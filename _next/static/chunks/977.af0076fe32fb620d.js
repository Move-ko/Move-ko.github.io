"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[977],{49977:function(n,t,e){e.r(t);var r=e(85893),s=e(41181),a=e(38154),o=e(15861),i=e(87357);t.default=()=>(0,r.jsxs)(s.ZP,{container:!0,children:[(0,r.jsxs)(s.ZP,{xs:12,sx:{textAlign:"center"},children:[(0,r.jsx)(i.Z,{sx:{width:"100%"},children:(0,r.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"모듈과 스크립트"})}),(0,r.jsxs)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move는 모듈(Module)과 스크립트(Script)를 제공하고 있습니다. 모듈은 구조체 타입과 이러한 타입에 작용하는 함수를 정의하는 라이브러리 이며 모듈 자체도 전역 스토리지에 저장됩니다. 구조체 타입은 Move의 전역 스토리지의 스키마를 정의하며, 모듈 함수는 스토리지를 업데이트하는 규칙을 정의합니다. 스크립트는 전통적인 언어에서의 main 함수와 유사한 실행 가능한 진입점이며 전역 스토리지에 게시되지 않는 일시적인 코드 조각입니다. 스크립트는 일반적으로 전역 스토리지에 대한 업데이트를 수행하는 게시된 모듈의 함수를 호출합니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move 소스 파일(또는 컴파일 단위)에는 여러 개의 모듈과 스크립트를 포함할 수 있습니다. 그러나 모듈을 게시하거나 스크립트를 실행하는 것은 별개의 VM(가상 머신) 작업입니다."})]}),(0,r.jsx)(i.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"스크립트"})}),(0,r.jsx)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"40px"},children:(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"스크립트 블록은 모든 사용 선언부로 시작해야 하며, 상수를 그 다음에 위치시킨 뒤 (마지막으로) 메인 함수 선언을 해야 합니다. 메인 함수는 어떤 이름으로든 사용할 수 있으며(main으로 명명할 필요는 없음), 스크립트 블록 내에서 유일한 함수여야 합니다. 인수의 개수에는 제한이 없으며, 값을 반환해서는 안 됩니다. 스크립트는 제한된 권한을 갖고 있으며, 친구(friends)를 선언하거나 구조체(struct types)를 정의하거나 전역 저장소에 접근할 수 없습니다. 스크립트의 주요 목적은 모듈 함수를 호출하는 것입니다."})}),(0,r.jsx)(a.Z,{code:"  script {\n    // std라는 이름을 가진 계정 주소에서 게시된 디버그 모듈을 가져옵니다.\n    use std::debug;//<use>\n\n    const ONE: u64 = 1; //<constants>:상수\n\n    fun main(x: u64) {  //fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>\n        let sum = x + ONE;\n        debug::print(&sum)\n    }\n}\n"}),(0,r.jsx)(i.Z,{sx:{width:"100%",marginTop:"40px"},children:(0,r.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"모듈"})}),(0,r.jsx)(a.Z,{code:"  module 0x42::example {  //<address>::<identifier>\n                                       //<use> | <friend> | <type> | <function> | <constant>\n    //*address:명명된 주소(  이름이 붙여진 주소) 또는 리터럴 주소\n    struct Example has copy, drop {\n       i: u64 \n       }\n\n    use std::debug;\n\n    friend 0x42::another_example;\n       \n    const ONE: u64 = 1; //*const:모듈의 함수에서 사용할수있는 전용 상수\n\n    public fun print(x: u64) {\n               let sum = x + ONE;\n               let example = Example { i: sum };\n               debug::print(&sum)\n    }\n}\n"}),(0,r.jsx)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"0x42::example 모듈 부분은 example 모듈이 글로벌 저장소의 0x42 주소에 있는 계정 아래에 게시될 것임을 지정합니다. 모듈은 명명된 주소(named addresses)를 사용하여 선언할 수도 있습니다. 예를 들어:"})}),(0,r.jsx)(a.Z,{code:"  module example_addr::example {}//0x42대신 example_addr로 대체\n"}),(0,r.jsx)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"명명된 주소는 소스 언어 수준에서만 존재하며, 컴파일 중에만 사용되므로, 바이트코드 수준에서 명명된 주소는 해당 값으로 완전히 대체됩니다. 예를 들어, 다음과 같은 코드가 있다고 가정해 봅시다:"})}),(0,r.jsx)(a.Z,{code:"  script {\n    fun example() {\n        my_addr::m::foo(@my_addr);\n    }\n}\n"}),(0,r.jsx)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"40px"},children:(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"그리고 my_addr을 0xC0FFEE로 설정하여 컴파일한다면, 실제로 다음과 같이 동작합니다:"})}),(0,r.jsx)(a.Z,{code:"  script {\n    fun example() {\n        0xC0FFEE::m::foo(@0xC0FFEE);\n    }\n}\n"}),(0,r.jsxs)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"하지만 소스 수준에서는 이러한 코드는 동등하지 않습니다. 함수 m::foo는 my_addr이라는 명명된 주소를 통해 접근되어야 하며, 해당 주소에 할당된 숫자 값으로는 접근할 수 없습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"모듈 이름은 영문자 a에서 z 또는 A에서 Z로 시작할 수 있습니다. 첫 번째 문자 이후에는 밑줄(_), 영문자 a에서 z, 영문자 A에서 Z 또는 숫자 0에서 9가 포함될 수 있습니다."})]}),(0,r.jsx)(a.Z,{code:"  module my_module {}\n  module foo_bar_42 {}\n"}),(0,r.jsxs)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 모듈 이름은 소문자로 시작합니다. my_module이라는 모듈은 my_module.move라는 소스 파일에 저장되어야 합니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"모듈 블록 내의 모든 요소는 어떤 순서로든 나타날 수 있습니다. 기본적으로 모듈은 타입과 함수의 집합입니다. use 키워드는 다른 모듈에서 타입을 가져오는 데 사용됩니다. friend 키워드는 신뢰할 수 있는 모듈의 목록을 지정합니다. const 키워드는 모듈의 함수에서 사용할 수 있는 비공개 상수를 정의합니다."})]}),(0,r.jsx)(i.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"\uD83E\uDD28모듈 특징정리"})})]}),(0,r.jsx)(s.ZP,{xs:0,md:2}),(0,r.jsx)(s.ZP,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,r.jsxs)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"1. 모듈 요소(사용, 상수, 함수 등)는 특정 순서로 구성되어야 합니다."}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["2.모듈은 ",(0,r.jsx)("span",{style:{color:"purple"},children:"전역저장소에"}),"저장됩니다."]}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈은 main이라는 함수를 포함해야 합니다."}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["4. ",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 모듈에서 유효합니다."]}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"5.모듈의 어떤 함수도 반환 값을 가질 수 없습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"6.모듈에는 하나의 함수만 선언할 수 있습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"7.친구 모듈은 모듈 내에서 유효합니다."}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["8.모듈은 ",(0,r.jsx)("span",{style:{color:"purple"},children:"주소"}),"와",(0,r.jsx)("span",{style:{color:"purple"},children:"식별자"}),"로 선언해야 합니다."]})]})}),(0,r.jsx)(s.ZP,{xs:0,md:2}),(0,r.jsx)(s.ZP,{xs:12,sx:{marginTop:"40px"},children:(0,r.jsx)(i.Z,{sx:{width:"100%"},children:(0,r.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"\uD83D\uDC69‍\uD83C\uDF93스크립트 특징정리"})})}),(0,r.jsx)(s.ZP,{xs:0,md:2}),(0,r.jsx)(s.ZP,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,r.jsxs)(i.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["1.스크립트는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"전역저장소"}),"에 저장되지 않습니다."]}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["2.스크립트 요소(사용, 상수, 함수 등)는",(0,r.jsx)("span",{style:{color:"purple"},children:"특정순서"}),"로 구성되어야 합니다."]}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"3.스크립트 블록에는 하나의 함수만 선언할 수 있습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"4. 스크립트 함수는 임의의 이름을 가질 수 있습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"5.상수는 스크립트에서 유효합니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"6.스크립트에는 하나의 함수만 선언할 수 있으며 이름은 main으로 지정해야 합니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"7.스크립트에 선언된 함수는 얼마든지 있을 수 있습니다."}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"8.friend 모듈은 스크립트에서 선언할 수 있습니다."}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["9.스크립트에서 선언된 함수는",(0,r.jsx)("span",{style:{color:"purple"},children:"매개변수"}),"를 가질 수 없습니다."]}),(0,r.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"10. 스크립트에서 선언된 함수는 반환 값을 가질 수 없습니다."}),(0,r.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["11. ",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 스크립트에서 유효합니다."]})]})}),(0,r.jsx)(s.ZP,{xs:0,md:2}),(0,r.jsx)(s.ZP,{xs:12,children:"ex)예시"}),(0,r.jsx)(s.ZP,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(a.Z,{code:"  // Example Module\n  module overmind::bananas {\n  \n      use std::vector;\n      use std::signer;\n  \n      struct BananaStore has key {\n          bushels: vector<Bushel>\n      }\n  \n      struct Bushel has store, drop {\n          bananas: vector<Banana>\n      }\n  \n      struct Banana has store, drop {}\n  \n      public entry fun buy_banana(buyer: &signer) acquires BananaStore {\n          let buyer_address = signer::address_of(buyer);\n  \n          if (!exists<BananaStore>(buyer_address)) {\n              move_to(\n                  buyer,\n                  BananaStore {\n                      bushels: vector<Bushel>[]\n                  }\n              );\n          };\n  \n          let bananaStore = borrow_global_mut<BananaStore>(buyer_address);\n  \n          let bushels_mut_ref = &mut bananaStore.bushels;\n  \n          let bushel_new = Bushel {\n              bananas: vector<Banana>[\n                  Banana {},\n                  Banana {},\n                  Banana {},\n                  Banana {}\n              ]\n          };\n  \n          vector::push_back<Bushel>(bushels_mut_ref, bushel_new);\n      }\n  \n      public entry fun eat_banana(account: &signer) acquires BananaStore {\n          let account_address = signer::address_of(account);\n  \n          let bananaStore = borrow_global_mut<BananaStore>(account_address);\n          let bushels_mut_ref = &mut bananaStore.bushels;\n          let first_bushel = vector::remove<Bushel>(bushels_mut_ref, 0);\n  \n          let _ = vector::pop_back<Banana>(&mut first_bushel.bananas);\n  \n          if (vector::length<Banana>(&mut first_bushel.bananas) != 0) {\n              vector::insert<Bushel>(bushels_mut_ref, 0, first_bushel);\n          }\n      }\n  }\n"})})]})},38154:function(n,t,e){e.d(t,{Z:function(){return l}});var r=e(85893),s=e(74855),a=e(34209),o=e(84283),i=e(90066),d=e(67294);function l(n){let{code:t}=n,[e,l]=(0,d.useState)(!1),[x,u]=(0,d.useState)(!1),[c,h]=(0,d.useState)(!1);return(0,r.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{u(!0)},onMouseLeave:()=>{u(!1)},children:[(0,r.jsx)(a.Z,{language:"javascript",style:o.cL,children:t}),(0,r.jsx)(s.CopyToClipboard,{text:t,children:(0,r.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),l(!0),h(!0),setTimeout(()=>{l(!1),h(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:x?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:c?(0,r.jsx)(i.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,r.jsx)(i.Z,{style:{color:e?"#fff":"#000",transition:"color 0.3s"}})})})]})}}}]);