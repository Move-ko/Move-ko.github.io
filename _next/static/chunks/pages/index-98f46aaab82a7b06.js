(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5405],{5557:function(e,s,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return r(2319)}])},2319:function(e,s,r){"use strict";r.r(s),r.d(s,{default:function(){return q}});var l=r(5893),i=r(7294),n=r(6274),x=r(4767),t=r(44),o=r(7357),d=r(5861),c=r(5697),h=r.n(c);r(2756);var a=e=>{let{children:s}=e;return(0,l.jsxs)(n.Z,{container:!0,children:[(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"\uD83E\uDDD0What is Move?"})})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Diem 블록체인의 구현을 위해 Rust언어에서 힌트를 받아 만들어졌으며,현재는 ",(0,l.jsx)("span",{style:{color:"purple"},children:"Aptos"})," ","및 ",(0,l.jsx)("span",{style:{color:"purple"},children:"Sui"}),"에서 사용하고 있습니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move를 사용하면 개발자가 자산을 유연하게 관리하고 전송하는 프로그램을 작성하는 동시에 해당 자산에 대한 공격에 방어(보안 및 보호)를 제공할수 있습니다."})]})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,md:4,children:(0,l.jsx)("img",{src:"/img/move.webp",style:{width:"100%",borderRadius:"10px",marginTop:"30px"}})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"특징"})})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 자산 보안: Move 언어는 자산의 보안성을 강조합니다. 타입 시스템을 사용하여 자산의 일관성과 불변성을 보장하며, 잠재적인 버그와 취약점을 예방하는데 도움이 됩니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"2.자산의 흐름 제어: Move 언어는 자산의 흐름을 제어하는 것을 강조합니다. 자산의 이동 및 전송에 대한 규칙과 제약을 명확하게 정의하여 보안과 논리적 일관성을 유지합니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈화: Move 언어는 모듈화를 지원하여 스마트 컨트랙트의 재사용성과 확장성을 향상시킵니다. 모듈은 독립적으로 작동하며 다른 모듈과 상호작용할 수 있습니다."})]})})]})},j=r(3321),p=r(1163),m=e=>{let{children:s}=e,r=(0,p.useRouter)();return(0,l.jsxs)(n.Z,{container:!0,children:[(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"1️⃣ 모듈과 스크립트"})})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,l.jsx)("span",{style:{color:"purple"},children:"모듈"})," 과"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"라는 두 가지 유형의 프로그램이 있습니다."," ",(0,l.jsx)("span",{style:{color:"purple"},children:"모듈"}),"은 이러한 유형에서 작동하는 함수와 함께 구조체 유형을 정의하는 라이브러리이며,구조체 유형은 Move의 전역저장소 스키마를 정의하고 모듈 함수는 저장소 업데이트 규칙을 정의하고 있으며,모듈은 전역저장소에 저장됩니다.",(0,l.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"는 전역저장소에 게시되지 않는 재사용 가능한 소스 코드, 이며, 일반적으로 전역저장소에 대한 업데이트를 수행하는 게시된 모듈의 기능을 호출합니다.또한 main스크립트는 기존 언어의 함수와 유사한 실행 가능한 진입점입니다."]}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 소스 파일("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"또는 컴파일 단위"})," )에는 여러 모듈과 스크립트가 포함될 수 있습니다. 그러나 모듈 게시 또는 스크립트 실행은 각각 별도의 VM 작업입니다."]})]})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"스크립트"})})}),(0,l.jsx)(n.Z,{xs:12,children:" ex)스크립트 구조"}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_1.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"20px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["script는 use("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"다른 모듈에서 유형을 가져오는데 사용하는 함수"}),")로 선언으로 시작하며 그 밑에 상수 그밑에 함수순으로 진행 되어야합니다.main함수는 어떤 이름이든 가질수 있으며(",(0,l.jsx)("span",{style:{color:"purple"},children:"main함수를 호출할 필요가 없음."}),")스크립트 내의 유일한 함수이며 인수를 얼마든지 가질수 있고 값은 반환할수 없습니다.또한 스크립트에는 스크립트는 권한이 매우 제한되어 있습니다(",(0,l.jsx)("span",{style:{color:"purple"},children:"Friends함수를 선언하거나 유형을 구성하거나 전역저장소에 접근 할 수 없습니다."}),")주요 목적은 모듈 함수를 호출하는 것입니다."]})})}),(0,l.jsxs)(n.Z,{xs:12,children:[(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"}}),(0,l.jsx)(d.Z,{children:(0,l.jsx)("span",{style:{color:"purple"},children:"* friend: 현재 모듈에서 신뢰하는 모듈을 선언하는 데 사용됩니다."})})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_2.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"모듈"})})}),(0,l.jsxs)(n.Z,{xs:12,children:[" ",(0,l.jsx)("span",{style:{color:"purple"},children:"*모듈 구조"})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_3.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 모듈 이름은 소문자로 시작합니다 명명된 모듈은 my_module명명된 소스파일에 저장되어야 합니다.모듈 블록 내의 모든 요소는 어떤 순서로든 나타날 수 있습니다. 기본적으로 모듈은 유형과 함수의 집합입니다."}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsxs)(o.Z,{sx:{width:"100%"},children:[(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsxs)("span",{style:{color:"purple"},children:["*address:명명된 주소("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),") 또는 리터럴 주소"]})}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsxs)("span",{style:{color:"purple"},children:["*const:모듈의 함수에서 사용할수있는 전용"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"상수"}),"를 지정"]})})]})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_4.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 module 0x42::example모듈의 부분은 모듈이 전역저장소의 계정주소로 게시되도록 지정합니다 모듈은 명명된 주소(",(0,l.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")를 사용하여 선언할수도 있습니다"]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_5.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")는 소스언어 수준과 컴파일 중에만 존재하기 떄문에 명명된 주소는 바이트코드 수준에서 해당 값을 완전히 대체합니다"]})})}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_6.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_6.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["my_addr로 설정하여 컴파일하면"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"0xC0FFEE"}),"운영상 다음과 동일합니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_7.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["그러나 소스 수준에서 이들은 동일하지 않습니다.함수는 해당 주소에 할당된 숫자값이 아니라 명명된 주소를 통해 엑세스 해야 m::foo합니다 모듈 이름은 문재 ",(0,l.jsx)("span",{style:{color:"purple"},children:"a to z"})," ","또는 ",(0,l.jsx)("span",{style:{color:"purple"},children:"Ato"}),"로 시작할수 있습니다"]}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["첫번쨰 문자 뒤에 모듈 이름에는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"밑줄 a~z,A~Z"}),"또는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"숫자"}),"가 포함될수 있습니다."]})]})}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83E\uDD28모듈 특징정리"})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 모듈 요소(사용, 상수, 함수 등)는 특정 순서로 구성되어야 합니다."}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.모듈은 ",(0,l.jsx)("span",{style:{color:"purple"},children:"전역저장소에"}),"저장됩니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈은 main이라는 함수를 포함해야 합니다."}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["4. ",(0,l.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 모듈에서 유효합니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.모듈의 어떤 함수도 반환 값을 가질 수 없습니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.모듈에는 하나의 함수만 선언할 수 있습니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.친구 모듈은 모듈 내에서 유효합니다."}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["8.모듈은 ",(0,l.jsx)("span",{style:{color:"purple"},children:"주소"}),"와"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"식별자"}),"로 선언해야 합니다."]})]})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83D\uDC69‍\uD83C\uDF93스크립트 특징정리"})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["1.스크립트는 ",(0,l.jsx)("span",{style:{color:"purple"},children:"전역저장소"}),"에 저장되지 않습니다."]}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.스크립트 요소(사용, 상수, 함수 등)는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"특정순서"}),"로 구성되어야 합니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.스크립트 블록에는 하나의 함수만 선언할 수 있습니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"4. 스크립트 함수는 임의의 이름을 가질 수 있습니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.상수는 스크립트에서 유효합니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.스크립트에는 하나의 함수만 선언할 수 있으며 이름은 main으로 지정해야 합니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.스크립트에 선언된 함수는 얼마든지 있을 수 있습니다."}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"8.friend 모듈은 스크립트에서 선언할 수 있습니다."}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["9.스크립트에서 선언된 함수는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"매개변수"}),"를 가질 수 없습니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"10. 스크립트에서 선언된 함수는 반환 값을 가질 수 없습니다."}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["11. ",(0,l.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 스크립트에서 유효합니다."]})]})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,children:"ex)예시"}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsxs)(n.Z,{xs:12,md:8,children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_9.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/1_9.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:2})]})},u=r(7906),Z=r(295),g=r(8102),v=r(9755),b=r(2882),y=r(3184),w=r(3816),B=r(629),T=r(948),_=e=>{let{children:s}=e,r=(0,p.useRouter)(),i=(0,T.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),x=(0,T.ZP)(w.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,l.jsxs)(n.Z,{container:!0,children:[(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"2️⃣ 정수"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move는 6개의 부호 없는 정수 유형("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128,u256"}),") 을 지원합니다.이러한 유형의 값 범위는 유형의 크기에 따라 0에서 최대값까지입니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"유형"}),(0,l.jsx)(i,{children:"값 범위"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{type:"부호 없는 8비트 정수,u8",range:"0 ~ 2^8 - 1"},{type:"부호 없는 16비트 정수,u16",range:"0 ~ 2^16 - 1"},{type:"부호 없는 32비트 정수,u32",range:"0 ~ 2^32 - 1"},{type:"부호 없는 64비트 정수,u64",range:"0 ~ 2^64 - 1"},{type:"부호 없는 128비트 정수,u128",range:"0 ~ 2^128 - 1"},{type:"부호 없는 256비트 정수,u256",range:"0 ~ 2^256 - 1"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.type}),(0,l.jsx)(i,{children:null==e?void 0:e.range})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"20px"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이러한 유형의 리터럴 값은 숫자의 연속으로 지정할 수 있습니다 예를 들어, ",(0,l.jsx)("span",{style:{color:"purple"},children:"112"}),"나"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"0xFF"}),"와 같이 사용할 수 있습니다. 리터럴의 유형은 선택적으로 접미사로 추가할 수 있습니다. 예를 들어, ",(0,l.jsx)("span",{style:{color:"purple"},children:"112u8"}),"과 같이 사용할 수 있습니다. 유형이 지정되지 않으면 컴파일러는 리터럴이 사용된 문맥에서 유형을 추론하려고 시도합니다. 유형을 추론할 수 없는 경우 u64로 가정합니다.숫자 리터럴은 그룹화와 가독성을 위해 밑줄로 구분할 수 있습니다.",(0,l.jsx)("span",{style:{color:"purple"},children:"(예: 1_234_5678, 1_000u128, 0xAB_CD_12_35)"}),". 리터럴이 지정된("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"또는 추론된"}),") 크기 범위보다 너무 큰 경우, 오류가 보고됩니다. 이는 정수 리터럴이 해당하는 유형의 범위를 초과하는 경우에 발생합니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_1.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"산술"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["각각의 유형은 동일한 집합의 체크된 산술 연산을 지원합니다. 이러한 모든 연산에서는 두 인수("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"왼쪽과 오른쪽 피연산자"}),")가 동일한 유형이어야 합니다. 서로 다른 유형의 값을 연산해야 하는 경우 먼저 형 변환을 수행해야 합니다. 마찬가지로, 연산 결과가 정수 유형에 너무 크다고 예상되는 경우 연산을 수행하기 전에 더 큰 크기로 형 변환을 수행해야 합니다. 모든 산술 연산은 수학적인 정수와는 달리"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"오버플로,언더플로,0으로 나누기"}),"와 같이 수학적으로 정수가 아닌 동작을 하지 않고 대신"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"중단"}),"됩니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"}),(0,l.jsx)(i,{children:"중단"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"+",작업:"덧셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"-",작업:"뺴기",중단:"결과가 0보다 작음"},{통사론:"*",작업:"곱셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"%",작업:"모듈식 분할",중단:"제수는 0"},{통사론:"/",작업:"잘림 나누기",중단:"제수는 0"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업}),(0,l.jsx)(i,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트연산"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsxs)(o.Z,{sx:{width:"100%"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,sx:{textAlign:"left"},children:["정수 유형은 다음과 같은 비트 연산을 지원합니다. 이러한 연산은 각 숫자를 0 또는 1로 구성된 개별적인 비트 시퀀스로 취급하며 숫자적인 정수 값으로 취급하지 않습니다."," "]}),(0,l.jsxs)(d.Z,{children:[" ",(0,l.jsx)("span",{style:{color:"purple"},children:"* 비트 연산은 중단되지 않습니다."})]})]})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"}),(0,l.jsx)(i,{children:"설명"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"&",작업:"비트 및",설명:"부울을 수행하고 각 비트에 대해 쌍으로"},{통사론:"|",작업:"비트 또는",설명:"부울 또는 각 비트에 대해 쌍으로 수행"},{통사론:"^",작업:"비트 xor",설명:"부을 독점 또는 각 비트에 대해 쌍으로 수행"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업}),(0,l.jsx)(i,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트시프트"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["비트 연산과 유사하게, 각 정수 유형은 비트 시프트를 지원합니다. 그러나 다른 연산과 달리, 우측 피연산자(시프트할 비트 수)는 항상",(0,l.jsx)("span",{style:{color:"purple"},children:"u8"}),"이어야 하며 좌측 피연산자( ",(0,l.jsx)("span",{style:{color:"purple"},children:"시프트할 숫자"}),")와 일치할 필요는 없습니다.비트 시프트는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128 , u256"}),"에 대해 각각"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"8, 16, 32, 64, 128, 256"}),"보다"," ",(0,l.jsxs)("span",{style:{color:"purple"},children:[" ","크거나 같은 비트 수로 시프트할 경우 중지될 수 있습니다."]})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"}),(0,l.jsx)(i,{children:"중단"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"<<",작업:"왼쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"},{통사론:">>",작업:"오른쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업}),(0,l.jsx)(i,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비교 연산자"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 정수 유형만이 비교 연산자를 사용할 수 있습니다. 비교 연산자를 사용할 때는 두 인자가 동일한 유형이어야 합니다. 만약 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 한 쪽을 형변환해야 합니다. Move에서의 비교 연산은"," ",(0,l.jsx)("span",{style:{color:"purple"},children:" 중단되지 않습니다."})," 이는 비교 연산이 갑작스럽게 종료되거나 오류를 발생시키지 않는다는 것을 의미합니다. 대신, 비교 연산은 비교 결과를 나타내는 불리언 값 ("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"참 또는 거짓"}),")을 반환합니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"<",작업:"보다 작은"},{통사론:">",작업:"보다큰"},{통사론:"<=",작업:"작거나 같음"},{통사론:">=",작업:"크거나 같음"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"평등"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move의 모든 정수 유형은"," ",(0,l.jsx)("span",{style:{color:"purple"},children:'"equal"'}),"과",(0,l.jsx)("span",{style:{color:"purple"},children:'"not equal"'})," 연산을 지원합니다. 두 인자는 동일한 유형이어야 합니다. 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 하나를 형변환해야 합니다."," ",(0,l.jsx)("span",{style:{color:"purple"},children:"등호 연산은 중단되지 않습니다."})," "]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"==",작업:"같은"},{통사론:"!=",작업:"같지않은"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형변환"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 한 크기의 정수 유형을 다른 크기의 정수 유형으로"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"형변환"})," 할 수 있습니다. 정수는 Move에서 형변환를 지원하는 유일한 유형입니다. 정수를 크기가 다른 유형으로 형변환 할 때, Move에서는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"형변환이 값을 절단하지 않는다는 점"}),"에 유의해야 합니다. 이는 형변환 연산이 원래 정수의 전체 값을 보존한다는 것을 의미합니다. 즉, 목표 정수 유형의 범위를 초과하는 경우에도 원래 정수의 전체 값이 유지됩니다. 그러나, 형변환의 결과가 지정된 유형에 너무 큰 경우 형변환이 중단될 수 있다는 점을 알려드립니다. 이는형변환 결과가 지정된 유형에 맞지 않을 때 형변환이 중단되는 것을 의미합니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(i,{children:"통사론"}),(0,l.jsx)(i,{children:"작업"}),(0,l.jsx)(i,{children:"다음과 같은 경우 중단"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"(e as T)",작업:"e 정수 표현식을 정수 유형으로형변환T",설명:"e로 표현하기에는 너무 큽니다"}].map(e=>(0,l.jsxs)(x,{children:[(0,l.jsx)(i,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(i,{children:null==e?void 0:e.작업}),(0,l.jsx)(i,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 언어에 내장된 정수 값들도 암묵적으로 복사 가능한 속성을 갖고 있습니다.",(0,l.jsx)("span",{style:{color:"purple"},children:"이는 복사와 같은 명시적 명령 없이도 복사될 수 있다는 것을 의미"})," ","합니다. 정수 값을 새 변수에 할당하거나 함수 인자로 전달할 때, 해당 값의 복사본이 생성됩니다. 원본 값과 복사본은 서로 독립적으로 사용될 수 있으며, 한 쪽 복사본을 수정해도 다른 쪽에는 영향을 미치지 않습니다. 이러한 복사 연산은 내부적으로 암묵적으로 처리됩니다. 예를 들어:"]})})}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_2.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:12,sx:{textAlign:"left",marginTop:"30px"},children:[" ",(0,l.jsxs)(d.Z,{children:["이 경우,"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"x의 값이 y로 복사되며, x와 y는 각각 정수 값의 독립적인 복사본을 가지고 있습니다."}),"y를 수정해도 x의 값에는 영향을 주지 않으며, 그 반대도 마찬가지입니다. 이러한 암묵적인 복사 동작은 명시적인 복사 명령 없이도 정수 값을 간편하게 처리할 수 있도록 해줍니다. 그러나 보다 복잡한 유형과 리소스의 경우, Move에서는 소유권과 빌림에 대한 명시적인 지침이나 고려 사항이 필요할 수 있습니다."]})]})]})},f=e=>{let{children:s}=e,r=(0,T.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:s.palette.common.black,color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:10}}}),i=(0,T.ZP)(w.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.action.hover},"&:last-child td, &:last-child th":{border:0}}});return(0,l.jsxs)(n.Z,{container:!0,children:[(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"부울"})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,l.jsx)("span",{style:{color:"purple"},children:"부울"}),"은 Move에서 boolean"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"true"}),"와"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"false"})," 값을 표현하기 위한 원시 타입입니다.또한 bool 타입의 리터럴은 true 또는 false로 표현됩니다."]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"* bool은 세가지 논리 연산을 지원합니다."})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,l.jsx)(b.Z,{component:B.Z,children:(0,l.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,l.jsx)(y.Z,{children:(0,l.jsxs)(w.Z,{children:[(0,l.jsx)(r,{children:"통사론"}),(0,l.jsx)(r,{children:"설명"}),(0,l.jsx)(r,{children:"등가표현"})]})}),(0,l.jsx)(Z.Z,{component:"div",children:[{통사론:"&&",설명:"단락 논리 및",등가표현:"p && q에 해당합니다 if(p)q else false"},{통사론:"||",설명:"단락 논리 또는",등가표현:"p || q 에 해당합니다 if(p) true else q"},{통사론:"!",설명:"논리적 부정",등가표현:"!p에 해당합니다 if(q) false else true"}].map(e=>(0,l.jsxs)(i,{children:[(0,l.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,l.jsx)(r,{children:null==e?void 0:e.설명}),(0,l.jsx)(r,{children:null==e?void 0:e.등가표현})]},null==e?void 0:e.drop_name))})]})})}),(0,l.jsx)(n.Z,{xs:0,md:2}),(0,l.jsx)(n.Z,{xs:12,md:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"bool 값은 Move의 여러 제어 흐름 구조에서 사용됩니다:"})})}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"* if문"})})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,l.jsx)("img",{src:"/img/3_2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"* while문"})})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,l.jsx)("img",{src:"/img/3_2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"3) assert:이 연산은 두 개의 인자를 받습니다: bool 타입의 조건과 u64 타입의 코드"})})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,l.jsx)("img",{src:"/img/3_2_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,l.jsx)(n.Z,{xs:0,md:4}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다른 스칼라 값들과 마찬가지로, 언어 내장의 boolean 값들은 암시적으로 복사 가능합니다. 즉, copy와 같은 명시적인 지시어 없이도 복사할 수 있습니다."})})})]})},M=e=>{let{children:s}=e;return(0,l.jsxs)(n.Z,{container:!0,children:[(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"주소"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,l.jsx)("span",{style:{color:"purple"},children:"주소(Address)"})," 는 Move 언어에서 글로벌 스토리지의 위치(가끔은 계정이라고도 함)를 나타내기 위해 사용되는 내장된 유형입니다. 주소 값은"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"128비트(16바이트)"}),"식별자입니다. 특정 주소에는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"모듈(Module)"}),"과",(0,l.jsx)("span",{style:{color:"purple"},children:"리소스(Resource)"}),"두 가지 요소를 저장할 수 있습니다."]}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["실제로 주소는 128비트 정수로 구성되지만, Move 주소는 의도적으로 불투명한 형태로 구성되어 있습니다. 즉, 정수로부터 주소를 생성할 수 없으며, 산술 연산을 지원하지 않으며, 수정할 수 없습니다. 포인터 산술과 유사한 용도로 사용될 수 있는 흥미로운 프로그램이 있을 수 있지만 (예: C의 포인터 산술), Move는 정적 검증을 지원하기 위해 처음부터",(0,l.jsx)("span",{style:{color:"purple"},children:"이러한 동적 동작을 허용하지 않습니다."})]}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["런타임 주소 값("," ",(0,l.jsx)("span",{style:{color:"purple"},children:"주소 유형의 값"}),")을 사용하여 해당 주소에 있는 리소스에 접근할 수 있습니다. 주소 값을 통해 런타임에서 모듈에 액세스할 수는 없습니다."]})]})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"문법"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsxs)(o.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소는 ",(0,l.jsx)("span",{style:{color:"purple"},children:"명명된(named) 주소"}),"와",(0,l.jsx)("span",{style:{color:"purple"},children:"숫자형(numerical) 주소"})," 로 두 가지 형태로 나뉩니다. 명명된 주소의 구문은 Move에서 일반적으로 사용되는 명명된 식별자의 규칙을 따릅니다. 숫자형 주소의 구문은 16진수로 인코딩된 값에 제한되지 않으며, 유효한 u128 숫자 값으로 주소 값으로 사용할 수 있습니다. 예를 들어,"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"42, 0xCAFE, 2021"})," 은 모두 유효한 숫자형 주소 리터럴입니다."]}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"주소가 식(expression) 컨텍스트에서 사용되는지 여부를 구분하기 위해 주소를 사용하는 구문은 사용되는 컨텍스트에 따라 다릅니다:"}),(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소가 식으로 사용될 때는 주소 앞에 @ 문자가 붙어야 합니다. 즉,"," ",(0,l.jsxs)("span",{style:{color:"purple"},children:[" ","@<numerical_value>"]})," ","또는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"@<named_address_identifier>"})," ","형태여야 합니다. 식 컨텍스트 이외의 곳에서는 주소를 @ 문자 없이 쓸 수 있습니다. 즉,"," ",(0,l.jsx)("span",{style:{color:"purple"},children:" <numerical_value>"})," 또는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"<named_address_identifier>"})," ","형태로 쓸 수 있습니다. 일반적으로 @는 주소를 네임스페이스 항목에서 식 항목으로 전환하는 연산자로 생각할 수 있습니다."]})]})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"명명된 주소"})})}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,l.jsx)(j.Z,{variant:"contained",size:"medium",onClick:e=>{router.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/4_1.move")},children:"Code"}),(0,l.jsx)("img",{src:"/img/4_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,l.jsx)(n.Z,{xs:0,md:3}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소(named addresses)는 주소가 사용되는 모든 위치에서 숫자 값 대신 식별자를 사용할 수 있도록 하는 기능입니다. 명명된 주소는 Move 패키지의 최상위 요소(모듈 및 스크립트 외부)로 선언되고 바인딩됩니다. 또한 Move 컴파일러에 인수로 전달될 수도 있습니다. 명명된 주소는 값 수준뿐만 아니라 주소가 사용되는"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"모든 위치"}),"에서 사용될 수 있으며, 소스 언어 수준에서만 존재하며 바이트코드 수준에서는 완전히 해당 값을 ",(0,l.jsx)("span",{style:{color:"purple"},children:"대체"}),"합니다. 따라서 모듈과 모듈 멤버는 모듈의 명명된 주소를 통해 접근해야 하며, 명명된 주소에 할당된 숫자 값으로 모듈 및 모듈 멤버에 접근해서는 안 됩니다. 예를 들어,",(0,l.jsx)("span",{style:{color:"purple"},children:"my_addr이 0x2로 설정된 상태"})," ","에서 Move 프로그램이 컴파일되더라도"," ",(0,l.jsx)("span",{style:{color:"purple"},children:"use my_addr::foo는 use 0x2::foo와 동일하지 않습니다"}),". 이 차이점은 모듈과 스크립트 섹션에서 자세히 논의됩니다."]})})}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"글로벌 스토리지 운영"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소 값의 주요 목적은 글로벌 스토리지 작업과 상호 작용하는 데에 있습니다. 주소 값은",(0,l.jsx)("span",{style:{color:"purple"},children:"exists, borrow_global, borrow_global_mut, move_from"})," ","등의 작업과 함께 사용됩니다. 주소를 사용하지 않는 유일한 글로벌 스토리지 작업은 ",(0,l.jsx)("span",{style:{color:"purple"},children:"move_to"}),"입니다. move_to 작업은",(0,l.jsx)("span",{style:{color:"purple"},children:"signer"})," 를 사용합니다."]})})}),(0,l.jsxs)(n.Z,{xs:12,sx:{marginTop:"10px"},children:[(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"*exists: 주소 아래에 T가 저장되어 있으면 true를 반환"})}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"*borrow_global:address 아래에 저장된 T에 대한 불변 참조를 반환합"})}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"* borrow_global_mut:address 아래에 저장된 T에 대한 변경 가능한 참조를 반환"})}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"*move_from:T 주소에서 T를 제거하고 반환"})}),(0,l.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,l.jsx)("span",{style:{color:"purple"},children:"* move_to:signer.address 아래에 T를 게시"})})]}),(0,l.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,l.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,l.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,l.jsx)(o.Z,{sx:{width:"100%",textAlign:"left"},children:(0,l.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:['언어에 내장된 다른 스칼라 값과 마찬가지로 주소 값도 암시적으로 복사 가능(copyable)합니다. 이는 "copy"와 같은',(0,l.jsx)("span",{style:{color:"purple"},children:"명시적인 명령 없이도 주소 값이 복사될 수 있다는 것을 의미"})," ","합니다. 주소 값을 새 변수에 할당하거나 함수에 인수로 전달할 때, 주소 값의 복사본이 생성되며 원본과 복사본 주소 모두 독립적으로 사용할 수 있습니다."]})})})]})},k=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"벡터"})})})})},C=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"서명자"})})})})},A=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"참조"})})})})},z=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"튜플 및 단위"})})})})},R=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"지역변수 및 범위"})})})})},D=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"평등"})})})})},E=e=>{let{children:s}=e;return(0,l.jsx)(n.Z,{container:!0,children:(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsx)(o.Z,{sx:{width:"100%"},children:(0,l.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"중단 및 어셜션"})})})})};function q(){let[e,s]=(0,i.useState)(!1),[r,c]=(0,i.useState)(0);function j(e){let{children:s,value:r,index:i,...n}=e;return(0,l.jsx)("div",{style:{textAlign:"center",width:"80%"},role:"tabpanel",hidden:r!==i,id:"vertical-tabpanel-".concat(i),"aria-labelledby":"vertical-tab-".concat(i),...n,children:r===i&&(0,l.jsx)(o.Z,{sx:{p:10,color:"white"},children:(0,l.jsx)(d.Z,{children:s})})})}function p(e){return{id:"vertical-tab-".concat(e),"aria-controls":"vertical-tabpanel-".concat(e)}}return(0,i.useEffect)(()=>{s(!0)},[]),j.propTypes={children:h().node,index:h().number.isRequired,value:h().number.isRequired},e&&(0,l.jsxs)(n.Z,{container:!0,sx:{marginTop:"84px"},children:[(0,l.jsxs)(n.Z,{xs:12,sx:{backgroundColor:" #171B1C",textAlign:"center",fontSize:"300%",color:"white"},children:[" ",(0,l.jsx)("img",{src:"/img/move.webp",style:{width:"50px"}}),(0,l.jsx)("div",{children:"MOVE BOOK"})]}),(0,l.jsx)(n.Z,{xs:12,children:(0,l.jsxs)(o.Z,{sx:{flexGrow:1,bgcolor:" #171B1C",display:"flex",minHeight:"600px",textAlign:"center"},children:[(0,l.jsxs)(x.Z,{orientation:"vertical",variant:"scrollable",value:r,onChange:(e,s)=>{c(s)},"aria-label":"Vertical tabs example",sx:{borderRight:1,borderColor:" #171B1C",width:"16%",color:"white"},children:[(0,l.jsx)(t.Z,{sx:{color:"white"},label:"0️⃣ 소개 및 설치",...p(0)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣ 모듈 및 스크립트",...p(1)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣ 정수",...p(2)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"3️⃣ 부울",...p(3)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"4️⃣ 주소",...p(4)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"5️⃣ 벡터",...p(5)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"6️⃣ 서명자",...p(6)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"7️⃣ 참조",...p(7)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"8️⃣ 튜플 및 단위",...p(8)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"9️⃣ 지역 변수 및 범위",...p(9)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"\uD83D\uDD1F 평등",...p(10)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣1️⃣ 중단 및 어성셜",...p(11)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣2️⃣ 조건부",...p(12)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣3️⃣ 반복문",...p(13)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣4️⃣ 기능",...p(14)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣5️⃣ 구조체 리소스",...p(15)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣6️⃣ 상수",...p(16)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣7️⃣ 제네릭",...p(17)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣8️⃣ 능력",...p(18)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"1️⃣9️⃣ 용도 및 별칭",...p(19)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣0️⃣ 친구",...p(20)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣1️⃣ 패키지",...p(21)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣2️⃣ 패키지 업그레이드",...p(22)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣3️⃣ 단위 및 테스트",...p(23)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣4️⃣ 글로벌 스토리지 구조",...p(24)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣5️⃣ 글로벌 스토리지 사업자",...p(25)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣6️⃣ 도서관",...p(26)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"2️⃣7️⃣ 코딩 규칙 이동",...p(27)}),(0,l.jsx)(t.Z,{sx:{color:"white"},label:"\uD83E\uDD28 tutorial",...p(28)})]}),(0,l.jsx)(j,{value:r,index:0,children:(0,l.jsx)(a,{})}),(0,l.jsx)(j,{value:r,index:1,children:(0,l.jsx)(m,{})}),(0,l.jsx)(j,{value:r,index:2,children:(0,l.jsx)(_,{})}),(0,l.jsx)(j,{value:r,index:3,children:(0,l.jsx)(f,{})}),(0,l.jsx)(j,{value:r,index:4,children:(0,l.jsx)(M,{})}),(0,l.jsx)(j,{value:r,index:5,children:(0,l.jsx)(k,{})}),(0,l.jsx)(j,{value:r,index:6,children:(0,l.jsx)(C,{})}),(0,l.jsx)(j,{value:r,index:7,children:(0,l.jsx)(A,{})}),(0,l.jsx)(j,{value:r,index:8,children:(0,l.jsx)(z,{})}),(0,l.jsx)(j,{value:r,index:9,children:(0,l.jsx)(R,{})}),(0,l.jsx)(j,{value:r,index:10,children:(0,l.jsx)(D,{})}),(0,l.jsx)(j,{value:r,index:11,children:(0,l.jsx)(E,{})}),(0,l.jsx)(j,{value:r,index:12,children:"5"}),(0,l.jsx)(j,{value:r,index:13,children:"5"}),(0,l.jsx)(j,{value:r,index:14,children:"5"}),(0,l.jsx)(j,{value:r,index:15,children:"5"}),(0,l.jsx)(j,{value:r,index:16,children:"16장"}),(0,l.jsx)(j,{value:r,index:17,children:"16장"}),(0,l.jsx)(j,{value:r,index:18,children:"16장"}),(0,l.jsx)(j,{value:r,index:19,children:"16장"}),(0,l.jsx)(j,{value:r,index:20,children:"16장"}),(0,l.jsx)(j,{value:r,index:21,children:"16장"}),(0,l.jsx)(j,{value:r,index:22,children:"16장"}),(0,l.jsx)(j,{value:r,index:23,children:"16장"}),(0,l.jsx)(j,{value:r,index:24,children:"16장"}),(0,l.jsx)(j,{value:r,index:25,children:"16장"}),(0,l.jsx)(j,{value:r,index:26,children:"16장"}),(0,l.jsx)(j,{value:r,index:27,children:"마지막"}),(0,l.jsx)(j,{value:r,index:28,children:"튜토리얼"})]})})]})}}},function(e){e.O(0,[7366,9774,2888,179],function(){return e(e.s=5557)}),_N_E=e.O()}]);