(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{75557:function(e,s,x){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return x(91225)}])},91225:function(e,s,x){"use strict";x.r(s),x.d(s,{default:function(){return Y}});var t=x(85893),r=x(67294),n=x(79713),i=x(39998),l=x(40044),d=x(87357),o=x(15861),c=x(45697),h=x.n(c),a=()=>(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"\uD83E\uDDD0What is Move?"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Diem 블록체인의 구현을 위해 Rust언어에서 힌트를 받아 만들어졌으며,현재는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"Aptos"})," ","및 ",(0,t.jsx)("span",{style:{color:"purple"},children:"Sui"}),"에서 사용하고 있습니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move를 사용하면 개발자가 자산을 유연하게 관리하고 전송하는 프로그램을 작성하는 동시에 해당 자산에 대한 공격에 방어(보안 및 보호)를 제공할수 있습니다."})]})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,children:(0,t.jsx)("img",{src:"/img/move.webp",style:{width:"100%",borderRadius:"10px",marginTop:"30px"}})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"특징"})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"1. 자산 보안: Move 언어는 자산의 보안성을 강조합니다. 타입 시스템을 사용하여 자산의 일관성과 불변성을 보장하며, 잠재적인 버그와 취약점을 예방하는데 도움이 됩니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"2.자산의 흐름 제어: Move 언어는 자산의 흐름을 제어하는 것을 강조합니다. 자산의 이동 및 전송에 대한 규칙과 제약을 명확하게 정의하여 보안과 논리적 일관성을 유지합니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈화: Move 언어는 모듈화를 지원하여 스마트 컨트랙트의 재사용성과 확장성을 향상시킵니다. 모듈은 독립적으로 작동하며 다른 모듈과 상호작용할 수 있습니다."})]})})]}),p=x(83321),j=x(11163),m=()=>{let e=(0,j.useRouter)();return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"1️⃣ 모듈과 스크립트"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"모듈"})," 과"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"라는 두 가지 유형의 프로그램이 있습니다."," ",(0,t.jsx)("span",{style:{color:"purple"},children:"모듈"}),"은 이러한 유형에서 작동하는 함수와 함께 구조체 유형을 정의하는 라이브러리이며,구조체 유형은 Move의 전역저장소 스키마를 정의하고 모듈 함수는 저장소 업데이트 규칙을 정의하고 있으며,모듈은 전역저장소에 저장됩니다.",(0,t.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"는 전역저장소에 게시되지 않는 재사용 가능한 소스 코드, 이며, 일반적으로 전역저장소에 대한 업데이트를 수행하는 게시된 모듈의 기능을 호출합니다.또한 main스크립트는 기존 언어의 함수와 유사한 실행 가능한 진입점입니다."]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move 소스 파일("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"또는 컴파일 단위"})," )에는 여러 모듈과 스크립트가 포함될 수 있습니다. 그러나 모듈 게시 또는 스크립트 실행은 각각 별도의 VM 작업입니다."]})]})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"스크립트"})})}),(0,t.jsx)(n.Z,{xs:12,children:" ex)스크립트 구조"}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_1.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"20px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["script는 use("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"다른 모듈에서 유형을 가져오는데 사용하는 함수"}),")로 선언으로 시작하며 그 밑에 상수 그밑에 함수순으로 진행 되어야합니다.main함수는 어떤 이름이든 가질수 있으며(",(0,t.jsx)("span",{style:{color:"purple"},children:"main함수를 호출할 필요가 없음."}),")스크립트 내의 유일한 함수이며 인수를 얼마든지 가질수 있고 값은 반환할수 없습니다.또한 스크립트에는 스크립트는 권한이 매우 제한되어 있습니다(",(0,t.jsx)("span",{style:{color:"purple"},children:"Friends함수를 선언하거나 유형을 구성하거나 전역저장소에 접근 할 수 없습니다."}),")주요 목적은 모듈 함수를 호출하는 것입니다."]})})}),(0,t.jsxs)(n.Z,{xs:12,children:[(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"}}),(0,t.jsx)(o.Z,{children:(0,t.jsx)("span",{style:{color:"purple"},children:"* friend: 현재 모듈에서 신뢰하는 모듈을 선언하는 데 사용됩니다."})})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_2.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"모듈"})})}),(0,t.jsxs)(n.Z,{xs:12,children:[" ",(0,t.jsx)("span",{style:{color:"purple"},children:"*모듈 구조"})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_3.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 모듈 이름은 소문자로 시작합니다 명명된 모듈은 my_module명명된 소스파일에 저장되어야 합니다.모듈 블록 내의 모든 요소는 어떤 순서로든 나타날 수 있습니다. 기본적으로 모듈은 유형과 함수의 집합입니다."}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%"},children:[(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsxs)("span",{style:{color:"purple"},children:["*address:명명된 주소("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),") 또는 리터럴 주소"]})}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsxs)("span",{style:{color:"purple"},children:["*const:모듈의 함수에서 사용할수있는 전용"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"상수"}),"를 지정"]})})]})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_4.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이 module 0x42::example모듈의 부분은 모듈이 전역저장소의 계정주소로 게시되도록 지정합니다 모듈은 명명된 주소(",(0,t.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")를 사용하여 선언할수도 있습니다"]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_5.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")는 소스언어 수준과 컴파일 중에만 존재하기 떄문에 명명된 주소는 바이트코드 수준에서 해당 값을 완전히 대체합니다"]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_6.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_6.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["my_addr로 설정하여 컴파일하면"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"0xC0FFEE"}),"운영상 다음과 동일합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_7.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["그러나 소스 수준에서 이들은 동일하지 않습니다.함수는 해당 주소에 할당된 숫자값이 아니라 명명된 주소를 통해 엑세스 해야 m::foo합니다 모듈 이름은 문재 ",(0,t.jsx)("span",{style:{color:"purple"},children:"a to z"})," ","또는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"Ato"}),"로 시작할수 있습니다"]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["첫번쨰 문자 뒤에 모듈 이름에는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"밑줄 a~z,A~Z"}),"또는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"숫자"}),"가 포함될수 있습니다."]})]})}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"\uD83E\uDD28모듈 특징정리"})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"1. 모듈 요소(사용, 상수, 함수 등)는 특정 순서로 구성되어야 합니다."}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["2.모듈은 ",(0,t.jsx)("span",{style:{color:"purple"},children:"전역저장소에"}),"저장됩니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈은 main이라는 함수를 포함해야 합니다."}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["4. ",(0,t.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 모듈에서 유효합니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"5.모듈의 어떤 함수도 반환 값을 가질 수 없습니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"6.모듈에는 하나의 함수만 선언할 수 있습니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"7.친구 모듈은 모듈 내에서 유효합니다."}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["8.모듈은 ",(0,t.jsx)("span",{style:{color:"purple"},children:"주소"}),"와"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"식별자"}),"로 선언해야 합니다."]})]})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"\uD83D\uDC69‍\uD83C\uDF93스크립트 특징정리"})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["1.스크립트는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"전역저장소"}),"에 저장되지 않습니다."]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["2.스크립트 요소(사용, 상수, 함수 등)는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"특정순서"}),"로 구성되어야 합니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"3.스크립트 블록에는 하나의 함수만 선언할 수 있습니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"4. 스크립트 함수는 임의의 이름을 가질 수 있습니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"5.상수는 스크립트에서 유효합니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"6.스크립트에는 하나의 함수만 선언할 수 있으며 이름은 main으로 지정해야 합니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"7.스크립트에 선언된 함수는 얼마든지 있을 수 있습니다."}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"8.friend 모듈은 스크립트에서 선언할 수 있습니다."}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["9.스크립트에서 선언된 함수는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"매개변수"}),"를 가질 수 없습니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"10. 스크립트에서 선언된 함수는 반환 값을 가질 수 없습니다."}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["11. ",(0,t.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 스크립트에서 유효합니다."]})]})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,children:"ex)예시"}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsxs)(n.Z,{xs:12,md:8,children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_9.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/1_9.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:2})]})},Z=x(7906),u=x(295),g=x(98102),v=x(89755),y=x(72882),b=x(53184),T=x(53816),w=x(90629),f=x(90948),B=()=>{let e=(0,j.useRouter)(),s=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),x=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"2️⃣ 정수"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move는 6개의 부호 없는 정수 유형("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128,u256"}),") 을 지원합니다.이러한 유형의 값 범위는 유형의 크기에 따라 0에서 최대값까지입니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"유형"}),(0,t.jsx)(s,{children:"값 범위"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{type:"부호 없는 8비트 정수,u8",range:"0 ~ 2^8 - 1"},{type:"부호 없는 16비트 정수,u16",range:"0 ~ 2^16 - 1"},{type:"부호 없는 32비트 정수,u32",range:"0 ~ 2^32 - 1"},{type:"부호 없는 64비트 정수,u64",range:"0 ~ 2^64 - 1"},{type:"부호 없는 128비트 정수,u128",range:"0 ~ 2^128 - 1"},{type:"부호 없는 256비트 정수,u256",range:"0 ~ 2^256 - 1"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.type}),(0,t.jsx)(s,{children:null==e?void 0:e.range})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left",marginTop:"20px"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이러한 유형의 리터럴 값은 숫자의 연속으로 지정할 수 있습니다 예를 들어, ",(0,t.jsx)("span",{style:{color:"purple"},children:"112"}),"나"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"0xFF"}),"와 같이 사용할 수 있습니다. 리터럴의 유형은 선택적으로 접미사로 추가할 수 있습니다. 예를 들어, ",(0,t.jsx)("span",{style:{color:"purple"},children:"112u8"}),"과 같이 사용할 수 있습니다. 유형이 지정되지 않으면 컴파일러는 리터럴이 사용된 문맥에서 유형을 추론하려고 시도합니다. 유형을 추론할 수 없는 경우 u64로 가정합니다.숫자 리터럴은 그룹화와 가독성을 위해 밑줄로 구분할 수 있습니다.",(0,t.jsx)("span",{style:{color:"purple"},children:"(예: 1_234_5678, 1_000u128, 0xAB_CD_12_35)"}),". 리터럴이 지정된("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"또는 추론된"}),") 크기 범위보다 너무 큰 경우, 오류가 보고됩니다. 이는 정수 리터럴이 해당하는 유형의 범위를 초과하는 경우에 발생합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_1.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"산술"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["각각의 유형은 동일한 집합의 체크된 산술 연산을 지원합니다. 이러한 모든 연산에서는 두 인수("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"왼쪽과 오른쪽 피연산자"}),")가 동일한 유형이어야 합니다. 서로 다른 유형의 값을 연산해야 하는 경우 먼저 형 변환을 수행해야 합니다. 마찬가지로, 연산 결과가 정수 유형에 너무 크다고 예상되는 경우 연산을 수행하기 전에 더 큰 크기로 형 변환을 수행해야 합니다. 모든 산술 연산은 수학적인 정수와는 달리"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"오버플로,언더플로,0으로 나누기"}),"와 같이 수학적으로 정수가 아닌 동작을 하지 않고 대신"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"중단"}),"됩니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"}),(0,t.jsx)(s,{children:"중단"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"+",작업:"덧셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"-",작업:"뺴기",중단:"결과가 0보다 작음"},{통사론:"*",작업:"곱셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"%",작업:"모듈식 분할",중단:"제수는 0"},{통사론:"/",작업:"잘림 나누기",중단:"제수는 0"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업}),(0,t.jsx)(s,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"비트연산"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,sx:{textAlign:"left"},children:["정수 유형은 다음과 같은 비트 연산을 지원합니다. 이러한 연산은 각 숫자를 0 또는 1로 구성된 개별적인 비트 시퀀스로 취급하며 숫자적인 정수 값으로 취급하지 않습니다."," "]}),(0,t.jsxs)(o.Z,{children:[" ",(0,t.jsx)("span",{style:{color:"purple"},children:"* 비트 연산은 중단되지 않습니다."})]})]})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"}),(0,t.jsx)(s,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"&",작업:"비트 및",설명:"부울을 수행하고 각 비트에 대해 쌍으로"},{통사론:"|",작업:"비트 또는",설명:"부울 또는 각 비트에 대해 쌍으로 수행"},{통사론:"^",작업:"비트 xor",설명:"부을 독점 또는 각 비트에 대해 쌍으로 수행"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업}),(0,t.jsx)(s,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"비트시프트"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["비트 연산과 유사하게, 각 정수 유형은 비트 시프트를 지원합니다. 그러나 다른 연산과 달리, 우측 피연산자(시프트할 비트 수)는 항상",(0,t.jsx)("span",{style:{color:"purple"},children:"u8"}),"이어야 하며 좌측 피연산자( ",(0,t.jsx)("span",{style:{color:"purple"},children:"시프트할 숫자"}),")와 일치할 필요는 없습니다.비트 시프트는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128 , u256"}),"에 대해 각각"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"8, 16, 32, 64, 128, 256"}),"보다"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","크거나 같은 비트 수로 시프트할 경우 중지될 수 있습니다."]})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"}),(0,t.jsx)(s,{children:"중단"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"<<",작업:"왼쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"},{통사론:">>",작업:"오른쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업}),(0,t.jsx)(s,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"비교 연산자"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 정수 유형만이 비교 연산자를 사용할 수 있습니다. 비교 연산자를 사용할 때는 두 인자가 동일한 유형이어야 합니다. 만약 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 한 쪽을 형변환해야 합니다. Move에서의 비교 연산은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 중단되지 않습니다."})," 이는 비교 연산이 갑작스럽게 종료되거나 오류를 발생시키지 않는다는 것을 의미합니다. 대신, 비교 연산은 비교 결과를 나타내는 불리언 값 ("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"참 또는 거짓"}),")을 반환합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"<",작업:"보다 작은"},{통사론:">",작업:"보다큰"},{통사론:"<=",작업:"작거나 같음"},{통사론:">=",작업:"크거나 같음"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"평등"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move의 모든 정수 유형은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:'"equal"'}),"과",(0,t.jsx)("span",{style:{color:"purple"},children:'"not equal"'})," 연산을 지원합니다. 두 인자는 동일한 유형이어야 합니다. 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 하나를 형변환해야 합니다."," ",(0,t.jsx)("span",{style:{color:"purple"},children:"등호 연산은 중단되지 않습니다."})," "]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"==",작업:"같은"},{통사론:"!=",작업:"같지않은"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"형변환"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 한 크기의 정수 유형을 다른 크기의 정수 유형으로"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"형변환"})," 할 수 있습니다. 정수는 Move에서 형변환를 지원하는 유일한 유형입니다. 정수를 크기가 다른 유형으로 형변환 할 때, Move에서는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"형변환이 값을 절단하지 않는다는 점"}),"에 유의해야 합니다. 이는 형변환 연산이 원래 정수의 전체 값을 보존한다는 것을 의미합니다. 즉, 목표 정수 유형의 범위를 초과하는 경우에도 원래 정수의 전체 값이 유지됩니다. 그러나, 형변환의 결과가 지정된 유형에 너무 큰 경우 형변환이 중단될 수 있다는 점을 알려드립니다. 이는형변환 결과가 지정된 유형에 맞지 않을 때 형변환이 중단되는 것을 의미합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(s,{children:"통사론"}),(0,t.jsx)(s,{children:"작업"}),(0,t.jsx)(s,{children:"다음과 같은 경우 중단"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"(e as T)",작업:"e 정수 표현식을 정수 유형으로형변환T",설명:"e로 표현하기에는 너무 큽니다"}].map(e=>(0,t.jsxs)(x,{children:[(0,t.jsx)(s,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,t.jsx)(s,{children:null==e?void 0:e.작업}),(0,t.jsx)(s,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move 언어에 내장된 정수 값들도 암묵적으로 복사 가능한 속성을 갖고 있습니다.",(0,t.jsx)("span",{style:{color:"purple"},children:"이는 복사와 같은 명시적 명령 없이도 복사될 수 있다는 것을 의미"})," ","합니다. 정수 값을 새 변수에 할당하거나 함수 인자로 전달할 때, 해당 값의 복사본이 생성됩니다. 원본 값과 복사본은 서로 독립적으로 사용될 수 있으며, 한 쪽 복사본을 수정해도 다른 쪽에는 영향을 미치지 않습니다. 이러한 복사 연산은 내부적으로 암묵적으로 처리됩니다. 예를 들어:"]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:s=>{e.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_2.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:12,sx:{textAlign:"left",marginTop:"30px"},children:[" ",(0,t.jsxs)(o.Z,{children:["이 경우,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"x의 값이 y로 복사되며, x와 y는 각각 정수 값의 독립적인 복사본을 가지고 있습니다."}),"y를 수정해도 x의 값에는 영향을 주지 않으며, 그 반대도 마찬가지입니다. 이러한 암묵적인 복사 동작은 명시적인 복사 명령 없이도 정수 값을 간편하게 처리할 수 있도록 해줍니다. 그러나 보다 복잡한 유형과 리소스의 경우, Move에서는 소유권과 빌림에 대한 명시적인 지침이나 고려 사항이 필요할 수 있습니다."]})]})]})},_=()=>{let e=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:s.palette.common.black,color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:10}}}),s=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.action.hover},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"부울"})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"부울"}),"은 Move에서 boolean"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"true"}),"와"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"false"})," 값을 표현하기 위한 원시 타입입니다.또한 bool 타입의 리터럴은 true 또는 false로 표현됩니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"* bool은 세가지 논리 연산을 지원합니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"통사론"}),(0,t.jsx)(e,{children:"설명"}),(0,t.jsx)(e,{children:"등가표현"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"&&",설명:"단락 논리 및",등가표현:"p && q에 해당합니다 if(p)q else false"},{통사론:"||",설명:"단락 논리 또는",등가표현:"p || q 에 해당합니다 if(p) true else q"},{통사론:"!",설명:"논리적 부정",등가표현:"!p에 해당합니다 if(q) false else true"}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{component:"div",scope:"row",children:null==x?void 0:x.통사론}),(0,t.jsx)(e,{children:null==x?void 0:x.설명}),(0,t.jsx)(e,{children:null==x?void 0:x.등가표현})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"bool 값은 Move의 여러 제어 흐름 구조에서 사용됩니다:"})})}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"* if문"})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/3_2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"* while문"})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/3_2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"3) assert:이 연산은 두 개의 인자를 받습니다: bool 타입의 조건과 u64 타입의 코드"})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/3_2_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"다른 스칼라 값들과 마찬가지로, 언어 내장의 boolean 값들은 암시적으로 복사 가능합니다. 즉, copy와 같은 명시적인 지시어 없이도 복사할 수 있습니다."})})})]})},A=()=>(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"주소"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"주소(Address)"})," 는 Move 언어에서 글로벌 스토리지의 위치(가끔은 계정이라고도 함)를 나타내기 위해 사용되는 내장된 유형입니다. 주소 값은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"128비트(16바이트)"}),"식별자입니다. 특정 주소에는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"모듈(Module)"}),"과",(0,t.jsx)("span",{style:{color:"purple"},children:"리소스(Resource)"}),"두 가지 요소를 저장할 수 있습니다."]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["실제로 주소는 128비트 정수로 구성되지만, Move 주소는 의도적으로 불투명한 형태로 구성되어 있습니다. 즉, 정수로부터 주소를 생성할 수 없으며, 산술 연산을 지원하지 않으며, 수정할 수 없습니다. 포인터 산술과 유사한 용도로 사용될 수 있는 흥미로운 프로그램이 있을 수 있지만 (예: C의 포인터 산술), Move는 정적 검증을 지원하기 위해 처음부터",(0,t.jsx)("span",{style:{color:"purple"},children:"이러한 동적 동작을 허용하지 않습니다."})]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["런타임 주소 값("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"주소 유형의 값"}),")을 사용하여 해당 주소에 있는 리소스에 접근할 수 있습니다. 주소 값을 통해 런타임에서 모듈에 액세스할 수는 없습니다."]})]})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"문법"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["주소는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"명명된(named) 주소"}),"와",(0,t.jsx)("span",{style:{color:"purple"},children:"숫자형(numerical) 주소"})," 로 두 가지 형태로 나뉩니다. 명명된 주소의 구문은 Move에서 일반적으로 사용되는 명명된 식별자의 규칙을 따릅니다. 숫자형 주소의 구문은 16진수로 인코딩된 값에 제한되지 않으며, 유효한 u128 숫자 값으로 주소 값으로 사용할 수 있습니다. 예를 들어,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"42, 0xCAFE, 2021"})," 은 모두 유효한 숫자형 주소 리터럴입니다."]}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"주소가 식(expression) 컨텍스트에서 사용되는지 여부를 구분하기 위해 주소를 사용하는 구문은 사용되는 컨텍스트에 따라 다릅니다:"}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["주소가 식으로 사용될 때는 주소 앞에 @ 문자가 붙어야 합니다. 즉,"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","@<numerical_value>"]})," ","또는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"@<named_address_identifier>"})," ","형태여야 합니다. 식 컨텍스트 이외의 곳에서는 주소를 @ 문자 없이 쓸 수 있습니다. 즉,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" <numerical_value>"})," 또는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"<named_address_identifier>"})," ","형태로 쓸 수 있습니다. 일반적으로 @는 주소를 네임스페이스 항목에서 식 항목으로 전환하는 연산자로 생각할 수 있습니다."]})]})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"명명된 주소"})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,t.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{router.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/4_1.move")},children:"Code"}),(0,t.jsx)("img",{src:"/img/4_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소(named addresses)는 주소가 사용되는 모든 위치에서 숫자 값 대신 식별자를 사용할 수 있도록 하는 기능입니다. 명명된 주소는 Move 패키지의 최상위 요소(모듈 및 스크립트 외부)로 선언되고 바인딩됩니다. 또한 Move 컴파일러에 인수로 전달될 수도 있습니다. 명명된 주소는 값 수준뿐만 아니라 주소가 사용되는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"모든 위치"}),"에서 사용될 수 있으며, 소스 언어 수준에서만 존재하며 바이트코드 수준에서는 완전히 해당 값을 ",(0,t.jsx)("span",{style:{color:"purple"},children:"대체"}),"합니다. 따라서 모듈과 모듈 멤버는 모듈의 명명된 주소를 통해 접근해야 하며, 명명된 주소에 할당된 숫자 값으로 모듈 및 모듈 멤버에 접근해서는 안 됩니다. 예를 들어,",(0,t.jsx)("span",{style:{color:"purple"},children:"my_addr이 0x2로 설정된 상태"})," ","에서 Move 프로그램이 컴파일되더라도"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"use my_addr::foo는 use 0x2::foo와 동일하지 않습니다"}),". 이 차이점은 모듈과 스크립트 섹션에서 자세히 논의됩니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"글로벌 스토리지 운영"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["주소 값의 주요 목적은 글로벌 스토리지 작업과 상호 작용하는 데에 있습니다. 주소 값은",(0,t.jsx)("span",{style:{color:"purple"},children:"exists, borrow_global, borrow_global_mut, move_from"})," ","등의 작업과 함께 사용됩니다. 주소를 사용하지 않는 유일한 글로벌 스토리지 작업은 ",(0,t.jsx)("span",{style:{color:"purple"},children:"move_to"}),"입니다. move_to 작업은",(0,t.jsx)("span",{style:{color:"purple"},children:"signer"})," 를 사용합니다."]})})}),(0,t.jsxs)(n.Z,{xs:12,sx:{marginTop:"10px"},children:[(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"*exists: 주소 아래에 T가 저장되어 있으면 true를 반환"})}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"*borrow_global:address 아래에 저장된 T에 대한 불변 참조를 반환합"})}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"* borrow_global_mut:address 아래에 저장된 T에 대한 변경 가능한 참조를 반환"})}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"*move_from:T 주소에서 T를 제거하고 반환"})}),(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)("span",{style:{color:"purple"},children:"* move_to:signer.address 아래에 T를 게시"})})]}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:['언어에 내장된 다른 스칼라 값과 마찬가지로 주소 값도 암시적으로 복사 가능(copyable)합니다. 이는 "copy"와 같은',(0,t.jsx)("span",{style:{color:"purple"},children:"명시적인 명령 없이도 주소 값이 복사될 수 있다는 것을 의미"})," ","합니다. 주소 값을 새 변수에 할당하거나 함수에 인수로 전달할 때, 주소 값의 복사본이 생성되며 원본과 복사본 주소 모두 독립적으로 사용할 수 있습니다."]})})})]}),M=()=>{let e=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),s=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"벡터"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에서 제공하는 유일한 원시 컬렉션 타입은"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","vector<T>"]}),"입니다. ","vector<T>","는 T의 동일한 유형의 항목들로 구성된 컬렉션으로, 값들을 끝에"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"push"}),"하거나 ",(0,t.jsx)("span",{style:{color:"purple"},children:"pop"}),"하여 크기를 조절할 수 있습니다.","vector<T>","는 어떤 유형 T로도 인스턴스화할 수 있습니다. 예를 들어,"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","vector<u64>, vector<address>, vector<0x42::MyModule::MyResource> 및 vector<vector<u8>>"]}),"은 모두 유효한 vector 타입입니다."]})})}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"일반적인 벡터 리터럴"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"벡터 리터럴을 사용하여 어떤 유형의 벡터든 생성할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"통사론"}),(0,t.jsx)(e,{children:"타입"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"vector[]",타입:"vector[]: vector<T> where T is any single, non-reference type",설명:"비어있는 벡터"},{통사론:"vector[e1, ..., en]",타입:"vector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0",설명:" n개의 요소가 있는 벡터(길이 n)"}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{component:"div",scope:"row",children:null==x?void 0:x.통사론}),(0,t.jsx)(e,{children:null==x?void 0:x.타입}),(0,t.jsx)(e,{children:null==x?void 0:x.설명})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이러한 경우에는 벡터의 유형이 원소 유형이나 벡터의 사용으로부터 추론됩니다. 유형을 추론할 수 없는 경우 또는 명확성을 위해 유형을",(0,t.jsx)("span",{style:{color:"purple"},children:"명시적"})," 으로 지정할 수도 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h4",gutterBottom:!0,children:["vector","<u8>"," 타입의 리터럴"]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에서 벡터를 사용하는 일반적인 사례는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"바이트 배열"}),"을 나타내는 것인데, 이는"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","vector<u8>"]}),"로 표현됩니다. 이러한 값들은 종종 공개 키나 해시 결과와 같은 암호화 목적으로 사용됩니다. 이러한 값들은 널리 사용되어 특정 구문이 제공되어 값을 더 가독성 있게 만들어줍니다. 각 개별 u8 값이 숫자 형태로 지정되는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"vector[]"}),"를 사용해야 하는 대신에 특정 구문을 사용할 수 있습니다."]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["현재 지원되는 두 가지 유형의 ","vector<u8>"," 리터럴은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"바이트 문자열(byte strings)"}),"과"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"16진수 문자열(hex strings)"}),"입니다."]})]})}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h5",gutterBottom:!0,children:"바이트 문자열(Byte Strings)"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"바이트 문자열"})," 은 b로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어,",(0,t.jsx)("span",{style:{color:"purple"},children:'b"Hello!\\n"'})," 과 같습니다."]}),(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"ASCII"})," 로 인코딩된 문자열로서"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"이스케이프 시퀀스"})," 를 허용합니다. 현재 지원되는 이스케이프 시퀀스는 다음과 같습니다:"]})]})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"이스케이프_시퀀스"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{이스케이프_시퀀스:"\\n",Description:"새 줄(또는 줄바꿈)"},{이스케이프_시퀀스:"\\r",Description:"캐리지 리턴(Carriage return)"},{이스케이프_시퀀스:"\\t",Description:"Tab"},{이스케이프_시퀀스:"\\\\",Description:"Backslash"},{이스케이프_시퀀스:"\\0",Description:"Null"},{이스케이프_시퀀스:'\\"',Description:"Quote"},{이스케이프_시퀀스:"\\xHH",Description:"Hex escape, inserts the hex byte sequence HH"}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{component:"div",scope:"row",children:null==x?void 0:x.이스케이프_시퀀스}),(0,t.jsx)(e,{children:null==x?void 0:x.Description})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h5",gutterBottom:!0,children:"16진수 문자열(Hex Strings)"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["16진수 문자열은 x로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:' x"48656C6C6F210A"'}),"와 같습니다. 각각의 바이트 쌍은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 00"}),"부터 ",(0,t.jsx)("span",{style:{color:"purple"},children:"FF"}),"까지의 16진수로 인코딩된 ",(0,t.jsx)("span",{style:{color:"purple"},children:"u8"}),"값을 의미합니다. 따라서 각 바이트 쌍은 결과적인 ","vector<u8>","에서 하나의 항목에 해당합니다. 예시 문자열 리터럴"]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"vector는 아래와 같이 Move 표준 라이브러리의 std::vector 모듈을 통해 여러 작업을 제공합니다. 시간이 지남에 따라 더 많은 작업이 추가될 수 있습니다. 벡터에 대한 최신 문서는 여기에서 찾을 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"Function"}),(0,t.jsx)(e,{children:"Description"}),(0,t.jsx)(e,{children:"Aborts?"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{Function:"vector::empty<T>(): vector<T>	",Description:"T 유형의 값을 저장할 수 있는 빈 벡터를 만듭니다.",Aborts:"절대"},{Function:"vector::is_empty<T>(): bool",Description:"벡터 v에 요소가 없으면 true를 반환하고 그렇지 않으면 false를 반환합니다.",Aborts:"절대"},{Function:"vector::singleton<T>(t: T): vector<T>",Description:"t를 포함하는 크기 1의 벡터를 만듭니다.",Aborts:"절대"},{Function:"vector::length<T>(v: &vector<T>): u64",Description:"벡터 v의 길이를 반환합니다.",Aborts:"절대"},{Function:"vector::push_back<T>(v: &mut vector<T>, t: T)",Description:"v 끝에 t 추가",Aborts:"절대"},{Function:"vector::pop_back<T>(v: &mut vector<T>): T",Description:"v의 마지막 요소를 제거하고 반환",Aborts:"v가 비어 있는 경우"},{Function:"vector::borrow<T>(v: &vector<T>, i: u64): &T",Description:"인덱스 i에서 T에 대한 불변 참조를 반환합니다.",Aborts:"내가 경계 안에 있지 않다면"},{Function:"vector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T",Description:"인덱스 i에서 T에 대한 변경 가능한 참조를 반환합니다.",Aborts:"내가 경계 안에 있지 않다면"},{Function:"vector::destroy_empty<T>(v: vector<T>)",Description:"v 삭제",Aborts:"v가 비어 있지 않은 경우"},{Function:"vector::append<T>(v1: &mut vector<T>, v2: vector<T>)",Description:"v2의 요소를 v1의 끝에 추가",Aborts:"절대"},{Function:"vector::reverse_append<T>(lhs: &mut vector<T>, other: vector<T>)",Description:"다른 벡터에서 발생한 것과 반대 순서로 다른 벡터의 모든 요소를 ​​lhs 벡터로 푸시합니다.",Aborts:"절대"},{Function:"vector::contains<T>(v: &vector<T>, e: &T): bool",Description:"e가 벡터 v에 있으면 참을 반환합니다. 그렇지 않으면 거짓을 반환합니다.",Aborts:"절대"},{Function:"vector::swap<T>(v: &mut vector<T>, i: u64, j: u64)",Description:"벡터 v의 i번째 인덱스와 j번째 인덱스에 있는 요소를 교체합니다.",Aborts:"i 또는 j가 범위를 벗어난 경우"},{Function:"vector::reverse<T>(v: &mut vector<T>)",Description:"제자리에서 벡터 v의 요소 순서를 반대로 바꿉니다.",Aborts:"절대"},{Function:"vector::reverse_slice<T>(v: &mut vector<T>, l: u64, r: u64)",Description:"제자리에서 벡터 v의 요소 [l, r)의 순서를 반대로 바꿉니다.",Aborts:"절대"},{Function:"vector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)",Description:"e가 인덱스 i의 벡터 v에 있으면 (true, i)를 반환합니다. 그렇지 않으면 (거짓, 0)을 반환합니다.",Aborts:"절대"},{Function:"vector::insert<T>(v: &mut vector<T>, i: u64, e: T)",Description:"O(길이 - i) 시간을 사용하여 위치 0 <= i <= 길이에 새 요소 e를 삽입합니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::remove<T>(v: &mut vector<T>, i: u64): T",Description:"벡터 v의 i번째 요소를 제거하고 모든 후속 요소를 이동합니다. 이것은 O(n)이며 벡터에서 요소의 순서를 유지합니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::swap_remove<T>(v: &mut vector<T>, i: u64): T",Description:"벡터 v의 i번째 요소를 마지막 요소로 바꾼 다음 요소를 팝합니다. 이것은 O(1)이지만 벡터의 요소 순서는 유지하지 않습니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::trim<T>(v: &mut vector<T>, new_len: u64): u64",Description:"벡터 v를 더 작은 크기의 new_len으로 자르고 제거된 요소를 순서대로 반환합니다.",Aborts:"new_len이 v의 길이보다 큽니다."},{Function:"vector::trim_reverse<T>(v: &mut vector<T>, new_len: u64): u64",Description:"벡터 v를 더 작은 크기의 new_len으로 자르고 제거된 요소를 역순으로 반환합니다.",Aborts:"new_len이 v의 길이보다 큽니다."},{Function:"vector::rotate<T>(v: &mut vector<T>, rot: u64): u64",Description:"rotate(&mut [1, 2, 3, 4, 5], 2) -> [3, 4, 5, 1, 2] 제자리에서 분할 지점을 반환합니다. 이 예에서 3",Aborts:"절대"},{Function:"vector::rotate_slice<T>(v: &mut vector<T>, left: u64, rot: u64, right: u64): u64",Description:"왼쪽 <= 회전 <= 오른쪽으로 길게 [ 왼쪽, 오른쪽 회전), 끝점 반환",Aborts:"절대"}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{component:"div",scope:"row",children:null==x?void 0:x.Function}),(0,t.jsx)(e,{component:"div",scope:"row",children:null==x?void 0:x.Description}),(0,t.jsx)(e,{children:null==x?void 0:x.Aborts})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"Example"})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"벡터 파괴 및 복사"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"vector<T>"}),"의 일부 동작은 원소 유형 T의 기능에 따라 달라집니다. 예를 들어,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 드롭(drop) "}),"기능이 없는 원소를 포함하는 벡터는 위의 예시에서 v와 같이 암묵적으로 폐기될 수 없으며, 명시적으로"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" vector::destroy_empty"}),"를 사용하여 파괴해야 합니다."," ",(0,t.jsx)("span",{style:{color:"purple"},children:" vector::destroy_empty"}),"는 vec에 원소가 없을 경우에만 실행 시점에서 중단됩니다:"]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["하지만 ",(0,t.jsx)("span",{style:{color:"purple"},children:" 드롭(drop) "}),"기능이 있는 원소를 포함하는 벡터를 폐기하려고 할 때 오류가 발생하지는 않습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["마찬가지로, 원소 유형이"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"복사 가능한 경우"}),"에만 벡터를 복사할 수 있습니다. 다시 말해, T가 복사 가능한 경우에만"," ","vector<T>","가 복사 가능합니다. 그러나 복사 가능한 벡터조차도 암묵적으로 복사되지는 않습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/5_8.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["대용량 벡터의 복사는 비용이 많이 들 수 있으므로 컴파일러는 복사가 명시적으로 이루어지도록 요구하여 어디에서 복사가 발생하는지 쉽게 파악할 수 있도록 합니다. 자세한 내용은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"유형 능력(type abilities)"}),"과"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"제네릭(generics) "}),"섹션을 참조하십시오."]})})}),(0,t.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h4",gutterBottom:!0,children:["소유권"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["위에서 언급한 대로,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"원소가 복사 가능한 경우"}),"에만 벡터 값들을 복사할 수 있습니다. 이 경우에는 복사가 명시적으로 이루어져야 하며, 복사 또는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 역참조 *"}),"를 통해 이루어집니다."]})})})]})},C=()=>{let e=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),s=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"서명자"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"서명자 "}),"는 기본 제공 이동 자원 유형입니다. 서명자는"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","소유자가 특정 주소를 대신하여 작업"," "]})," ","할 수 있도록 하는 기능입니다. 기본 구현을 다음과 같이 생각할 수 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/6_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["서명자는 이동 외부의 코드(예:"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"암호화 서명 또는 암호 확인 "}),")로 인증된 사용자를 나타낸다는 점에서 Unix UID와 다소 유사합니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"주소 비교"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move 프로그램은 주소 리터럴을 사용하여 특별한 권한 없이 모든 주소 값을 만들 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/6_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["그러나 서명자 값은 리터럴이나 지침을 통해 생성할 수 없고"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"Move VM에서만 생성 "})," 할 수 있기 때문에 특별합니다. VM이 서명자 유형의 매개변수를 사용하여 스크립트를 실행하기 전에 서명자 값을 자동으로 생성하여 스크립트에 전달합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/6_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"스크립트가 0x42 이외의 주소에서 전송되면 이 스크립트는 코드 0으로 중단됩니다. 트랜잭션 스크립트는 서명자가 다른 인수의 접두사인 한 임의의 수의 서명자를 가질 수 있습니다. 즉, 모든 서명자 인수가 먼저 와야 합니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/6_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이는 여러 당사자의 권한으로 원자적으로 작동하는 다중 서명자 스크립트를 구현하는 데 유용합니다. 예를 들어, 위 스크립트의 확장은 s1과 s2 사이에 원자 통화 스왑을 수행할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"서명자 연산자"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:" std::signer "})," 표준 라이브러리 모듈은 서명자 값에 대해 두 가지 유틸리티 기능을 제공합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"함수"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{함수:"signer::address_of(&signer): address	",설명:"이 &signer로 래핑된 주소를 반환합니다."},{함수:"signer::borrow_address(&signer): &address		",설명:"이 &signer로 래핑된 주소에 대한 참조를 반환합니다."}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{children:null==x?void 0:x.함수}),(0,t.jsx)(e,{children:null==x?void 0:x.설명})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["또한"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:["move_to","<T>","(&signer, T)"," "]})," ","전역 저장소 연산자는 signer.address의 계정에 리소스 T를 게시하기 위해 ",(0,t.jsx)("span",{style:{color:"purple"},children:"&signer "}),"인수가 필요합니다. 이렇게 하면 인증된 사용자만 자신의 주소로 리소스를 게시하도록 선택할 수 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["단순 스칼라 값과 달리 서명자 값은 복사할 수 없습니다. 즉"," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","명시적 복사 명령을 통해서이든 역참조 *를 통해서든 어떤 작업에서도 복사할 수 없습니다."]})]})})})]})},R=()=>{let e=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),s=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"참조"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"불변 &"}),"및"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"가변 &mut"}),"의 두 가지 유형의 참조가 있습니다. 변경할 수 없는 참조는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 읽기 전용"}),"이며 기본 값(또는 해당 필드)을 수정할 수 없습니다. 변경 가능한 참조는 해당 참조를 통한"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"쓰기를 통한 수정"}),"을 허용합니다. Move의 유형 시스템은 참조 오류를 방지하는 소유권 규율을 적용합니다. 참조 규칙에 대한 자세한 내용은 구조체 및 리소스를 참조하세요."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"참조 연산자"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move는 참조를 만들고 확장할 뿐만 아니라 변경 가능한 참조를 변경 불가능한 참조로 변환하기 위한 연산자를 제공합니다. 여기와 다른 곳에서는",(0,t.jsx)("span",{style:{color:"purple"},children:'"표현식 e에는 T 유형이 있음"'}),"에 대해 표기법 ",(0,t.jsx)("span",{style:{color:"purple"},children:" e: T"}),"를 사용합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"통사론"}),(0,t.jsx)(e,{children:"타입"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"&e",타입:"&T where e: T and T is a non-reference type	",설명:"e에 대한 불변 참조 생성"},{통사론:"&mut e",타입:"&mut T where e: T and T is a non-reference type	",설명:"e에 대한 변경 가능한 참조를 만듭니다."},{통사론:"&e.f",타입:"&T where e.f: T",설명:"구조체 e의 필드 f에 대한 불변 참조를 만듭니다."},{통사론:"&mut e.f",타입:"&mut T where e.f: T	",설명:"구조체의 필드 f에 대한 변경 가능한 참조를 만듭니다."},{통사론:"freeze(e)",타입:"&T where e: &mut T	",설명:"가변 참조 e를 불변 참조로 변환합니다."}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{children:null==x?void 0:x.통사론}),(0,t.jsx)(e,{children:null==x?void 0:x.타입}),(0,t.jsx)(e,{children:null==x?void 0:x.설명})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:" &e.f"}),"및"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" &mut e.f "}),"연산자는 구조체에 대한 새 참조를 만들거나 기존 참조를 확장하는 데 모두 사용할 수 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"30px"},children:(0,t.jsx)("img",{src:"/img/7_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"여러 필드가 있는 참조 표현식은 두 구조체가 동일한 모듈에 있는 한 작동합니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"30px"},children:(0,t.jsx)("img",{src:"/img/7_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["마지막으로 참조에 대한 참조는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"허용되지 않습니다."})]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"30px"},children:(0,t.jsx)("img",{src:"/img/7_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsxs)(o.Z,{variant:"h4",gutterBottom:!0,children:["참고 문헌을 통한 읽기 및 쓰기"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["변경 가능한 참조와 변경 불가능한 참조를 모두 읽어 참조된 값의",(0,t.jsx)("span",{style:{color:"purple"},children:"복사본"}),"을 생성할 수 있습니다. 변경 가능한 참조만 작성할 수 있습니다. 쓰기"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" *x = v"}),"는 이전에 x에 저장된 값을 버리고 v로 업데이트합니다. 두 작업 모두 C와 유사한"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"* 구문"}),"을 사용합니다. 그러나 읽기는 표현식인 반면 쓰기는 등호의 왼쪽에서 발생해야 하는 변형입니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"통사론"}),(0,t.jsx)(e,{children:"타입"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"*e",타입:"T where e is &T or &mut T	",설명:"e가 가리키는 값을 읽습니다."},{통사론:"*e1 = e2	",타입:"() where e1: &mut T and e2: T	",설명:"e1의 값을 e2로 업데이트합니다."}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{children:null==x?void 0:x.통사론}),(0,t.jsx)(e,{children:null==x?void 0:x.타입}),(0,t.jsx)(e,{children:null==x?void 0:x.설명})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["참조를 읽으려면 기본 유형에"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"복사"}),"기능이 있어야 합니다. 참조를 읽으면 값의 새 복사본이 생성되기 때문입니다."," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","이 규칙은 리소스 값 복사를 방지합니다."]})]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이중: 참조를 작성하려면 기본 유형에 삭제 기능이 있어야 합니다. 참조에 작성하면 이전 값이 삭제 (",(0,t.jsx)("span",{style:{color:"purple"},children:'또는 "삭제"'}),")되기 때문입니다. 이 규칙은 리소스 값의 파괴를 방지합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h4",gutterBottom:!0,children:["동결 추론"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"변경 불가능한 참조가 예상되는 상황에서 변경 가능한 참조를 사용할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_6.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이는 내부적으로 컴파일러가 필요한 곳에 고정 명령을 삽입하기 때문에 작동합니다. 다음은 고정 추론의 몇 가지 예입니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"하위 유형"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이 동결 추론을 통해 Move 유형 검사기는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"&mut T"}),"를"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"&T"}),"의 하위 유형으로 볼 수 있습니다. 위에 표시된 것처럼 이것은 &T 값이 사용되는 모든 표현식에 대해 &mut T 값도 사용할 수 있음을 의미합니다. 이 용어는 &T가 제공된 곳에 &mut T가 필요했음을 간결하게 나타내기 위해 오류 메시지에 사용됩니다. 예를 들어"]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_8.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같은 오류 메시지가 나타납니다"})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_9.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["현재 하위 유형이 있는 유일한 다른 유형은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"튜플"}),"입니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"동일한 참조의 기존 복사본이나 확장이 있더라도 변경 가능한 참조와 변경 불가능한 참조는 항상 복사 및 확장될 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/7_10.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이것은 위의 코드를 거부하는 Rust의 소유권 시스템에 익숙한 프로그래머에게는 놀라운 일이 될 수 있습니다. Move의 타입 시스템은 복사본 처리에 있어서 더 관대하지만 쓰기 전에 변경 가능한 참조의 고유한 소유권을 보장하는 데 있어서도 똑같이 엄격합니다."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"참조를 저장할 수 없음"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"참조"})," 와"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"튜플"}),"은 구조체의 필드 값으로 저장할 수 없는 ",(0,t.jsx)("span",{style:{color:"purple"},children:"유일한 유형"}),"이며, 이는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"전역 저장소에 존재할 수 없음을 의미"}),"하기도 합니다. 프로그램 실행 중에 생성된 모든 참조는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"Move 프로그램이 종료될 때 삭제"}),"됩니다. 그들은 완전히"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 일시적"})," 입니다. 이 불변성은 저장 기능이 없는 유형의 값에도 적용되지만 참조와 튜플은 애초에 구조체에서 허용되지 않음으로써 한 단계 더 나아갑니다. 이것은 Move와 Rust의 또 다른 차이점으로, 구조체 내부에 참조를 저장할 수 있습니다. 현재 Move는 참조를 직렬화할 수 없기 때문에 이를 지원할 수 없지만 모든 Move 값은 직렬화 가능해야 합니다. 이 요구 사항은 프로그램 실행 간에 값을 유지하기 위해 값을 직렬화해야 하는 Move의 영구 전역 저장소에서 비롯됩니다."," ",(0,t.jsxs)("span",{style:{color:"purple"},children:[" ","구조체는 전역 저장소에 쓸 수 있으므로 직렬화 가능해야 합니다."]}),"참조를 구조체에 저장하고 해당 구조체가 전역 저장소에 존재하는 것을 금지하는 더 멋지고 표현력이 뛰어난 유형 시스템을 상상할 수 있습니다. 저장 기능이 없는 구조체 내부의 참조를 허용할 수도 있지만 문제를 완전히 해결하지는 못합니다. Move에는 정적 참조 안전성을 추적하는 상당히 복잡한 시스템이 있으며 유형 시스템의 이러한 측면도 확장해야 합니다. 구조체 내부에 참조 저장을 지원합니다. 요컨대, Move의 유형 시스템(특히 참조 안전성에 관한 측면)은 저장된 참조를 지원하도록 확장되어야 합니다. 그러나 그것은 언어가 발전함에 따라 우리가 주시하고 있는 것입니다."]})})})]})},k=()=>{let e=(0,f.ZP)(g.Z)(e=>{let{theme:s}=e;return{["&.".concat(v.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(v.Z.body)]:{fontSize:12}}}),s=(0,f.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"튜플 및 단위"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move는 튜플을 일급 값으로 사용하는 다른 언어에서 온 것으로 예상할 수 있으므로 튜플을 완전히 지원하지 않습니다. 그러나 여러 반환 값을 지원하기 위해 Move에는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 튜플과 같은 표현식"}),"이 있습니다. 이러한 식은 런타임에 구체적인 값을 생성하지 않으며("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"바이트코드에 튜플이 없음"}),") 결과적으로 매우 제한적입니다. 식에만 나타날 수 있습니다(",(0,t.jsx)("span",{style:{color:"purple"},children:"일반적으로 함수의 반환 위치"}),"). 지역 변수에 바인딩할 수 없습니다. 구조체에 저장할 수 없습니다. 제네릭을 인스턴스화하는 데 튜플 유형을 사용할 수 없습니다. 마찬가지로 ",(0,t.jsx)("span",{style:{color:"purple"},children:"unit()"}),"은 표현식 기반이 되기 위해 Move 소스 언어에서 만든 유형입니다. 단위 값()은 런타임 값을 생성하지 않습니다."," ",(0,t.jsx)("span",{style:{color:"purple"},children:"unit()"})," 을 빈 튜플로 간주할 수 있으며 튜플에 적용되는 모든 제한 사항이 유닛에도 적용됩니다. 이러한 제한 사항을 감안할 때 언어에 튜플이 있는 것이 이상하게 느껴질 수 있습니다. 그러나 다른 언어에서 튜플의 가장 일반적인 사용 사례 중 하나는 함수가 여러 값을 반환할 수 있도록 하는 함수입니다. 일부 언어는 사용자가 여러 반환 값을 포함하는 구조체를 작성하도록 강제하여 이 문제를 해결합니다. 그러나 Move에서는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"구조체 내부에 참조를 넣을 수 없습니다."})," ","여러 반환 값을 지원하려면 Move가 필요했습니다. 이러한 여러 반환 값은 모두 바이트 코드 수준에서 스택에 푸시됩니다. 소스 수준에서 이러한 여러 반환 값은 튜플을 사용하여 표시됩니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"튜플은 괄호 안에 쉼표로 구분된 표현식 목록으로 생성됩니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,t.jsx)(y.Z,{component:w.Z,children:(0,t.jsxs)(Z.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,t.jsx)(b.Z,{children:(0,t.jsxs)(T.Z,{children:[(0,t.jsx)(e,{children:"통사론"}),(0,t.jsx)(e,{children:"타입"}),(0,t.jsx)(e,{children:"설명"})]})}),(0,t.jsx)(u.Z,{component:"div",children:[{통사론:"()",타입:"(): ()",설명:"단위, 빈 튜플 또는 인수가 0인 튜플"},{통사론:"(e1, ..., en)",타입:"(e1, ..., en): (T1, ..., Tn) where e_i: Ti s.t. 0 < i <= n and n > 0",설명:"n-튜플, 개수 n의 튜플, n개의 요소가 있는 튜플"}].map(x=>(0,t.jsxs)(s,{children:[(0,t.jsx)(e,{children:null==x?void 0:x.통사론}),(0,t.jsx)(e,{children:null==x?void 0:x.타입}),(0,t.jsx)(e,{children:null==x?void 0:x.설명})]},null==x?void 0:x.drop_name))})]})})}),(0,t.jsx)(n.Z,{xs:0,md:2}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)("span",{style:{color:"purple"},children:"(e)"})," 에는"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"(e): (t)"})," 유형이 없습니다. 즉,"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"하나의 요소가 있는 튜플이 없습니다."})," ","괄호 안에 하나의 요소만 있는 경우 괄호는 명확성을 위해서만 사용되며 다른 특별한 의미는 없습니다. 때로는 요소가 두 개인 튜플을"," ",(0,t.jsx)("span",{style:{color:"purple"},children:' "쌍"'}),"이라고 하고 요소가 세 개인 튜플을 ",(0,t.jsx)("span",{style:{color:"purple"},children:' "트리플"'}),"이라고 합니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/8_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:3}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"Operations"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["현재 튜플에서 수행할 수 있는 유일한 작업은"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"구조 분해"})," 입니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"Destructuring"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"모든 크기의 튜플에 대해 let 바인딩이나 할당에서 해체될 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/8_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"자세한 내용은 변수 이동을 참조하십시오."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"Subtyping"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["참조와 함께 튜플은 Move에서"," ",(0,t.jsx)("span",{style:{color:"purple"},children:"하위 유형"})," 이 있는 유일한 유형입니다. 튜플은 ("," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 공변량 방식으로"})," ) 참조가 있는 하위 유형이라는 의미에서만 하위 유형이 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,t.jsx)("img",{src:"/img/8_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,t.jsx)(n.Z,{xs:0,md:4}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["위에서 언급했듯이 튜플 값은 런타임에 실제로"," ",(0,t.jsx)("span",{style:{color:"purple"},children:" 존재하지 않습니다. "}),"그리고 현재 이 때문에 로컬 변수에 저장할 수 없습니다("," ",(0,t.jsx)("span",{style:{color:"purple"},children:"그러나 이 기능이 곧 제공될 가능성이 높습니다"})," ","). 따라서 튜플을 복사하려면 먼저 지역 변수에 넣어야 하므로 튜플은 현재에만 이동할 수 있습니다."]})})})]})},z=x(74855),D=x(34209),F=x(84283),X=x(90066);function S(e){let{code:s}=e,[x,n]=(0,r.useState)(!1),[i,l]=(0,r.useState)(!1),[d,o]=(0,r.useState)(!1);return(0,t.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{l(!0)},onMouseLeave:()=>{l(!1)},children:[(0,t.jsx)(D.Z,{language:"javascript",style:F.cL,children:s}),(0,t.jsx)(z.CopyToClipboard,{text:s,children:(0,t.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),n(!0),o(!0),setTimeout(()=>{n(!1),o(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:i?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:d?(0,t.jsx)(X.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,t.jsx)(X.Z,{style:{color:x?"#fff":"#000",transition:"color 0.3s"}})})})]})}function E(e){let{text:s}=e;return(0,t.jsx)("span",{style:{color:"purple"},children:s})}var O=()=>(0,t.jsxs)(n.Z,{container:!0,children:[(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"로컬 변수 및 범위"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move의 지역 변수는 어휘(",(0,t.jsx)(E,{text:"정적으로"}),") 범위가 지정됩니다. 새 변수는",(0,t.jsx)(E,{text:"let"}),"키워드로 도입되며 동일한 이름을 가진 이전 로컬을 숨깁니다. 로컬은 변경 가능하며 직접 업데이트하거나 변경 가능한 참조를 통해 업데이트할 수 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"지역 변수 선언"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"let bindings"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["Move는 ",(0,t.jsx)(E,{text:"let"}),"을 사용하여 변수 이름을 값에 바인딩합니다."]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 1;\n  let y = x + x:\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[(0,t.jsx)(E,{text:"let"}),"은 지역변수에 값을 바인딩하지 않고 사용할 수도 있습니다."]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x;\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"그런 다음 지역변수에 나중에 값을 할당할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsx)(S,{code:" let x;\n  if (cond) {\n    x = 1\n  } else {\n    x = 0\n  }\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이는 기본값을 제공할 수 없을 때 루프에서 값을 추출하려고 할 때 매우 유용할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,children:(0,t.jsx)(S,{code:"  let x;\n  let cond = true;\n  let i = 0;\n  loop {\n      (x, cond) = foo(i);\n      if (!cond) break;\n      i = i + 1;\n  }\n"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"사용하기 전에 변수를 초기화해야합니다"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move의 유형 시스템은 지역 변수가 할당되기 전에 사용되는 것을 방지합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x;\n  x + x // 에러발생!\n\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x;\n  if (cond) x = 0;\n  x + x // 에러발생!"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x;\n  while (cond) x = 0;\n  x + x // 에러발생!\n"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"유효한 변수 이름"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["변수 이름에는 밑줄 ",(0,t.jsx)(E,{text:"_, 문자 a~z, 문자 A~Z, 숫자 0~9"}),"가 포함될 수 있습니다. 변수 이름은 ",(0,t.jsx)(E,{text:"밑줄 _"}),"또는 문자 ",(0,t.jsx)(E,{text:" a~z"}),"로 시작해야 합니다. 대문자로 시작할 수 없습니다."]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  //모두 유효\n  let x = e;\n  let _x = e;\n  let _A = e;\n  let x0 = e;\n  let xA = e;\n  let foobar_123 = e;\n  \n  // 모두 유효하지 않음\n  let X = e; // 에러!\n  let Foo = e; // 에러!\n"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"유형 주석"})})}),(0,t.jsxs)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"지역 변수의 유형은 거의 항상 Move의 유형 시스템에서 유추할 수 있습니다. 그러나 Move는 가독성, 명확성 또는 디버깅 가능성에 유용할 수 있는 명시적 형식 주석을 허용합니다. 유형 주석을 추가하는 구문은 다음과 같습니다."})}),(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"center"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:(0,t.jsx)(E,{text:"    *유형주석:변수, 매개변수, 반환 값 등에 대해 유형 정보를 명시적으로 표기하는 것을 의미"})})})]}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x: T = e; // T 유형의 변수 x는 표현식 e로 초기화됩니다.\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"명시적 유형 주석의 몇 가지 예:"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  address 0x42 {\n    module example {\n    \n        struct S { f: u64, g: u64 }\n    \n        fun annotated() {\n            let u: u8 = 0;\n            let b: vector<u8> = b"hello";\n            let a: address = @0x0;\n            let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n            let S { f, g: f2 }: S = S { f: 0, g: 1 };\n        }\n    }\n}\n'})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"유형 주석은 항상 패턴의 오른쪽에 있어야 합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let (x: &u64, y: &mut u64) = (&0, &mut 1); // 오류! (x, y): ... =여야 합니다. "})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"주석이 필요한 경우"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"경우에 따라 유형이 다음과 같은 경우 지역변수 유형 주석이 필요합니다. 시스템이 유형을 유추할 수 없습니다. 이것은 일반적으로 유형이 다음과 같은 경우에 발생합니다. 제네릭 형식에 대한 인수를 유추할 수 없습니다. 예를 들어:"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let _v1 = vector::empty(); // 에러가 발생!\n  //        ^^^^^^^^^^^^^^^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요.\n  let v2: vector<u64> = vector::empty(); //에러가 발생하지않음\n  "})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["드물게 유형 시스템이 유형을 유추하지 못할 수 있습니다. 발산 코드의 경우( ",(0,t.jsx)(E,{text:"다음 코드에 도달할 수 없는 경우"}),"). ",(0,t.jsx)(E,{text:"return"}),"과 ",(0,t.jsx)(E,{text:"abort"}),"는 둘 다 표현식이며 모든 유형을 가질 수 있습니다. 루프 중단이 있으면"," ",(0,t.jsx)(E,{text:"()"}),"유형을 가지지만 중단이 없는 경우 루프, 모든 유형을 가질 수 있습니다. 이러한 유형을 유추할 수 없는 경우 유형 주석이 필요합니다. 예를 들어 이 코드는 다음과 같습니다."]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let a: u8 = return ();\n  let b: bool = abort 0;\n  let c: signer = loop ();\n  \n  let x = return (); // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n  let y = abort 0; // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n  let z = loop (); // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이 코드에 유형 주석을 추가하면 다음에 대한 다른 오류가 노출됩니다. 데드 코드 또는 사용되지 않는 지역 변수, 그러나 예제는 여전히 이 문제를 이해하는 데 도움이 됩니다."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"튜플을 사용한 여러 선언"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"let을 사용하여 튜플을 이용해 한 번에 여러 개의 로컬 변수를 동시에 선언할 수 있습니다. 괄호 내에 선언된 로컬 변수들은 튜플에서 해당하는 값으로 초기화됩니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let () = ();\n  let (x0, x1) = (0, 1);\n  let (y0, y1, y2) = (0, 1, 2);\n  let (z0, z1, z2, z3) = (0, 1, 2, 3);\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"표현식의 유형은 튜플 패턴의 인자 수와 일치해야 합니다. 정확히."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let (x, y) = (0, 1, 2); // 오류!\n  let (x, y, z, q) = (0, 1, 2); // 오류!\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"동일한 이름을 가진 로컬을 두 개 이상 선언할 수 없습니다. 싱글 렛."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let (x, x) = 0; // 오류!\n"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"구조체가 있는 여러 선언"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"let은 한 번에 둘 이상의 지역을 소개할 수도 있습니다. 구조체를 분해(또는 일치)합니다. 이 형식에서 let 값으로 초기화되는 지역 변수 세트를 생성합니다. 구조체의 필드. 구문은 다음과 같습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  struct T { f1: u64, f2: u64 }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n  // local1: u64\n  // local2: u64\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["다음은 더 복잡한 예입니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n        struct Y { x1: X, x2: X }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        fun example() {\n            let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };\n            assert!(f + x2.f == 2, 42);\n    \n            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };\n            assert!(f1 + f2 == 2, 42);\n        }\n    }\n    }\n"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"구조체의 필드는 두 가지 역할을 수행할 수 있습니다. 바인드 및 변수의 이름. 이것은 때때로 다음과 같이 언급됩니다. 말장난."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let X { f } = e;"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let X { f: f } = e;"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"튜플과 같이 둘 이상의 로컬을 선언할 수 없습니다. 하나의 let에 같은 이름."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let Y { x1: x, x2: x } = e; // 오류!"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h3",gutterBottom:!0,children:["참조에 대한 파괴"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"구조체에 대한 위의 예에서 let의 바운드 값은 다음과 같습니다. 이동하여 구조체 값을 파괴하고 해당 필드를 바인딩합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  struct T { f1: u64, f2: u64 }"})})," ",(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n  // local1: u64\n  // local2: u64"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:" 이 시나리오에서 구조체 값 T { f1: 1, f2: 2 }는 let 뒤에 더 이상 존재하지 않습니다. 대신 구조체 값을 이동하거나 파괴하지 않으려면 각 필드를 빌릴 수 있습니다. 예를 들면 다음과 같습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let t = T { f1: 1, f2: 2 };\n  let T { f1: local1, f2: local2 } = &t;\n  // local1: &u64\n  // local2: &u64"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"변경 가능한 참조와 마찬가지로 다음과 같습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let t = T { f1: 1, f2: 2 };\n  let T { f1: local1, f2: local2 } = &mut t;\n  // local1: &mut u64\n  // local2: &mut u64"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["이 동작은 중첩 구조체에서도 작동할 수 있습니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n        struct Y { x1: X, x2: X }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        fun example() {\n            let y = Y { x1: new_x(), x2: new_x() };\n    \n            let Y { x1: X { f }, x2 } = &y;\n            assert!(*f + x2.f == 2, 42);\n    \n            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;\n            *f1 = *f1 + 1;\n            *f2 = *f2 + 1;\n            assert!(*f1 + *f2 == 4, 42);\n        }\n    }\n    }"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"값 무시"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["let 바인딩에서 일부 값을 무시하는 것이 종종 도움이 됩니다. 현지의 _로 시작하는 변수는 무시되며 새 변수를 도입하지 않습니다. 변수"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  fun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let (x1, _, z1) = three();\n  let (x2, _y, z2) = three();\n  assert!(x1 + z1 == x2 + z2, 42);"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"컴파일러가 사용하지 않을 때 오류가 발생하므로 때때로 필요할 수 있습니다. 지역 변수"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let (x1, y, z1) = three(); // ERROR!\n  //       ^ unused local 'y'"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h3",gutterBottom:!0,children:["일반 let 문법"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"let의 모든 다른 구조를 결합할 수 있습니다! 이를 통해 let 문의 일반 문법에 도달합니다. let-binding → let pattern-or-list type-annotationopt initializeropt > pattern-or-list → pattern | ( pattern- list ) > pattern-list → pattern ,opt | pattern , pattern-list > type-annotation → : type initializer → = expression 바인딩을 도입하는 항목에 대한 일반 용어는 패턴입니다. ) 바인딩을 소개합니다.패턴 문법은 다음과 같습니다:pattern → local-variable | struct-type { field-binding-list } > field-binding-list → field-binding ,opt | field-binding , field-binding- list > field-binding → field | field : pattern이 문법이 적용된 몇 가지 구체적인 예:"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"      let (x, y): (u64, u64) = (0, 1);\n  //       ^                           local-variable\n  //       ^                           pattern\n  //          ^                        local-variable\n  //          ^                        pattern\n  //          ^                        pattern-list\n  //       ^^^^                        pattern-list\n  //      ^^^^^^                       pattern-or-list\n  //            ^^^^^^^^^^^^           type-annotation\n  //                         ^^^^^^^^  initializer\n  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n  \n      let Foo { f, g: x } = Foo { f: 0, g: 1 };\n  //      ^^^                                    struct-type\n  //            ^                                field\n  //            ^                                field-binding\n  //               ^                             field\n  //                  ^                          local-variable\n  //                  ^                          pattern\n  //               ^^^^                          field-binding\n  //            ^^^^^^^                          field-binding-list\n  //      ^^^^^^^^^^^^^^^                        pattern\n  //      ^^^^^^^^^^^^^^^                        pattern-or-list\n  //                      ^^^^^^^^^^^^^^^^^^^^   initializer\n  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"돌연변이"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"과제"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"로컬이 도입된 후(let 또는 함수로) 매개변수) 로컬은 할당을 통해 수정할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  x = e"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"let 바인딩과 달리 할당은 표현식입니다. 일부 언어에서는 할당은 할당된 값을 반환하지만 Move에서는 할당 유형은 항상 ()입니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  (x = e: ())"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:" 실질적으로 할당이 표현식이라는 것은 중괄호({...})가 있는 새 표현식 블록을 추가하지 않고 사용할 수 있음을 의미합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  if (cond) x = 1 else x = 2;"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["할당은 let 바인딩과 동일한 패턴 구문 체계를 사용합니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        // This example will complain about unused variables and assignments.\n        fun example() {\n           let (x, _, z) = (0, 1, 3);\n           let (x, y, f, g);\n    \n           (X { f }, X { f: x }) = (new_x(), new_x());\n           assert!(f + x == 2, 42);\n    \n           (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);\n        }\n    }\n    }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"지역 변수는 하나의 유형만 가질 수 있으므로 로컬은 할당 간에 변경할 수 없습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x;\n  x = 0;\n  x = false; // ERROR!"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"참조를 통한 변형"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"할당으로 로컬을 직접 수정하는 것 외에도 로컬 변경 가능한 참조 &mut를 통해 수정할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  let r = &mut x;\n  *r = 1;\n  assert!(x == 1, 42);"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이것은 다음과 같은 경우에 특히 유용합니다. (1) 수정하려는 경우 어떤 조건에 따라 다른 변수."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  let y = 1;\n  let r = if (cond) &mut x else &mut y;\n  *r = *r + 1;"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["(2) 다른 함수가 로컬 값을 수정하기를 원합니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  modify_ref(&mut x);"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이러한 종류의 수정은 구조체와 벡터를 수정하는 방법입니다!"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let v = vector::empty();\n  vector::push_back(&mut v, 100);\n  assert!(*vector::borrow(&v, 0) == 100, 42);"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"자세한 내용은 참조 이동을 참조하십시오."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"범위"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:[" let으로 선언된 로컬은 해당 범위 내에서 후속 표현식에 사용할 수 있습니다. 범위는 {...} 식 블록으로 선언됩니다. 로컬은 선언된 범위 외부에서 사용할 수 없습니다. "," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  {\n      let y = 1;\n  };\n  x + y // ERROR!\n  //  ^ unbound local 'y'"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["그러나 외부 범위의 로컬은 중첩 범위에서 사용할 수 있습니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  {\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["로컬은 액세스할 수 있는 모든 범위에서 변경될 수 있습니다. 저것 돌연변이는 범위에 관계없이 로컬과 함께 살아남습니다. 돌연변이를 수행했습니다."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  x = x + 1;\n  assert!(x == 1, 42);\n  {\n      x = x + 1;\n      assert!(x == 2, 42);\n  };\n  assert!(x == 2, 42);"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsxs)(o.Z,{variant:"h3",gutterBottom:!0,children:["표현식 블록"," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"식 블록은 다음으로 구분되는 일련의 문입니다. 세미콜론(;). 식 블록의 결과 값은 블록의 마지막 표현식 값."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  { let x = 1; let y = 1; x + y }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이 예에서 블록의 결과는 x + y입니다. 진술은 할 수 있습니다 let 선언 또는 표현식이어야 합니다. 기억 할당(x = e)은 () 유형의 표현식입니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  { let x; let y = 1; x = 1; x + y }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"함수 호출은 () 유형의 또 다른 일반적인 표현입니다. 기능 데이터를 수정하는 호출은 일반적으로 문으로 사용됩니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  { let v = vector::empty(); vector::push_back(&mut v, 1); v }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"이것은 () 유형에만 국한되지 않습니다. --- 모든 표현식을 다음과 같이 사용할 수 있습니다. 순서대로 진술!"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  {\n    let x = 0;\n    x + 1; // value is discarded\n    x + 2; // value is discarded\n    b"hello"; // value is discarded\n}'})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:" 하지만! 표현식에 리소스(드롭 가능성이 없는 값)가 포함되어 있으면 오류가 발생합니다. 이는 Move의 유형 시스템이 드롭된 모든 값에 드롭 가능성이 있음을 보장하기 때문입니다.(소유권을 이전하거나 값을 이전해야 합니다. 선언 모듈 내에서 명시적으로 소멸됩니다.)"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  {\n    let x = 0;\n    Coin { value: x }; // ERROR!\n//  ^^^^^^^^^^^^^^^^^ unused value without the drop ability\n    x\n}"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"최종 표현식이 블록에 없으면 ---즉, 후행 세미콜론 ;, 암시적 단위() 값이 있습니다. 마찬가지로 표현식 블록이 비어 있으면 암시적 단위() 값."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  // Both are equivalent\n  { x = x + 1; 1 / x; }\n  { x = x + 1; 1 / x; () }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  // Both are equivalent\n  { }\n  { () }"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"식 블록은 그 자체로 식이며 어디에서나 사용할 수 있습니다. 표현이 사용됩니다. (참고: 함수의 본문은 또한 식 블록이지만 함수 본문은 다음으로 대체할 수 없습니다. 다른 표현.)"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  let my_vector: vector<vector<u8>> = {\n    let v = vector::empty();\n    vector::push_back(&mut v, b"hello");\n    vector::push_back(&mut v, b"goodbye");\n    v\n};'})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"(이 예에서는 유형 주석이 필요하지 않으며 추가만 됩니다. 명확성을 위해.)"})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"섀도잉"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"let이 이미 범위에 있는 이름을 가진 지역 변수를 도입하는 경우, 그 이전 변수는 나머지 기간 동안 더 이상 액세스할 수 없습니다. 이 범위. 이것을 쉐도잉이라고 합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  assert!(x == 0, 42);\n  \n  let x = 1; // x is shadowed\n  assert!(x == 1, 42);\n  \n  "})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"로컬이 섀도 처리되면 동일한 유형을 유지할 필요가 없습니다. 이전과."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  let x = 0;\n  assert!(x == 0, 42);\n  \n  let x = b"hello"; // x is shadowed\n  assert!(x == b"hello", 42);\n  \n  '})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"로컬이 가려진 후에도 로컬에 저장된 값은 여전히 존재하지만 더 이상 액세스할 수 없습니다. 이것은 유지하는 것이 중요합니다 드롭 기능이 없는 유형의 값을 소유권으로 염두에 두십시오. 의 값은 함수가 끝날 때까지 전송되어야 합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  address 0x42 {\n    module example {\n        struct Coin has store { value: u64 }\n\n        fun unused_resource(): Coin {\n            let x = Coin { value: 0 }; // ERROR!\n//              ^ This local still contains a value without the drop ability\n            x.value = 1;\n            let x = Coin { value: 10 };\n            x\n//          ^ Invalid return\n        }\n    }\n}"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"로컬이 범위 내에서 섀도잉되면 섀도잉만 남습니다. 해당 범위에 대해. 범위가 끝나면 그림자가 사라집니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  {\n      let x = 1;\n      assert!(x == 1, 42);\n  };\n  assert!(x == 0, 42);"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["지역 주민은 그림자가 드리워지면 유형을 변경할 수 있음을 기억하십시오."," "]})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  let x = 0;\n  {\n      let x = b"hello";\n      assert!(x = b"hello", 42);\n  };\n  assert!(x == 0, 42);'})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"이동 및 복사"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move의 모든 지역 변수는 두 가지 방법으로 사용할 수 있습니다. 또는 복사합니다. 둘 중 하나가 지정되지 않은 경우 Move 컴파일러는 복사 또는 이동을 사용해야 하는지 여부를 추론할 수 있습니다. 이것은 의미합니다 위의 모든 예에서 이동 또는 복사는 컴파일러에 의해 삽입됩니다. 없이는 지역 변수를 사용할 수 없습니다. 이동 또는 복사 사용. 사본이 가장 친숙하게 느껴질 것입니다. 새로운 사본을 생성하므로 다른 프로그래밍 언어에서 해당 식에서 사용할 변수 내부의 값입니다. 와 함께 copy, 지역 변수는 두 번 이상 사용할 수 있습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 0;\n  let y = copy x + 1;\n  let z = copy x + 2;"})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"복사 기능이 있는 값은 이 방법으로 복사할 수 있습니다. 이동하다 데이터를 복사하지 않고 로컬 변수에서 값을 가져옵니다. 이동이 발생한 후에는 로컬 변수를 사용할 수 없습니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:"  let x = 1;\n  let y = move x + 1;\n  //      ------ Local was moved here\n  let z = move x + 2; // Error!\n  //      ^^^^^^ Invalid usage of local 'x'\n  y + z"})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"안전"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"Move의 유형 시스템은 값이 지정된 후에 사용되는 것을 방지합니다. 움직이는. 이것은 let 선언에 설명된 것과 동일한 안전 검사입니다. 할당되기 전에 지역 변수가 사용되는 것을 방지합니다. 가치."})})}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h3",gutterBottom:!0,children:"추론"})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,t.jsx)(d.Z,{sx:{width:"100%",textAlign:"left"},children:(0,t.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"위에서 언급했듯이 Move 컴파일러는 다음과 같은 경우 복사 또는 이동을 유추합니다. 하나는 표시되지 않습니다. 이를 수행하는 알고리즘은 매우 간단합니다. 복사 기능이 있는 모든 스칼라 값에는 복사본이 제공됩니다. 어느 참조(가변 &mut 및 불변 & 모두)에 사본이 제공됩니다. 위해 이동하는 특별한 경우를 제외하고는 예측 가능한 빌림 검사기 오류. 다른 모든 값에는 이동이 제공됩니다. 이것은 다른 값이 복사본을 가질 수 있음을 의미합니다. 프로그래머가 명시적으로 수행해야 합니다. 이것은 큰 데이터 구조의 우발적 복사를 방지합니다."})})}),(0,t.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,t.jsx)(S,{code:'  let s = b"hello";\n  let foo = Foo { f: 0 };\n  let coin = Coin { value: 0 };\n  \n  let s2 = s; // move\n  let foo2 = foo; // move\n  let coin2 = coin; // move\n  \n  let x = 0;\n  let b = false;\n  let addr = @0x42;\n  let x_ref = &x;\n  let coin_ref = &mut coin2;\n  \n  let x2 = x; // copy\n  let b2 = b; // copy\n  let addr2 = @0x42; // copy\n  let x_ref2 = x_ref; // copy\n  let coin_ref2 = coin_ref; // copy'})})]}),P=()=>(0,t.jsx)(n.Z,{container:!0,children:(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h2",gutterBottom:!0,children:"평등"})})})}),q=()=>(0,t.jsx)(n.Z,{container:!0,children:(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsx)(d.Z,{sx:{width:"100%"},children:(0,t.jsx)(o.Z,{variant:"h2",gutterBottom:!0,children:"중단 및 어셜션"})})})});function Y(){let[e,s]=(0,r.useState)(!1),[x,c]=(0,r.useState)(0);function p(e){let{children:s,value:x,index:r,...n}=e;return(0,t.jsx)("div",{style:{textAlign:"center",width:"80%"},role:"tabpanel",hidden:x!==r,id:"vertical-tabpanel-".concat(r),"aria-labelledby":"vertical-tab-".concat(r),...n,children:x===r&&(0,t.jsx)(d.Z,{sx:{p:10,color:"white"},children:(0,t.jsx)(o.Z,{children:s})})})}function j(e){return{id:"vertical-tab-".concat(e),"aria-controls":"vertical-tabpanel-".concat(e)}}return(0,r.useEffect)(()=>{localStorage.getItem("refreshed")||(localStorage.setItem("refreshed",!0),window.location.reload())},[]),(0,r.useEffect)(()=>{s(!0)},[]),p.propTypes={children:h().node,index:h().number.isRequired,value:h().number.isRequired},e&&(0,t.jsxs)(n.Z,{container:!0,sx:{marginTop:"84px"},children:[(0,t.jsxs)(n.Z,{xs:12,sx:{backgroundColor:" #171B1C",textAlign:"center",fontSize:"300%",color:"white"},children:[" ",(0,t.jsx)("img",{src:"/img/move.webp",style:{width:"50px"}}),(0,t.jsx)("div",{children:"MOVE BOOK"})]}),(0,t.jsx)(n.Z,{xs:12,children:(0,t.jsxs)(d.Z,{sx:{flexGrow:1,bgcolor:" #171B1C",display:"flex",minHeight:"600px",textAlign:"center"},children:[(0,t.jsxs)(i.Z,{orientation:"vertical",variant:"scrollable",value:x,onChange:(e,s)=>{c(s)},"aria-label":"Vertical tabs example",sx:{borderRight:1,borderColor:" #171B1C",width:"16%",color:"white"},children:[(0,t.jsx)(l.Z,{sx:{color:"white"},label:"0️⃣ 소개 및 설치",...j(0)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣ 모듈 및 스크립트",...j(1)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣ 정수",...j(2)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"3️⃣ 부울",...j(3)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"4️⃣ 주소",...j(4)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"5️⃣ 벡터",...j(5)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"6️⃣ 서명자",...j(6)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"7️⃣ 참조",...j(7)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"8️⃣ 튜플 및 단위",...j(8)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"9️⃣ 지역 변수 및 범위",...j(9)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"\uD83D\uDD1F 평등",...j(10)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣1️⃣ 중단 및 어성셜",...j(11)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣2️⃣ 조건부",...j(12)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣3️⃣ 반복문",...j(13)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣4️⃣ 기능",...j(14)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣5️⃣ 구조체 리소스",...j(15)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣6️⃣ 상수",...j(16)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣7️⃣ 제네릭",...j(17)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣8️⃣ 능력",...j(18)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"1️⃣9️⃣ 용도 및 별칭",...j(19)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣0️⃣ 친구",...j(20)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣1️⃣ 패키지",...j(21)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣2️⃣ 패키지 업그레이드",...j(22)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣3️⃣ 단위 및 테스트",...j(23)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣4️⃣ 글로벌 스토리지 구조",...j(24)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣5️⃣ 글로벌 스토리지 사업자",...j(25)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣6️⃣ 도서관",...j(26)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"2️⃣7️⃣ 코딩 규칙 이동",...j(27)}),(0,t.jsx)(l.Z,{sx:{color:"white"},label:"\uD83E\uDD28 tutorial",...j(28)})]}),(0,t.jsx)(p,{value:x,index:0,children:(0,t.jsx)(a,{})}),(0,t.jsx)(p,{value:x,index:1,children:(0,t.jsx)(m,{})}),(0,t.jsx)(p,{value:x,index:2,children:(0,t.jsx)(B,{})}),(0,t.jsx)(p,{value:x,index:3,children:(0,t.jsx)(_,{})}),(0,t.jsx)(p,{value:x,index:4,children:(0,t.jsx)(A,{})}),(0,t.jsx)(p,{value:x,index:5,children:(0,t.jsx)(M,{})}),(0,t.jsx)(p,{value:x,index:6,children:(0,t.jsx)(C,{})}),(0,t.jsx)(p,{value:x,index:7,children:(0,t.jsx)(R,{})}),(0,t.jsx)(p,{value:x,index:8,children:(0,t.jsx)(k,{})}),(0,t.jsx)(p,{value:x,index:9,children:(0,t.jsx)(O,{})}),(0,t.jsx)(p,{value:x,index:10,children:(0,t.jsx)(P,{})}),(0,t.jsx)(p,{value:x,index:11,children:(0,t.jsx)(q,{})}),(0,t.jsx)(p,{value:x,index:12,children:"5"}),(0,t.jsx)(p,{value:x,index:13,children:"5"}),(0,t.jsx)(p,{value:x,index:14,children:"5"}),(0,t.jsx)(p,{value:x,index:15,children:"5"}),(0,t.jsx)(p,{value:x,index:16,children:"16장"}),(0,t.jsx)(p,{value:x,index:17,children:"16장"}),(0,t.jsx)(p,{value:x,index:18,children:"16장"}),(0,t.jsx)(p,{value:x,index:19,children:"16장"}),(0,t.jsx)(p,{value:x,index:20,children:"16장"}),(0,t.jsx)(p,{value:x,index:21,children:"16장"}),(0,t.jsx)(p,{value:x,index:22,children:"16장"}),(0,t.jsx)(p,{value:x,index:23,children:"16장"}),(0,t.jsx)(p,{value:x,index:24,children:"16장"}),(0,t.jsx)(p,{value:x,index:25,children:"16장"}),(0,t.jsx)(p,{value:x,index:26,children:"16장"}),(0,t.jsx)(p,{value:x,index:27,children:"마지막"}),(0,t.jsx)(p,{value:x,index:28,children:"튜토리얼"})]})})]})}}},function(e){e.O(0,[648,774,888,179],function(){return e(e.s=75557)}),_N_E=e.O()}]);