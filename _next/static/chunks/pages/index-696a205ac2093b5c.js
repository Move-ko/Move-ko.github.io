(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5405],{5557:function(e,s,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return r(2319)}])},2319:function(e,s,r){"use strict";r.r(s),r.d(s,{default:function(){return E}});var i=r(5893),t=r(7294),n=r(6274),o=r(4767),x=r(44),l=r(7357),d=r(5861),c=r(5697),h=r.n(c);r(2756);var a=e=>{let{children:s}=e;return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"\uD83E\uDDD0What is Move?"})})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Diem 블록체인의 구현을 위해 Rust언어에서 힌트를 받아 만들어졌으며,현재는 ",(0,i.jsx)("span",{style:{color:"purple"},children:"Aptos"})," ","및 ",(0,i.jsx)("span",{style:{color:"purple"},children:"Sui"}),"에서 사용하고 있습니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move를 사용하면 개발자가 자산을 유연하게 관리하고 전송하는 프로그램을 작성하는 동시에 해당 자산에 대한 공격에 방어(보안 및 보호)를 제공할수 있습니다."})]})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,children:(0,i.jsx)("img",{src:"/img/move.webp",style:{width:"100%",borderRadius:"10px",marginTop:"30px"}})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"특징"})})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 자산 보안: Move 언어는 자산의 보안성을 강조합니다. 타입 시스템을 사용하여 자산의 일관성과 불변성을 보장하며, 잠재적인 버그와 취약점을 예방하는데 도움이 됩니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"2.자산의 흐름 제어: Move 언어는 자산의 흐름을 제어하는 것을 강조합니다. 자산의 이동 및 전송에 대한 규칙과 제약을 명확하게 정의하여 보안과 논리적 일관성을 유지합니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈화: Move 언어는 모듈화를 지원하여 스마트 컨트랙트의 재사용성과 확장성을 향상시킵니다. 모듈은 독립적으로 작동하며 다른 모듈과 상호작용할 수 있습니다."})]})})]})},p=r(3321),j=r(1163),m=e=>{let{children:s}=e,r=(0,j.useRouter)();return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"1️⃣ 모듈과 스크립트"})})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,i.jsx)("span",{style:{color:"purple"},children:"모듈"})," 과"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"라는 두 가지 유형의 프로그램이 있습니다."," ",(0,i.jsx)("span",{style:{color:"purple"},children:"모듈"}),"은 이러한 유형에서 작동하는 함수와 함께 구조체 유형을 정의하는 라이브러리이며,구조체 유형은 Move의 전역저장소 스키마를 정의하고 모듈 함수는 저장소 업데이트 규칙을 정의하고 있으며,모듈은 전역저장소에 저장됩니다.",(0,i.jsx)("span",{style:{color:"purple"},children:"스크립트"}),"는 전역저장소에 게시되지 않는 재사용 가능한 소스 코드, 이며, 일반적으로 전역저장소에 대한 업데이트를 수행하는 게시된 모듈의 기능을 호출합니다.또한 main스크립트는 기존 언어의 함수와 유사한 실행 가능한 진입점입니다."]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 소스 파일("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"또는 컴파일 단위"})," )에는 여러 모듈과 스크립트가 포함될 수 있습니다. 그러나 모듈 게시 또는 스크립트 실행은 각각 별도의 VM 작업입니다."]})]})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"스크립트"})})}),(0,i.jsx)(n.Z,{xs:12,children:" ex)스크립트 구조"}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_1.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"20px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["script는 use("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"다른 모듈에서 유형을 가져오는데 사용하는 함수"}),")로 선언으로 시작하며 그 밑에 상수 그밑에 함수순으로 진행 되어야합니다.main함수는 어떤 이름이든 가질수 있으며(",(0,i.jsx)("span",{style:{color:"purple"},children:"main함수를 호출할 필요가 없음."}),")스크립트 내의 유일한 함수이며 인수를 얼마든지 가질수 있고 값은 반환할수 없습니다.또한 스크립트에는 스크립트는 권한이 매우 제한되어 있습니다(",(0,i.jsx)("span",{style:{color:"purple"},children:"Friends함수를 선언하거나 유형을 구성하거나 전역저장소에 접근 할 수 없습니다."}),")주요 목적은 모듈 함수를 호출하는 것입니다."]})})}),(0,i.jsxs)(n.Z,{xs:12,children:[(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"}}),(0,i.jsx)(d.Z,{children:(0,i.jsx)("span",{style:{color:"purple"},children:"* friend: 현재 모듈에서 신뢰하는 모듈을 선언하는 데 사용됩니다."})})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_2.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"모듈"})})}),(0,i.jsxs)(n.Z,{xs:12,children:[" ",(0,i.jsx)("span",{style:{color:"purple"},children:"*모듈 구조"})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_3.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 모듈 이름은 소문자로 시작합니다 명명된 모듈은 my_module명명된 소스파일에 저장되어야 합니다.모듈 블록 내의 모든 요소는 어떤 순서로든 나타날 수 있습니다. 기본적으로 모듈은 유형과 함수의 집합입니다."}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsxs)(l.Z,{sx:{width:"100%"},children:[(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsxs)("span",{style:{color:"purple"},children:["*address:명명된 주소("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),") 또는 리터럴 주소"]})}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsxs)("span",{style:{color:"purple"},children:["*const:모듈의 함수에서 사용할수있는 전용"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"상수"}),"를 지정"]})})]})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_4.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 module 0x42::example모듈의 부분은 모듈이 전역저장소의 계정주소로 게시되도록 지정합니다 모듈은 명명된 주소(",(0,i.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")를 사용하여 선언할수도 있습니다"]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_5.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),")는 소스언어 수준과 컴파일 중에만 존재하기 떄문에 명명된 주소는 바이트코드 수준에서 해당 값을 완전히 대체합니다"]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_6.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_6.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["my_addr로 설정하여 컴파일하면"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"0xC0FFEE"}),"운영상 다음과 동일합니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"40px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_7.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["그러나 소스 수준에서 이들은 동일하지 않습니다.함수는 해당 주소에 할당된 숫자값이 아니라 명명된 주소를 통해 엑세스 해야 m::foo합니다 모듈 이름은 문재 ",(0,i.jsx)("span",{style:{color:"purple"},children:"a to z"})," ","또는 ",(0,i.jsx)("span",{style:{color:"purple"},children:"Ato"}),"로 시작할수 있습니다"]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["첫번쨰 문자 뒤에 모듈 이름에는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"밑줄 a~z,A~Z"}),"또는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"숫자"}),"가 포함될수 있습니다."]})]})}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83E\uDD28모듈 특징정리"})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 모듈 요소(사용, 상수, 함수 등)는 특정 순서로 구성되어야 합니다."}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.모듈은 ",(0,i.jsx)("span",{style:{color:"purple"},children:"전역저장소에"}),"저장됩니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈은 main이라는 함수를 포함해야 합니다."}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["4. ",(0,i.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 모듈에서 유효합니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.모듈의 어떤 함수도 반환 값을 가질 수 없습니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.모듈에는 하나의 함수만 선언할 수 있습니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.친구 모듈은 모듈 내에서 유효합니다."}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["8.모듈은 ",(0,i.jsx)("span",{style:{color:"purple"},children:"주소"}),"와"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"식별자"}),"로 선언해야 합니다."]})]})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"40px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83D\uDC69‍\uD83C\uDF93스크립트 특징정리"})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["1.스크립트는 ",(0,i.jsx)("span",{style:{color:"purple"},children:"전역저장소"}),"에 저장되지 않습니다."]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.스크립트 요소(사용, 상수, 함수 등)는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"특정순서"}),"로 구성되어야 합니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.스크립트 블록에는 하나의 함수만 선언할 수 있습니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"4. 스크립트 함수는 임의의 이름을 가질 수 있습니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.상수는 스크립트에서 유효합니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.스크립트에는 하나의 함수만 선언할 수 있으며 이름은 main으로 지정해야 합니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.스크립트에 선언된 함수는 얼마든지 있을 수 있습니다."}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"8.friend 모듈은 스크립트에서 선언할 수 있습니다."}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["9.스크립트에서 선언된 함수는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"매개변수"}),"를 가질 수 없습니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"10. 스크립트에서 선언된 함수는 반환 값을 가질 수 없습니다."}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["11. ",(0,i.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 스크립트에서 유효합니다."]})]})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,children:"ex)예시"}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsxs)(n.Z,{xs:12,md:8,children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/1/1_9.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/1_9.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:2})]})},u=r(7906),Z=r(295),v=r(8102),g=r(9755),b=r(2882),y=r(3184),T=r(3816),w=r(629),B=r(948),_=e=>{let{children:s}=e,r=(0,j.useRouter)(),t=(0,B.ZP)(v.Z)(e=>{let{theme:s}=e;return{["&.".concat(g.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(g.Z.body)]:{fontSize:12}}}),o=(0,B.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"2️⃣ 정수"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move는 6개의 부호 없는 정수 유형("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128,u256"}),") 을 지원합니다.이러한 유형의 값 범위는 유형의 크기에 따라 0에서 최대값까지입니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"유형"}),(0,i.jsx)(t,{children:"값 범위"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{type:"부호 없는 8비트 정수,u8",range:"0 ~ 2^8 - 1"},{type:"부호 없는 16비트 정수,u16",range:"0 ~ 2^16 - 1"},{type:"부호 없는 32비트 정수,u32",range:"0 ~ 2^32 - 1"},{type:"부호 없는 64비트 정수,u64",range:"0 ~ 2^64 - 1"},{type:"부호 없는 128비트 정수,u128",range:"0 ~ 2^128 - 1"},{type:"부호 없는 256비트 정수,u256",range:"0 ~ 2^256 - 1"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.type}),(0,i.jsx)(t,{children:null==e?void 0:e.range})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"20px"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이러한 유형의 리터럴 값은 숫자의 연속으로 지정할 수 있습니다 예를 들어, ",(0,i.jsx)("span",{style:{color:"purple"},children:"112"}),"나"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"0xFF"}),"와 같이 사용할 수 있습니다. 리터럴의 유형은 선택적으로 접미사로 추가할 수 있습니다. 예를 들어, ",(0,i.jsx)("span",{style:{color:"purple"},children:"112u8"}),"과 같이 사용할 수 있습니다. 유형이 지정되지 않으면 컴파일러는 리터럴이 사용된 문맥에서 유형을 추론하려고 시도합니다. 유형을 추론할 수 없는 경우 u64로 가정합니다.숫자 리터럴은 그룹화와 가독성을 위해 밑줄로 구분할 수 있습니다.",(0,i.jsx)("span",{style:{color:"purple"},children:"(예: 1_234_5678, 1_000u128, 0xAB_CD_12_35)"}),". 리터럴이 지정된("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"또는 추론된"}),") 크기 범위보다 너무 큰 경우, 오류가 보고됩니다. 이는 정수 리터럴이 해당하는 유형의 범위를 초과하는 경우에 발생합니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_1.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"산술"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["각각의 유형은 동일한 집합의 체크된 산술 연산을 지원합니다. 이러한 모든 연산에서는 두 인수("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"왼쪽과 오른쪽 피연산자"}),")가 동일한 유형이어야 합니다. 서로 다른 유형의 값을 연산해야 하는 경우 먼저 형 변환을 수행해야 합니다. 마찬가지로, 연산 결과가 정수 유형에 너무 크다고 예상되는 경우 연산을 수행하기 전에 더 큰 크기로 형 변환을 수행해야 합니다. 모든 산술 연산은 수학적인 정수와는 달리"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"오버플로,언더플로,0으로 나누기"}),"와 같이 수학적으로 정수가 아닌 동작을 하지 않고 대신"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"중단"}),"됩니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"}),(0,i.jsx)(t,{children:"중단"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"+",작업:"덧셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"-",작업:"뺴기",중단:"결과가 0보다 작음"},{통사론:"*",작업:"곱셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"%",작업:"모듈식 분할",중단:"제수는 0"},{통사론:"/",작업:"잘림 나누기",중단:"제수는 0"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업}),(0,i.jsx)(t,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트연산"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,sx:{textAlign:"left"},children:["정수 유형은 다음과 같은 비트 연산을 지원합니다. 이러한 연산은 각 숫자를 0 또는 1로 구성된 개별적인 비트 시퀀스로 취급하며 숫자적인 정수 값으로 취급하지 않습니다."," "]}),(0,i.jsxs)(d.Z,{children:[" ",(0,i.jsx)("span",{style:{color:"purple"},children:"* 비트 연산은 중단되지 않습니다."})]})]})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"}),(0,i.jsx)(t,{children:"설명"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"&",작업:"비트 및",설명:"부울을 수행하고 각 비트에 대해 쌍으로"},{통사론:"|",작업:"비트 또는",설명:"부울 또는 각 비트에 대해 쌍으로 수행"},{통사론:"^",작업:"비트 xor",설명:"부을 독점 또는 각 비트에 대해 쌍으로 수행"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업}),(0,i.jsx)(t,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트시프트"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["비트 연산과 유사하게, 각 정수 유형은 비트 시프트를 지원합니다. 그러나 다른 연산과 달리, 우측 피연산자(시프트할 비트 수)는 항상",(0,i.jsx)("span",{style:{color:"purple"},children:"u8"}),"이어야 하며 좌측 피연산자( ",(0,i.jsx)("span",{style:{color:"purple"},children:"시프트할 숫자"}),")와 일치할 필요는 없습니다.비트 시프트는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"u8, u16, u32, u64, u128 , u256"}),"에 대해 각각"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"8, 16, 32, 64, 128, 256"}),"보다"," ",(0,i.jsxs)("span",{style:{color:"purple"},children:[" ","크거나 같은 비트 수로 시프트할 경우 중지될 수 있습니다."]})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"}),(0,i.jsx)(t,{children:"중단"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"<<",작업:"왼쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"},{통사론:">>",작업:"오른쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업}),(0,i.jsx)(t,{children:null==e?void 0:e.중단})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비교 연산자"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 정수 유형만이 비교 연산자를 사용할 수 있습니다. 비교 연산자를 사용할 때는 두 인자가 동일한 유형이어야 합니다. 만약 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 한 쪽을 형변환해야 합니다. Move에서의 비교 연산은"," ",(0,i.jsx)("span",{style:{color:"purple"},children:" 중단되지 않습니다."})," 이는 비교 연산이 갑작스럽게 종료되거나 오류를 발생시키지 않는다는 것을 의미합니다. 대신, 비교 연산은 비교 결과를 나타내는 불리언 값 ("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"참 또는 거짓"}),")을 반환합니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"<",작업:"보다 작은"},{통사론:">",작업:"보다큰"},{통사론:"<=",작업:"작거나 같음"},{통사론:">=",작업:"크거나 같음"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"평등"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move의 모든 정수 유형은"," ",(0,i.jsx)("span",{style:{color:"purple"},children:'"equal"'}),"과",(0,i.jsx)("span",{style:{color:"purple"},children:'"not equal"'})," 연산을 지원합니다. 두 인자는 동일한 유형이어야 합니다. 서로 다른 유형의 정수를 비교해야 하는 경우, 먼저 하나를 형변환해야 합니다."," ",(0,i.jsx)("span",{style:{color:"purple"},children:"등호 연산은 중단되지 않습니다."})," "]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"==",작업:"같은"},{통사론:"!=",작업:"같지않은"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형변환"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 한 크기의 정수 유형을 다른 크기의 정수 유형으로"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"형변환"})," 할 수 있습니다. 정수는 Move에서 형변환를 지원하는 유일한 유형입니다. 정수를 크기가 다른 유형으로 형변환 할 때, Move에서는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"형변환이 값을 절단하지 않는다는 점"}),"에 유의해야 합니다. 이는 형변환 연산이 원래 정수의 전체 값을 보존한다는 것을 의미합니다. 즉, 목표 정수 유형의 범위를 초과하는 경우에도 원래 정수의 전체 값이 유지됩니다. 그러나, 형변환의 결과가 지정된 유형에 너무 큰 경우 형변환이 중단될 수 있다는 점을 알려드립니다. 이는형변환 결과가 지정된 유형에 맞지 않을 때 형변환이 중단되는 것을 의미합니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(t,{children:"통사론"}),(0,i.jsx)(t,{children:"작업"}),(0,i.jsx)(t,{children:"다음과 같은 경우 중단"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"(e as T)",작업:"e 정수 표현식을 정수 유형으로형변환T",설명:"e로 표현하기에는 너무 큽니다"}].map(e=>(0,i.jsxs)(o,{children:[(0,i.jsx)(t,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(t,{children:null==e?void 0:e.작업}),(0,i.jsx)(t,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 언어에 내장된 정수 값들도 암묵적으로 복사 가능한 속성을 갖고 있습니다.",(0,i.jsx)("span",{style:{color:"purple"},children:"이는 복사와 같은 명시적 명령 없이도 복사될 수 있다는 것을 의미"})," ","합니다. 정수 값을 새 변수에 할당하거나 함수 인자로 전달할 때, 해당 값의 복사본이 생성됩니다. 원본 값과 복사본은 서로 독립적으로 사용될 수 있으며, 한 쪽 복사본을 수정해도 다른 쪽에는 영향을 미치지 않습니다. 이러한 복사 연산은 내부적으로 암묵적으로 처리됩니다. 예를 들어:"]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{r.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/2_2.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:12,sx:{textAlign:"left",marginTop:"30px"},children:[" ",(0,i.jsxs)(d.Z,{children:["이 경우,"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"x의 값이 y로 복사되며, x와 y는 각각 정수 값의 독립적인 복사본을 가지고 있습니다."}),"y를 수정해도 x의 값에는 영향을 주지 않으며, 그 반대도 마찬가지입니다. 이러한 암묵적인 복사 동작은 명시적인 복사 명령 없이도 정수 값을 간편하게 처리할 수 있도록 해줍니다. 그러나 보다 복잡한 유형과 리소스의 경우, Move에서는 소유권과 빌림에 대한 명시적인 지침이나 고려 사항이 필요할 수 있습니다."]})]})]})},f=e=>{let{children:s}=e,r=(0,B.ZP)(v.Z)(e=>{let{theme:s}=e;return{["&.".concat(g.Z.head)]:{backgroundColor:s.palette.common.black,color:s.palette.common.white},["&.".concat(g.Z.body)]:{fontSize:10}}}),t=(0,B.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.action.hover},"&:last-child td, &:last-child th":{border:0}}});return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"부울"})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,i.jsx)("span",{style:{color:"purple"},children:"부울"}),"은 Move에서 boolean"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"true"}),"와"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"false"})," 값을 표현하기 위한 원시 타입입니다.또한 bool 타입의 리터럴은 true 또는 false로 표현됩니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"* bool은 세가지 논리 연산을 지원합니다."})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(r,{children:"통사론"}),(0,i.jsx)(r,{children:"설명"}),(0,i.jsx)(r,{children:"등가표현"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"&&",설명:"단락 논리 및",등가표현:"p && q에 해당합니다 if(p)q else false"},{통사론:"||",설명:"단락 논리 또는",등가표현:"p || q 에 해당합니다 if(p) true else q"},{통사론:"!",설명:"논리적 부정",등가표현:"!p에 해당합니다 if(q) false else true"}].map(e=>(0,i.jsxs)(t,{children:[(0,i.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(r,{children:null==e?void 0:e.설명}),(0,i.jsx)(r,{children:null==e?void 0:e.등가표현})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"bool 값은 Move의 여러 제어 흐름 구조에서 사용됩니다:"})})}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"* if문"})})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/3_2_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"* while문"})})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/3_2_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"3) assert:이 연산은 두 개의 인자를 받습니다: bool 타입의 조건과 u64 타입의 코드"})})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/3_2_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다른 스칼라 값들과 마찬가지로, 언어 내장의 boolean 값들은 암시적으로 복사 가능합니다. 즉, copy와 같은 명시적인 지시어 없이도 복사할 수 있습니다."})})})]})},A=e=>{let{children:s}=e;return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"주소"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,i.jsx)("span",{style:{color:"purple"},children:"주소(Address)"})," 는 Move 언어에서 글로벌 스토리지의 위치(가끔은 계정이라고도 함)를 나타내기 위해 사용되는 내장된 유형입니다. 주소 값은"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"128비트(16바이트)"}),"식별자입니다. 특정 주소에는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"모듈(Module)"}),"과",(0,i.jsx)("span",{style:{color:"purple"},children:"리소스(Resource)"}),"두 가지 요소를 저장할 수 있습니다."]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["실제로 주소는 128비트 정수로 구성되지만, Move 주소는 의도적으로 불투명한 형태로 구성되어 있습니다. 즉, 정수로부터 주소를 생성할 수 없으며, 산술 연산을 지원하지 않으며, 수정할 수 없습니다. 포인터 산술과 유사한 용도로 사용될 수 있는 흥미로운 프로그램이 있을 수 있지만 (예: C의 포인터 산술), Move는 정적 검증을 지원하기 위해 처음부터",(0,i.jsx)("span",{style:{color:"purple"},children:"이러한 동적 동작을 허용하지 않습니다."})]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["런타임 주소 값("," ",(0,i.jsx)("span",{style:{color:"purple"},children:"주소 유형의 값"}),")을 사용하여 해당 주소에 있는 리소스에 접근할 수 있습니다. 주소 값을 통해 런타임에서 모듈에 액세스할 수는 없습니다."]})]})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"문법"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소는 ",(0,i.jsx)("span",{style:{color:"purple"},children:"명명된(named) 주소"}),"와",(0,i.jsx)("span",{style:{color:"purple"},children:"숫자형(numerical) 주소"})," 로 두 가지 형태로 나뉩니다. 명명된 주소의 구문은 Move에서 일반적으로 사용되는 명명된 식별자의 규칙을 따릅니다. 숫자형 주소의 구문은 16진수로 인코딩된 값에 제한되지 않으며, 유효한 u128 숫자 값으로 주소 값으로 사용할 수 있습니다. 예를 들어,"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"42, 0xCAFE, 2021"})," 은 모두 유효한 숫자형 주소 리터럴입니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"주소가 식(expression) 컨텍스트에서 사용되는지 여부를 구분하기 위해 주소를 사용하는 구문은 사용되는 컨텍스트에 따라 다릅니다:"}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소가 식으로 사용될 때는 주소 앞에 @ 문자가 붙어야 합니다. 즉,"," ",(0,i.jsxs)("span",{style:{color:"purple"},children:[" ","@<numerical_value>"]})," ","또는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"@<named_address_identifier>"})," ","형태여야 합니다. 식 컨텍스트 이외의 곳에서는 주소를 @ 문자 없이 쓸 수 있습니다. 즉,"," ",(0,i.jsx)("span",{style:{color:"purple"},children:" <numerical_value>"})," 또는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"<named_address_identifier>"})," ","형태로 쓸 수 있습니다. 일반적으로 @는 주소를 네임스페이스 항목에서 식 항목으로 전환하는 연산자로 생각할 수 있습니다."]})]})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"명명된 주소"})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsxs)(n.Z,{xs:12,md:6,sx:{marginTop:"30px"},children:[(0,i.jsx)(p.Z,{variant:"contained",size:"medium",onClick:e=>{router.push("https://github.com/Move-ko/Move-ko.github.io/blob/main/Move/2/4_1.move")},children:"Code"}),(0,i.jsx)("img",{src:"/img/4_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})]}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소(named addresses)는 주소가 사용되는 모든 위치에서 숫자 값 대신 식별자를 사용할 수 있도록 하는 기능입니다. 명명된 주소는 Move 패키지의 최상위 요소(모듈 및 스크립트 외부)로 선언되고 바인딩됩니다. 또한 Move 컴파일러에 인수로 전달될 수도 있습니다. 명명된 주소는 값 수준뿐만 아니라 주소가 사용되는"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"모든 위치"}),"에서 사용될 수 있으며, 소스 언어 수준에서만 존재하며 바이트코드 수준에서는 완전히 해당 값을 ",(0,i.jsx)("span",{style:{color:"purple"},children:"대체"}),"합니다. 따라서 모듈과 모듈 멤버는 모듈의 명명된 주소를 통해 접근해야 하며, 명명된 주소에 할당된 숫자 값으로 모듈 및 모듈 멤버에 접근해서는 안 됩니다. 예를 들어,",(0,i.jsx)("span",{style:{color:"purple"},children:"my_addr이 0x2로 설정된 상태"})," ","에서 Move 프로그램이 컴파일되더라도"," ",(0,i.jsx)("span",{style:{color:"purple"},children:"use my_addr::foo는 use 0x2::foo와 동일하지 않습니다"}),". 이 차이점은 모듈과 스크립트 섹션에서 자세히 논의됩니다."]})})}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"글로벌 스토리지 운영"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소 값의 주요 목적은 글로벌 스토리지 작업과 상호 작용하는 데에 있습니다. 주소 값은",(0,i.jsx)("span",{style:{color:"purple"},children:"exists, borrow_global, borrow_global_mut, move_from"})," ","등의 작업과 함께 사용됩니다. 주소를 사용하지 않는 유일한 글로벌 스토리지 작업은 ",(0,i.jsx)("span",{style:{color:"purple"},children:"move_to"}),"입니다. move_to 작업은",(0,i.jsx)("span",{style:{color:"purple"},children:"signer"})," 를 사용합니다."]})})}),(0,i.jsxs)(n.Z,{xs:12,sx:{marginTop:"10px"},children:[(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"*exists: 주소 아래에 T가 저장되어 있으면 true를 반환"})}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"*borrow_global:address 아래에 저장된 T에 대한 불변 참조를 반환합"})}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"* borrow_global_mut:address 아래에 저장된 T에 대한 변경 가능한 참조를 반환"})}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"*move_from:T 주소에서 T를 제거하고 반환"})}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,i.jsx)("span",{style:{color:"purple"},children:"* move_to:signer.address 아래에 T를 게시"})})]}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:['언어에 내장된 다른 스칼라 값과 마찬가지로 주소 값도 암시적으로 복사 가능(copyable)합니다. 이는 "copy"와 같은',(0,i.jsx)("span",{style:{color:"purple"},children:"명시적인 명령 없이도 주소 값이 복사될 수 있다는 것을 의미"})," ","합니다. 주소 값을 새 변수에 할당하거나 함수에 인수로 전달할 때, 주소 값의 복사본이 생성되며 원본과 복사본 주소 모두 독립적으로 사용할 수 있습니다."]})})})]})},M=e=>{let{children:s}=e,r=(0,B.ZP)(v.Z)(e=>{let{theme:s}=e;return{["&.".concat(g.Z.head)]:{backgroundColor:" #171B1C",color:s.palette.common.white},["&.".concat(g.Z.body)]:{fontSize:12}}}),t=(0,B.ZP)(T.Z)(e=>{let{theme:s}=e;return{"&:nth-of-type(odd)":{backgroundColor:s.palette.common.white,color:s.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,i.jsxs)(n.Z,{container:!0,children:[(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"벡터"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서 제공하는 유일한 원시 컬렉션 타입은 ","vector<T>","입니다."," ","vector<T>","는 T의 동일한 유형의 항목들로 구성된 컬렉션으로, 값들을 끝에 push하거나 pop하여 크기를 조절할 수 있습니다.","vector<T>","는 어떤 유형 T로도 인스턴스화할 수 있습니다. 예를 들어,"," ","vector<u64>, vector<address>, vector<0x42::MyModule::MyResource> 및 vector<vector<u8>>","은 모두 유효한 vector 타입입니다."]})})}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"일반적인 벡터 리터럴"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"벡터 리터럴을 사용하여 어떤 유형의 벡터든 생성할 수 있습니다."})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(r,{children:"통사론"}),(0,i.jsx)(r,{children:"타입"}),(0,i.jsx)(r,{children:"설명"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{통사론:"vector[]",타입:"vector[]: vector<T> where T is any single, non-reference type",설명:"비어있는 벡터"},{통사론:"vector[e1, ..., en]",타입:"vector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0",설명:" n개의 요소가 있는 벡터(길이 n)"}].map(e=>(0,i.jsxs)(t,{children:[(0,i.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.통사론}),(0,i.jsx)(r,{children:null==e?void 0:e.타입}),(0,i.jsx)(r,{children:null==e?void 0:e.설명})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 경우에는 벡터의 유형이 원소 유형이나 벡터의 사용으로부터 추론됩니다. 유형을 추론할 수 없는 경우 또는 명확성을 위해 유형을 명시적으로 지정할 수도 있습니다."})})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_1.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,md:4,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_2.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:4}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["vector","<u8>"," 타입의 리터럴"]})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left"},children:[(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:['Move에서 벡터를 사용하는 일반적인 사례는 "바이트 배열"을 나타내는 것인데, 이는 ',"vector<u8>","로 표현됩니다. 이러한 값들은 종종 공개 키나 해시 결과와 같은 암호화 목적으로 사용됩니다. 이러한 값들은 널리 사용되어 특정 구문이 제공되어 값을 더 가독성 있게 만들어줍니다. 각 개별 u8 값이 숫자 형태로 지정되는 vector[]를 사용해야 하는 대신에 특정 구문을 사용할 수 있습니다."]}),(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["현재 지원되는 두 가지 유형의 ","vector<u8>"," 리터럴은 바이트 문자열(byte strings)과 16진수 문자열(hex strings)입니다."]}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'바이트 문자열(Byte Strings) 바이트 문자열은 b로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어, b"Hello!\\n"과 같습니다.'}),(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이는 ASCII로 인코딩된 문자열로서 이스케이프 시퀀스를 허용합니다. 현재 지원되는 이스케이프 시퀀스는 다음과 같습니다:"})]})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(r,{children:"이스케이프_시퀀스"}),(0,i.jsx)(r,{children:"설명"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{이스케이프_시퀀스:"\\n",Description:"새 줄(또는 줄바꿈)"},{이스케이프_시퀀스:"\\r",Description:"캐리지 리턴(Carriage return)"},{이스케이프_시퀀스:"\\t",Description:"Tab"},{이스케이프_시퀀스:"\\\\",Description:"Backslash"},{이스케이프_시퀀스:"\\0",Description:"Null"},{이스케이프_시퀀스:'\\"',Description:"Quote"},{이스케이프_시퀀스:"\\xHH",Description:"Hex escape, inserts the hex byte sequence HH"}].map(e=>(0,i.jsxs)(t,{children:[(0,i.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.이스케이프_시퀀스}),(0,i.jsx)(r,{children:null==e?void 0:e.Description})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:['16진수 문자열(Hex Strings) 16진수 문자열은 x로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어, x"48656C6C6F210A"와 같습니다. 각각의 바이트 쌍은 00부터 FF까지의 16진수로 인코딩된 u8 값을 의미합니다. 따라서 각 바이트 쌍은 결과적인'," ","vector<u8>","에서 하나의 항목에 해당합니다. 예시 문자열 리터럴"]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_3.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"vector는 아래와 같이 Move 표준 라이브러리의 std::vector 모듈을 통해 여러 작업을 제공합니다. 시간이 지남에 따라 더 많은 작업이 추가될 수 있습니다. 벡터에 대한 최신 문서는 여기에서 찾을 수 있습니다."})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,i.jsx)(b.Z,{component:w.Z,children:(0,i.jsxs)(u.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,i.jsx)(y.Z,{children:(0,i.jsxs)(T.Z,{children:[(0,i.jsx)(r,{children:"Function"}),(0,i.jsx)(r,{children:"Description"}),(0,i.jsx)(r,{children:"Aborts?"})]})}),(0,i.jsx)(Z.Z,{component:"div",children:[{Function:"vector::empty<T>(): vector<T>	",Description:"T 유형의 값을 저장할 수 있는 빈 벡터를 만듭니다.",Aborts:"절대"},{Function:"vector::is_empty<T>(): bool",Description:"새 줄(또는 줄바꿈)",Aborts:"절대"},{Function:"vector::singleton<T>(t: T): vector<T>",Description:"새 줄(또는 줄바꿈)",Aborts:"절대"},{Function:"vector::length<T>(v: &vector<T>): u64",Description:"새 줄(또는 줄바꿈)",Aborts:"절대"},{Function:"vector::push_back<T>(v: &mut vector<T>, t: T)",Description:"새 줄(또는 줄바꿈)",Aborts:"절대"},{Function:"vector::pop_back<T>(v: &mut vector<T>): T",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::borrow<T>(v: &vector<T>, i: u64): &T",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::destroy_empty<T>(v: vector<T>)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::append<T>(v1: &mut vector<T>, v2: vector<T>)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::reverse_append<T>(lhs: &mut vector<T>, other: vector<T>)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::contains<T>(v: &vector<T>, e: &T): bool",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::swap<T>(v: &mut vector<T>, i: u64, j: u64)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::reverse<T>(v: &mut vector<T>)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::reverse_slice<T>(v: &mut vector<T>, l: u64, r: u64)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::insert<T>(v: &mut vector<T>, i: u64, e: T)",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::remove<T>(v: &mut vector<T>, i: u64): T",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::swap_remove<T>(v: &mut vector<T>, i: u64): T",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::trim<T>(v: &mut vector<T>, new_len: u64): u64",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::trim_reverse<T>(v: &mut vector<T>, new_len: u64): u64",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::rotate<T>(v: &mut vector<T>, rot: u64): u64",Description:"새 줄(또는 줄바꿈)",Aborts:""},{Function:"vector::rotate_slice<T>(v: &mut vector<T>, left: u64, rot: u64, right: u64): u64",Description:"새 줄(또는 줄바꿈)",Aborts:""}].map(e=>(0,i.jsxs)(t,{children:[(0,i.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.Function}),(0,i.jsx)(r,{component:"div",scope:"row",children:null==e?void 0:e.Description}),(0,i.jsx)(r,{children:null==e?void 0:e.Aborts})]},null==e?void 0:e.drop_name))})]})})}),(0,i.jsx)(n.Z,{xs:0,md:2}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Example"})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_4.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"벡터 파괴 및 복사"})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["vector<T>","의 일부 동작은 원소 유형 T의 기능에 따라 달라집니다. 예를 들어, 드롭(drop) 기능이 없는 원소를 포함하는 벡터는 위의 예시에서 v와 같이 암묵적으로 폐기될 수 없으며, 명시적으로 vector::destroy_empty를 사용하여 파괴해야 합니다. vector::destroy_empty는 vec에 원소가 없을 경우에만 실행 시점에서 중단됩니다:"]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_5.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"하지만 드롭(drop) 기능이 있는 원소를 포함하는 벡터를 폐기하려고 할 때 오류가 발생하지는 않습니다."})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_7.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["마찬가지로, 원소 유형이 복사 가능한 경우에만 벡터를 복사할 수 있습니다. 다시 말해, T가 복사 가능한 경우에만 ","vector<T>","가 복사 가능합니다. 그러나 복사 가능한 벡터조차도 암묵적으로 복사되지는 않습니다."]})})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:6,sx:{marginTop:"0px"},children:(0,i.jsx)("img",{src:"/img/5_8.png",style:{width:"100%",borderRadius:"10px",marginTop:"10px"}})}),(0,i.jsx)(n.Z,{xs:0,md:3}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"대용량 벡터의 복사는 비용이 많이 들 수 있으므로 컴파일러는 복사가 명시적으로 이루어지도록 요구하여 어디에서 복사가 발생하는지 쉽게 파악할 수 있도록 합니다. 자세한 내용은 유형 능력(type abilities)과 제네릭(generics) 섹션을 참조하십시오."})})}),(0,i.jsx)(n.Z,{xs:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["소유권"," "]})})}),(0,i.jsx)(n.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"left"},children:(0,i.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위에서 언급한 대로, 원소가 복사 가능한 경우에만 벡터 값들을 복사할 수 있습니다. 이 경우에는 복사가 명시적으로 이루어져야 하며, 복사 또는 역참조 *를 통해 이루어집니다."})})})]})},D=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"서명자"})})})})},k=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"참조"})})})})},C=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"튜플 및 단위"})})})})},F=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"지역변수 및 범위"})})})})},R=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"평등"})})})})},z=e=>{let{children:s}=e;return(0,i.jsx)(n.Z,{container:!0,children:(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsx)(l.Z,{sx:{width:"100%"},children:(0,i.jsx)(d.Z,{variant:"h2",gutterBottom:!0,children:"중단 및 어셜션"})})})})};function E(){let[e,s]=(0,t.useState)(!1),[r,c]=(0,t.useState)(0);function p(e){let{children:s,value:r,index:t,...n}=e;return(0,i.jsx)("div",{style:{textAlign:"center",width:"80%"},role:"tabpanel",hidden:r!==t,id:"vertical-tabpanel-".concat(t),"aria-labelledby":"vertical-tab-".concat(t),...n,children:r===t&&(0,i.jsx)(l.Z,{sx:{p:10,color:"white"},children:(0,i.jsx)(d.Z,{children:s})})})}function j(e){return{id:"vertical-tab-".concat(e),"aria-controls":"vertical-tabpanel-".concat(e)}}return(0,t.useEffect)(()=>{s(!0)},[]),p.propTypes={children:h().node,index:h().number.isRequired,value:h().number.isRequired},e&&(0,i.jsxs)(n.Z,{container:!0,sx:{marginTop:"84px"},children:[(0,i.jsxs)(n.Z,{xs:12,sx:{backgroundColor:" #171B1C",textAlign:"center",fontSize:"300%",color:"white"},children:[" ",(0,i.jsx)("img",{src:"/img/move.webp",style:{width:"50px"}}),(0,i.jsx)("div",{children:"MOVE BOOK"})]}),(0,i.jsx)(n.Z,{xs:12,children:(0,i.jsxs)(l.Z,{sx:{flexGrow:1,bgcolor:" #171B1C",display:"flex",minHeight:"600px",textAlign:"center"},children:[(0,i.jsxs)(o.Z,{orientation:"vertical",variant:"scrollable",value:r,onChange:(e,s)=>{c(s)},"aria-label":"Vertical tabs example",sx:{borderRight:1,borderColor:" #171B1C",width:"16%",color:"white"},children:[(0,i.jsx)(x.Z,{sx:{color:"white"},label:"0️⃣ 소개 및 설치",...j(0)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣ 모듈 및 스크립트",...j(1)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣ 정수",...j(2)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"3️⃣ 부울",...j(3)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"4️⃣ 주소",...j(4)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"5️⃣ 벡터",...j(5)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"6️⃣ 서명자",...j(6)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"7️⃣ 참조",...j(7)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"8️⃣ 튜플 및 단위",...j(8)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"9️⃣ 지역 변수 및 범위",...j(9)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"\uD83D\uDD1F 평등",...j(10)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣1️⃣ 중단 및 어성셜",...j(11)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣2️⃣ 조건부",...j(12)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣3️⃣ 반복문",...j(13)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣4️⃣ 기능",...j(14)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣5️⃣ 구조체 리소스",...j(15)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣6️⃣ 상수",...j(16)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣7️⃣ 제네릭",...j(17)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣8️⃣ 능력",...j(18)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"1️⃣9️⃣ 용도 및 별칭",...j(19)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣0️⃣ 친구",...j(20)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣1️⃣ 패키지",...j(21)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣2️⃣ 패키지 업그레이드",...j(22)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣3️⃣ 단위 및 테스트",...j(23)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣4️⃣ 글로벌 스토리지 구조",...j(24)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣5️⃣ 글로벌 스토리지 사업자",...j(25)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣6️⃣ 도서관",...j(26)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"2️⃣7️⃣ 코딩 규칙 이동",...j(27)}),(0,i.jsx)(x.Z,{sx:{color:"white"},label:"\uD83E\uDD28 tutorial",...j(28)})]}),(0,i.jsx)(p,{value:r,index:0,children:(0,i.jsx)(a,{})}),(0,i.jsx)(p,{value:r,index:1,children:(0,i.jsx)(m,{})}),(0,i.jsx)(p,{value:r,index:2,children:(0,i.jsx)(_,{})}),(0,i.jsx)(p,{value:r,index:3,children:(0,i.jsx)(f,{})}),(0,i.jsx)(p,{value:r,index:4,children:(0,i.jsx)(A,{})}),(0,i.jsx)(p,{value:r,index:5,children:(0,i.jsx)(M,{})}),(0,i.jsx)(p,{value:r,index:6,children:(0,i.jsx)(D,{})}),(0,i.jsx)(p,{value:r,index:7,children:(0,i.jsx)(k,{})}),(0,i.jsx)(p,{value:r,index:8,children:(0,i.jsx)(C,{})}),(0,i.jsx)(p,{value:r,index:9,children:(0,i.jsx)(F,{})}),(0,i.jsx)(p,{value:r,index:10,children:(0,i.jsx)(R,{})}),(0,i.jsx)(p,{value:r,index:11,children:(0,i.jsx)(z,{})}),(0,i.jsx)(p,{value:r,index:12,children:"5"}),(0,i.jsx)(p,{value:r,index:13,children:"5"}),(0,i.jsx)(p,{value:r,index:14,children:"5"}),(0,i.jsx)(p,{value:r,index:15,children:"5"}),(0,i.jsx)(p,{value:r,index:16,children:"16장"}),(0,i.jsx)(p,{value:r,index:17,children:"16장"}),(0,i.jsx)(p,{value:r,index:18,children:"16장"}),(0,i.jsx)(p,{value:r,index:19,children:"16장"}),(0,i.jsx)(p,{value:r,index:20,children:"16장"}),(0,i.jsx)(p,{value:r,index:21,children:"16장"}),(0,i.jsx)(p,{value:r,index:22,children:"16장"}),(0,i.jsx)(p,{value:r,index:23,children:"16장"}),(0,i.jsx)(p,{value:r,index:24,children:"16장"}),(0,i.jsx)(p,{value:r,index:25,children:"16장"}),(0,i.jsx)(p,{value:r,index:26,children:"16장"}),(0,i.jsx)(p,{value:r,index:27,children:"마지막"}),(0,i.jsx)(p,{value:r,index:28,children:"튜토리얼"})]})})]})}}},function(e){e.O(0,[7366,9774,2888,179],function(){return e(e.s=5557)}),_N_E=e.O()}]);