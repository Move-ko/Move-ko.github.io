(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{48312:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return n(19098)}])},19098:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return et}});var r=n(85893),s=n(67294),o=n(79713),i=n(39998),x=n(40044),l=n(87357),d=n(15861),a=n(45697),c=n.n(a),h=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"\uD83E\uDDD0What is Move?"})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Diem 블록체인의 구현을 위해 Rust언어에서 힌트를 받아 만들어졌으며,현재는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"Aptos"}),"및",(0,r.jsx)("span",{style:{color:"purple"},children:"Sui"}),"에서 사용하고 있습니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move를 사용하면 개발자가 자산을 유연하게 관리하고 전송하는 프로그램을 작성하는 동시에 해당 자산에 대한 공격에 방어(보안 및 보호)를 제공할수 있습니다."})]})}),(0,r.jsx)(o.Z,{xs:0,md:4}),(0,r.jsx)(o.Z,{xs:12,md:4,children:(0,r.jsx)("img",{src:"/img/move.webp",style:{width:"100%",borderRadius:"10px",marginTop:"30px"}})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"특징"})})}),(0,r.jsx)(o.Z,{xs:0,md:4}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 자산 보안: Move 언어는 자산의 보안성을 강조합니다. 타입 시스템을 사용하여 자산의 일관성과 불변성을 보장하며, 잠재적인 버그와 취약점을 예방하는데 도움이 됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"2.자산의 흐름 제어: Move 언어는 자산의 흐름을 제어하는 것을 강조합니다. 자산의 이동 및 전송에 대한 규칙과 제약을 명확하게 정의하여 보안과 논리적 일관성을 유지합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈화: Move 언어는 모듈화를 지원하여 스마트 컨트랙트의 재사용성과 확장성을 향상시킵니다. 모듈은 독립적으로 작동하며 다른 모듈과 상호작용할 수 있습니다."})]})})]}),m=n(74855),u=n(34209),p=n(84283),j=n(90066);function g(e){let{code:t}=e,[n,o]=(0,s.useState)(!1),[i,x]=(0,s.useState)(!1),[l,d]=(0,s.useState)(!1);return(0,r.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{x(!0)},onMouseLeave:()=>{x(!1)},children:[(0,r.jsx)(u.Z,{language:"javascript",style:p.cL,children:t}),(0,r.jsx)(m.CopyToClipboard,{text:t,children:(0,r.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),o(!0),d(!0),setTimeout(()=>{o(!1),d(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:i?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:l?(0,r.jsx)(j.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,r.jsx)(j.Z,{style:{color:n?"#fff":"#000",transition:"color 0.3s"}})})})]})}var Z=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"모듈과 스크립트"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move는 두 가지 종류의 모듈(Module)과 스크립트(Script)를 제공하고 있습니다. 모듈은 구조체 타입과 이러한 타입에 작용하는 함수를 정의하는 라이브러리입니다. 구조체 타입은 Move의 전역 스토리지의 스키마를 정의하며, 모듈 함수는 스토리지를 업데이트하는 규칙을 정의합니다. 모듈 자체도 전역 스토리지에 저장됩니다. 스크립트는 전통적인 언어에서의 main 함수와 유사한 실행 가능한 진입점입니다. 스크립트는 일반적으로 전역 스토리지에 대한 업데이트를 수행하는 게시된 모듈의 함수를 호출합니다. 스크립트는 전역 스토리지에 게시되지 않는 일시적인 코드 조각입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 소스 파일(또는 컴파일 단위)에는 여러 개의 모듈과 스크립트를 포함할 수 있습니다. 그러나 모듈을 게시하거나 스크립트를 실행하는 것은 별개의 VM(가상 머신) 작업입니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"스크립트"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"40px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"스크립트 블록은 모든 사용 선언부로 시작해야 하며, 상수를 그 다음에 위치시킨 뒤 (마지막으로) 메인 함수 선언을 해야 합니다. 메인 함수는 어떤 이름으로든 사용할 수 있으며(main으로 명명할 필요는 없음), 스크립트 블록 내에서 유일한 함수여야 합니다. 인수의 개수에는 제한이 없으며, 값을 반환해서는 안 됩니다. 다음은 각각의 구성 요소를 포함한 예시입니다:"})}),(0,r.jsx)(g,{code:"  script {\n    // std라는 이름을 가진 계정 주소에서 게시된 디버그 모듈을 가져옵니다.\n    use std::debug;//<use>\n\n    const ONE: u64 = 1; //<constants>:상수\n\n    fun main(x: u64) {  //fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>\n        let sum = x + ONE;\n        debug::print(&sum)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"40px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"스크립트는 제한된 권한을 갖고 있으며, 친구(friends)를 선언하거나 구조체(struct types)를 정의하거나 전역 저장소에 접근할 수 없습니다. 스크립트의 주요 목적은 모듈 함수를 호출하는 것입니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"40px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"모듈"})}),(0,r.jsx)("span",{style:{color:"purple"},children:"*모듈 구조"}),(0,r.jsxs)(l.Z,{sx:{width:"100%"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsxs)("span",{style:{color:"purple"},children:["*address:명명된 주소(",(0,r.jsx)("span",{style:{color:"purple"},children:"이름이 붙여진 주소"}),") 또는 리터럴 주소"]})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsxs)("span",{style:{color:"purple"},children:["*const:모듈의 함수에서 사용할수있는 전용",(0,r.jsx)("span",{style:{color:"purple"},children:"상수"}),"를 지정"]})})]}),(0,r.jsx)(g,{code:"  module 0x42::example {  //<address>::<identifier>\n                                       //<use> | <friend> | <type> | <function> | <constant>\n    struct Example has copy, drop {\n       i: u64 \n       }\n\n    use std::debug;\n\n    friend 0x42::another_example;\n       \n    const ONE: u64 = 1;\n       \n    public fun print(x: u64) {\n               let sum = x + ONE;\n               let example = Example { i: sum };\n               debug::print(&sum)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"0x42::example 모듈 부분은 example 모듈이 글로벌 저장소의 0x42 주소에 있는 계정 아래에 게시될 것임을 지정합니다. 모듈은 명명된 주소(named addresses)를 사용하여 선언할 수도 있습니다. 예를 들어:"})}),(0,r.jsx)(g,{code:"  module example_addr::example {}//0x42대신 example_addr로 대체\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"명명된 주소는 소스 언어 수준에서만 존재하며, 컴파일 중에만 사용되므로, 바이트코드 수준에서 명명된 주소는 해당 값으로 완전히 대체됩니다. 예를 들어, 다음과 같은 코드가 있다고 가정해 봅시다:"})}),(0,r.jsx)(g,{code:"  script {\n    fun example() {\n        my_addr::m::foo(@my_addr);\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"40px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그리고 my_addr을 0xC0FFEE로 설정하여 컴파일한다면, 실제로 다음과 같이 동작합니다:"})}),(0,r.jsx)(g,{code:"  script {\n    fun example() {\n        0xC0FFEE::m::foo(@0xC0FFEE);\n    }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"하지만 소스 수준에서는 이러한 코드는 동등하지 않습니다. 함수 m::foo는 my_addr이라는 명명된 주소를 통해 접근되어야 하며, 해당 주소에 할당된 숫자 값으로는 접근할 수 없습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 이름은 영문자 a에서 z 또는 A에서 Z로 시작할 수 있습니다. 첫 번째 문자 이후에는 밑줄(_), 영문자 a에서 z, 영문자 A에서 Z 또는 숫자 0에서 9가 포함될 수 있습니다."})]}),(0,r.jsx)(g,{code:"  module my_module {}\n  module foo_bar_42 {}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 모듈 이름은 소문자로 시작합니다. my_module이라는 모듈은 my_module.move라는 소스 파일에 저장되어야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 블록 내의 모든 요소는 어떤 순서로든 나타날 수 있습니다. 기본적으로 모듈은 타입과 함수의 집합입니다. use 키워드는 다른 모듈에서 타입을 가져오는 데 사용됩니다. friend 키워드는 신뢰할 수 있는 모듈의 목록을 지정합니다. const 키워드는 모듈의 함수에서 사용할 수 있는 비공개 상수를 정의합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83E\uDD28모듈 특징정리"})})]}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"1. 모듈 요소(사용, 상수, 함수 등)는 특정 순서로 구성되어야 합니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.모듈은 ",(0,r.jsx)("span",{style:{color:"purple"},children:"전역저장소에"}),"저장됩니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.모듈은 main이라는 함수를 포함해야 합니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["4. ",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 모듈에서 유효합니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.모듈의 어떤 함수도 반환 값을 가질 수 없습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.모듈에는 하나의 함수만 선언할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.친구 모듈은 모듈 내에서 유효합니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["8.모듈은 ",(0,r.jsx)("span",{style:{color:"purple"},children:"주소"}),"와",(0,r.jsx)("span",{style:{color:"purple"},children:"식별자"}),"로 선언해야 합니다."]})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"40px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"\uD83D\uDC69‍\uD83C\uDF93스크립트 특징정리"})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"40px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["1.스크립트는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"전역저장소"}),"에 저장되지 않습니다."]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["2.스크립트 요소(사용, 상수, 함수 등)는",(0,r.jsx)("span",{style:{color:"purple"},children:"특정순서"}),"로 구성되어야 합니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"3.스크립트 블록에는 하나의 함수만 선언할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"4. 스크립트 함수는 임의의 이름을 가질 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"5.상수는 스크립트에서 유효합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"6.스크립트에는 하나의 함수만 선언할 수 있으며 이름은 main으로 지정해야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"7.스크립트에 선언된 함수는 얼마든지 있을 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"8.friend 모듈은 스크립트에서 선언할 수 있습니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["9.스크립트에서 선언된 함수는",(0,r.jsx)("span",{style:{color:"purple"},children:"매개변수"}),"를 가질 수 없습니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"10. 스크립트에서 선언된 함수는 반환 값을 가질 수 없습니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["11. ",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체"}),"는 스크립트에서 유효합니다."]})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,children:"ex)예시"}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  // Example Module\n  module overmind::bananas {\n  \n      use std::vector;\n      use std::signer;\n  \n      struct BananaStore has key {\n          bushels: vector<Bushel>\n      }\n  \n      struct Bushel has store, drop {\n          bananas: vector<Banana>\n      }\n  \n      struct Banana has store, drop {}\n  \n      public entry fun buy_banana(buyer: &signer) acquires BananaStore {\n          let buyer_address = signer::address_of(buyer);\n  \n          if (!exists<BananaStore>(buyer_address)) {\n              move_to(\n                  buyer,\n                  BananaStore {\n                      bushels: vector<Bushel>[]\n                  }\n              );\n          };\n  \n          let bananaStore = borrow_global_mut<BananaStore>(buyer_address);\n  \n          let bushels_mut_ref = &mut bananaStore.bushels;\n  \n          let bushel_new = Bushel {\n              bananas: vector<Banana>[\n                  Banana {},\n                  Banana {},\n                  Banana {},\n                  Banana {}\n              ]\n          };\n  \n          vector::push_back<Bushel>(bushels_mut_ref, bushel_new);\n      }\n  \n      public entry fun eat_banana(account: &signer) acquires BananaStore {\n          let account_address = signer::address_of(account);\n  \n          let bananaStore = borrow_global_mut<BananaStore>(account_address);\n          let bushels_mut_ref = &mut bananaStore.bushels;\n          let first_bushel = vector::remove<Bushel>(bushels_mut_ref, 0);\n  \n          let _ = vector::pop_back<Banana>(&mut first_bushel.bananas);\n  \n          if (vector::length<Banana>(&mut first_bushel.bananas) != 0) {\n              vector::insert<Bushel>(bushels_mut_ref, 0, first_bushel);\n          }\n      }\n  }\n  \n\n"})})]}),v=n(7906),f=n(295),b=n(98102),y=n(89755),T=n(72882),_=n(53184),w=n(53816),B=n(90629),A=n(90948),C=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"정수"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 언어는 여섯 가지의 부호 없는 정수 타입을 지원합니다: u8, u16, u32, u64, u128, 그리고 u256입니다. 이러한 타입의 값은 0부터 해당 타입의 크기에 따라 다른 최댓값까지 범위를 갖습니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"유형"}),(0,r.jsx)(e,{children:"값 범위"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{type:"부호 없는 8비트 정수,u8",range:"0 ~ 2^8 - 1"},{type:"부호 없는 16비트 정수,u16",range:"0 ~ 2^16 - 1"},{type:"부호 없는 32비트 정수,u32",range:"0 ~ 2^32 - 1"},{type:"부호 없는 64비트 정수,u64",range:"0 ~ 2^64 - 1"},{type:"부호 없는 128비트 정수,u128",range:"0 ~ 2^128 - 1"},{type:"부호 없는 256비트 정수,u256",range:"0 ~ 2^256 - 1"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.type}),(0,r.jsx)(e,{children:null==n?void 0:n.range})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"20px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 타입에 대한 리터럴 값은 숫자의 연속으로 지정될 수 있습니다 (예: 112) 또는 16진수 리터럴로 지정될 수 있습니다 (예: 0xFF). 리터럴의 타입은 선택적으로 접미사로 추가될 수 있습니다. 예를 들어, 112u8와 같이 타입을 명시적으로 추가할 수 있습니다. 타입이 명시되지 않은 경우, 컴파일러는 리터럴이 사용된 문맥에서 타입을 추론하려고 시도합니다. 타입을 추론할 수 없는 경우, 기본적으로 u64로 가정됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"숫자 리터럴은 그룹화와 가독성을 위해 밑줄로 구분할 수 있습니다. (예: 1_234_5678, 1_000u128, 0xAB_CD_12_35)."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 리터럴이 지정된 (또는 추론된) 크기 범위보다 크다면, 오류가 발생합니다."})]})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"      module example::test {\n            fun main(){\n            //  명시적 주석이 있는 리터럴;\n            let explicit_u8 = 1u8;\n            let explicit_u16 = 1u16;\n            let explicit_u32 = 1u32;\n            let explicit_u64 = 2u64;\n            let explicit_u128 = 3u128;\n            let explicit_u256 = 1u256;\n            let explicit_u64_underscored = 154_322_973u64;\n            \n            // 간단한 추론을 통한 리터럴\n            let simple_u8: u8 = 1;\n            let simple_u16: u16 = 1;\n            let simple_u32: u32 = 1;\n            let simple_u64: u64 = 2;\n            let simple_u128: u128 = 3;\n            let simple_u256: u256 = 1;\n            \n            //보다 복잡한 추론을 통한 리터럴\n            let complex_u8 = 1; // 추론된: u8\n            //shift의 오른쪽 피연산자는 u8이어야 합니다.\n            let _unused = 10 << complex_u8;\n            \n            let x: u8 = 38;\n            let complex_u8 = 2; //// 추론된: u8\n            //인수는 동일한 타입을 가져야합니다.\n            let _unused = x + complex_u8;\n            \n            let complex_u128 = 133_876; // 추론된: u128\n            //함수 인수의 타입으로부터 추론됨\n            function_that_takes_u128(complex_u128);\n            \n            //16진수로 리터럴을 작성할 수 있습니다.\n            let hex_u8: u8 = 0x1;\n            let hex_u16: u16 = 0x1BAE;\n            let hex_u32: u32 = 0xDEAD80;\n            let hex_u64: u64 = 0xCAFE;\n            let hex_u128: u128 = 0xDEADBEEF;\n            let hex_u256: u256 = 0x1123_456A_BCDE_F;\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"산술"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"각각의 정수 타입은 동일한 집합의 검사된 산술 연산을 지원합니다. 이러한 모든 연산에서는 인자(왼쪽 및 오른쪽 피연산자) 모두 동일한 타입이어야 합니다. 다른 타입의 값에 대해 작업해야 하는 경우, 먼저 캐스트를 수행해야 합니다. 마찬가지로, 연산 결과가 정수 타입으로는 너무 커질 것으로 예상되는 경우, 연산을 수행하기 전에 더 큰 크기로 캐스트를 수행해야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"수학적인 정수의 동작과는 다른 방식으로 동작하는 대신, 모든 산술 연산은 오류가 발생합니다(예: 오버플로우, 언더플로우, 0으로 나누기)."})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"}),(0,r.jsx)(e,{children:"중단"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"+",작업:"덧셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"-",작업:"뺴기",중단:"결과가 0보다 작음"},{통사론:"*",작업:"곱셈",중단:"결과가 정수 유형에 비해 너무 큽니다"},{통사론:"%",작업:"모듈식 분할",중단:"제수는 0"},{통사론:"/",작업:"잘림 나누기",중단:"제수는 0"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업}),(0,r.jsx)(e,{children:null==n?void 0:n.중단})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트연산"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,sx:{textAlign:"left"},children:"정수 타입은 각 숫자를 0 또는 1로 구성된 개별 비트의 시퀀스로 취급하는 다음과 같은 비트 연산을 지원합니다."}),(0,r.jsx)(d.Z,{children:(0,r.jsx)("span",{style:{color:"purple"},children:"* 비트 연산은 중단되지 않습니다."})})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"&",작업:"비트 및",설명:"부울을 수행하고 각 비트에 대해 쌍으로"},{통사론:"|",작업:"비트 또는",설명:"부울 또는 각 비트에 대해 쌍으로 수행"},{통사론:"^",작업:"비트 xor",설명:"부을 독점 또는 각 비트에 대해 쌍으로 수행"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비트시프트"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"비트 연산과 유사하게, 각 정수 타입은 비트 시프트를 지원합니다. 그러나 다른 연산과 달리, 우측 피연산자(시프트할 비트 수)는 항상 u8이어야 하며, 좌측 피연산자(시프트하는 숫자)와 일치할 필요는 없습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"비트 시프트는 u8, u16, u32, u64, u128 및 u256의 경우 시프트할 비트 수가 각각 8, 16, 32, 64, 128 또는 256보다 크거나 같은 경우 중단될 수 있습니다."})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"}),(0,r.jsx)(e,{children:"중단"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"<<",작업:"왼쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"},{통사론:">>",작업:"오른쪽으로 이동",중단:"이동할 비트 수가 정수 유형의 크기보다 큽니다"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업}),(0,r.jsx)(e,{children:null==n?void 0:n.중단})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"비교 연산자"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"정수 타입은 Move에서 비교 연산자를 사용할 수 있는 유일한 타입입니다. 두 인자는 동일한 타입이어야 합니다. 서로 다른 타입의 정수를 비교해야 하는 경우, 먼저 하나를 캐스트해야 합니다. 비교 연산은 중단되지 않습니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"<",작업:"보다 작은"},{통사론:">",작업:"보다큰"},{통사론:"<=",작업:"작거나 같음"},{통사론:">=",작업:"크거나 같음"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"평등"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'Move에서 드롭(drop)을 가지는 모든 타입과 마찬가지로, 모든 정수 타입은 "동일" 및 "동일하지 않음" 연산을 지원합니다. 두 인자는 동일한 타입이어야 합니다. 서로 다른 타입의 정수를 비교해야 하는 경우, 먼저 하나를 캐스트해야 합니다. 등호 연산은 중단되지 않습니다.'})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"==",작업:"같은"},{통사론:"!=",작업:"같지않은"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형변환"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서는 한 크기의 정수 유형을 다른 크기의 정수 유형으로",(0,r.jsx)("span",{style:{color:"purple"},children:"형변환"})," 할 수 있습니다. 정수는 Move에서 형변환를 지원하는 유일한 유형입니다. 정수를 크기가 다른 유형으로 형변환 할 때, Move에서는",(0,r.jsx)("span",{style:{color:"purple"},children:"형변환이 값을 절단하지 않는다는 점"}),"에 유의해야 합니다. 이는 형변환 연산이 원래 정수의 전체 값을 보존한다는 것을 의미합니다. 즉, 목표 정수 유형의 범위를 초과하는 경우에도 원래 정수의 전체 값이 유지됩니다. 그러나, 형변환의 결과가 지정된 유형에 너무 큰 경우 형변환이 중단될 수 있다는 점을 알려드립니다. 이는형변환 결과가 지정된 유형에 맞지 않을 때 형변환이 중단되는 것을 의미합니다."]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"작업"}),(0,r.jsx)(e,{children:"다음과 같은 경우 중단"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"(e as T)",작업:"e 정수 표현식을 정수 유형으로형변환T",설명:"e로 표현하기에는 너무 큽니다"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px",textAlign:"left"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 언어에 내장된 정수 값들도 암묵적으로 복사 가능한 속성을 갖고 있습니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"이는 복사와 같은 명시적 명령 없이도 복사될 수 있다는 것을 의미"}),"합니다. 정수 값을 새 변수에 할당하거나 함수 인자로 전달할 때, 해당 값의 복사본이 생성됩니다. 원본 값과 복사본은 서로 독립적으로 사용될 수 있으며, 한 쪽 복사본을 수정해도 다른 쪽에는 영향을 미치지 않습니다. 이러한 복사 연산은 내부적으로 암묵적으로 처리됩니다. 예를 들어:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"      module example::test {\n    fun main(){\n  let x: u8 = 10;\n  let y = x; // x의 값을 y에 복사합니다.\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{children:["이 경우,",(0,r.jsx)("span",{style:{color:"purple"},children:"x의 값이 y로 복사되며, x와 y는 각각 정수 값의 독립적인 복사본을 가지고 있습니다."}),"y를 수정해도 x의 값에는 영향을 주지 않으며, 그 반대도 마찬가지입니다. 이러한 암묵적인 복사 동작은 명시적인 복사 명령 없이도 정수 값을 간편하게 처리할 수 있도록 해줍니다. 그러나 보다 복잡한 유형과 리소스의 경우, Move에서는 소유권과 빌림에 대한 명시적인 지침이나 고려 사항이 필요할 수 있습니다."]})})]})},M=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:t.palette.common.black,color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:10}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.action.hover},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"부울"})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"부울"}),"은 Move에서 boolean",(0,r.jsx)("span",{style:{color:"purple"},children:"true"}),"와",(0,r.jsx)("span",{style:{color:"purple"},children:"false"})," 값을 표현하기 위한 원시 타입입니다.또한 bool 타입의 리터럴은 true 또는 false로 표현됩니다."]})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"* bool은 세가지 논리 연산을 지원합니다."})}),(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"설명"}),(0,r.jsx)(e,{children:"등가표현"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"&&",설명:"단락 논리 및",등가표현:"p && q에 해당합니다 if(p)q else false"},{통사론:"||",설명:"단락 논리 또는",등가표현:"p || q 에 해당합니다 if(p) true else q"},{통사론:"!",설명:"논리적 부정",등가표현:"!p에 해당합니다 if(q) false else true"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.설명}),(0,r.jsx)(e,{children:null==n?void 0:n.등가표현})]}))})]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"bool 값은 Move의 여러 제어 흐름 구조에서 사용됩니다:"})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"* if문"})}),(0,r.jsx)(g,{code:"      \n  if bool_표현식 {\n // bool_표현식이 true일 경우 실행되는 코드 블록\n } else {\n  // bool_표현식이 false일 경우 실행되는 코드 블록\n }\n\n"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"* while문"})}),(0,r.jsx)(g,{code:"      while bool_표현식 {\n    // bool_표현식이 true인 동안 반복적으로 실행되는 코드 블록\n  }\n"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"3) assert:이 연산은 두 개의 인자를 받습니다: bool 타입의 조건과 u64 타입의 코드"})}),(0,r.jsx)(g,{code:"     assert!(bool_표현식, 오류_메시지); "}),(0,r.jsxs)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"정리"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다른 스칼라 값들과 마찬가지로, 언어 내장의 boolean 값들은 암시적으로 복사 가능합니다. 즉, copy와 같은 명시적인 지시어 없이도 복사할 수 있습니다."})]}),(0,r.jsx)(g,{code:"module example::test {\n    fun example(){\n          let a = true  //true\n          let b = false //false\n          let c = true && false //false\n          let d = false || true //true\n          let e = true || false && true //true\n          let f = !true //false\n          let g = !false  //true\n          let h = !true || true //true\n          let i = false || true && false //false  \n    }\n}\n"})]})})},k=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"주소"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"주소(Address)"})," 는 Move 언어에서 글로벌 스토리지의 위치(가끔은 계정이라고도 함)를 나타내기 위해 사용되는 내장된 유형입니다. 주소 값은",(0,r.jsx)("span",{style:{color:"purple"},children:"128비트(16바이트)"}),"식별자입니다. 특정 주소에는",(0,r.jsx)("span",{style:{color:"purple"},children:"모듈(Module)"}),"과",(0,r.jsx)("span",{style:{color:"purple"},children:"리소스(Resource)"}),"두 가지 요소를 저장할 수 있습니다."]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["실제로 주소는 128비트 정수로 구성되지만, Move 주소는 의도적으로 불투명한 형태로 구성되어 있습니다. 즉, 정수로부터 주소를 생성할 수 없으며, 산술 연산을 지원하지 않으며, 수정할 수 없습니다. 포인터 산술과 유사한 용도로 사용될 수 있는 흥미로운 프로그램이 있을 수 있지만 (예: C의 포인터 산술), Move는 정적 검증을 지원하기 위해 처음부터",(0,r.jsx)("span",{style:{color:"purple"},children:"이러한 동적 동작을 허용하지 않습니다."})]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["런타임 주소 값(",(0,r.jsx)("span",{style:{color:"purple"},children:"주소 유형의 값"}),")을 사용하여 해당 주소에 있는 리소스에 접근할 수 있습니다. 주소 값을 통해 런타임에서 모듈에 액세스할 수는 없습니다."]})]})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"문법"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"명명된(named) 주소"}),"와",(0,r.jsx)("span",{style:{color:"purple"},children:"숫자형(numerical) 주소"})," 로 두 가지 형태로 나뉩니다. 명명된 주소의 구문은 Move에서 일반적으로 사용되는 명명된 식별자의 규칙을 따릅니다. 숫자형 주소의 구문은 16진수로 인코딩된 값에 제한되지 않으며, 유효한 u128 숫자 값으로 주소 값으로 사용할 수 있습니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:"42, 0xCAFE, 2021"})," 은 모두 유효한 숫자형 주소 리터럴입니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"주소가 식(expression) 컨텍스트에서 사용되는지 여부를 구분하기 위해 주소를 사용하는 구문은 사용되는 컨텍스트에 따라 다릅니다:"}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소가 식으로 사용될 때는 주소 앞에 @ 문자가 붙어야 합니다. 즉,",(0,r.jsxs)("span",{style:{color:"purple"},children:[" ","@<numerical_value>"]}),"또는",(0,r.jsx)("span",{style:{color:"purple"},children:"@<named_address_identifier>"}),"형태여야 합니다. 식 컨텍스트 이외의 곳에서는 주소를 @ 문자 없이 쓸 수 있습니다. 즉,",(0,r.jsx)("span",{style:{color:"purple"},children:" <numerical_value>"})," 또는",(0,r.jsx)("span",{style:{color:"purple"},children:"<named_address_identifier>"}),"형태로 쓸 수 있습니다. 일반적으로 @는 주소를 네임스페이스 항목에서 식 항목으로 전환하는 연산자로 생각할 수 있습니다."]})]})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"명명된 주소"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test{\n    fun example(){\n        let a1: address = @0x1; // 0x00000000000000000000000000000001의 약식표현\n        let a2: address = @0x42; //0x00000000000000000000000000000042의 약식표현\n        let a3: address = @0xDEADBEEF; // 0x000000000000000000000000DEADBEEF 의 약식표현\n        let a4: address = @0x0000000000000000000000000000000A;//0xA\n        let a5: address = @std; //std라는 이름의 주소에 있는 값을 a5에 할당합니다.\n        let a6: address = @66;\n        let a7: address = @0x42;\n\nmodule 66::some_module {   //표현식 컨텍스트가 아니기 때문에 @ 기호가 필요하지 않습니다.\n    use 0x1::other_module; //표현식 컨텍스트가 아니기 때문에 @ 기호가 필요하지 않습니다.\n    use std::vector;       //다른 모듈을 사용할 때, 네임드 어드레스를 네임스페이스 항목으로 사용할 수 있습니다.\n    ...\n}\n\nmodule std::other_module {  //네임드 어드레스를 네임스페이스 항목으로 사용하여 모듈을 선언할 수 있습니다.\n    ...\n}\n\n\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["명명된 주소(named addresses)는 주소가 사용되는 모든 위치에서 숫자 값 대신 식별자를 사용할 수 있도록 하는 기능입니다. 명명된 주소는 Move 패키지의 최상위 요소(모듈 및 스크립트 외부)로 선언되고 바인딩됩니다. 또한 Move 컴파일러에 인수로 전달될 수도 있습니다. 명명된 주소는 값 수준뿐만 아니라 주소가 사용되는",(0,r.jsx)("span",{style:{color:"purple"},children:"모든 위치"}),"에서 사용될 수 있으며, 소스 언어 수준에서만 존재하며 바이트코드 수준에서는 완전히 해당 값을 ",(0,r.jsx)("span",{style:{color:"purple"},children:"대체"}),"합니다. 따라서 모듈과 모듈 멤버는 모듈의 명명된 주소를 통해 접근해야 하며, 명명된 주소에 할당된 숫자 값으로 모듈 및 모듈 멤버에 접근해서는 안 됩니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:"my_addr이 0x2로 설정된 상태"}),"에서 Move 프로그램이 컴파일되더라도",(0,r.jsx)("span",{style:{color:"purple"},children:"use my_addr::foo는 use 0x2::foo와 동일하지 않습니다"}),". 이 차이점은 모듈과 스크립트 섹션에서 자세히 논의됩니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"글로벌 스토리지 운영"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["주소 값의 주요 목적은 글로벌 스토리지 작업과 상호 작용하는 데에 있습니다. 주소 값은",(0,r.jsx)("span",{style:{color:"purple"},children:"exists, borrow_global, borrow_global_mut, move_from"}),"등의 작업과 함께 사용됩니다. 주소를 사용하지 않는 유일한 글로벌 스토리지 작업은 ",(0,r.jsx)("span",{style:{color:"purple"},children:"move_to"}),"입니다. move_to 작업은",(0,r.jsx)("span",{style:{color:"purple"},children:"signer"})," 를 사용합니다."]})})}),(0,r.jsxs)(o.Z,{xs:12,sx:{marginTop:"10px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"*exists: 주소 아래에 T가 저장되어 있으면 true를 반환"})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"*borrow_global:address 아래에 저장된 T에 대한 불변 참조를 반환합"})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"* borrow_global_mut:address 아래에 저장된 T에 대한 변경 가능한 참조를 반환"})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"*move_from:T 주소에서 T를 제거하고 반환"})}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)("span",{style:{color:"purple"},children:"* move_to:signer.address 아래에 T를 게시"})})]}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:['언어에 내장된 다른 스칼라 값과 마찬가지로 주소 값도 암시적으로 복사 가능(copyable)합니다. 이는 "copy"와 같은',(0,r.jsx)("span",{style:{color:"purple"},children:"명시적인 명령 없이도 주소 값이 복사될 수 있다는 것을 의미"}),"합니다. 주소 값을 새 변수에 할당하거나 함수에 인수로 전달할 때, 주소 값의 복사본이 생성되며 원본과 복사본 주소 모두 독립적으로 사용할 수 있습니다."]})})})]}),F=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"벡터"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서 제공하는 유일한 원시 컬렉션 타입은",(0,r.jsxs)("span",{style:{color:"purple"},children:[" ","vector<T>"]}),"입니다. ","vector<T>","는 T의 동일한 유형의 항목들로 구성된 컬렉션으로, 값들을 끝에",(0,r.jsx)("span",{style:{color:"purple"},children:"push"}),"하거나 ",(0,r.jsx)("span",{style:{color:"purple"},children:"pop"}),"하여 크기를 조절할 수 있습니다.","vector<T>","는 어떤 유형 T로도 인스턴스화할 수 있습니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:"vector<u64>, vector<address>, vector<0x42::MyModule::MyResource> 및 vector<vector<u8>>"}),"은 모두 유효한 vector 타입입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"일반적인 벡터 리터럴"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"벡터 리터럴을 사용하여 어떤 유형의 벡터든 생성할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"vector[]",타입:"vector[]: vector<T> where T is any single, non-reference type",설명:"비어있는 벡터"},{통사론:"vector[e1, ..., en]",타입:"vector[e1, ..., en]: vector<T> where e_i: T s.t. 0 < i <= n and n > 0",설명:" n개의 요소가 있는 벡터(길이 n)"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.타입}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이러한 경우에는 벡터의 유형이 원소 유형이나 벡터의 사용으로부터 추론됩니다. 유형을 추론할 수 없는 경우 또는 명확성을 위해 유형을",(0,r.jsx)("span",{style:{color:"purple"},children:"명시적"})," 으로 지정할 수도 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n\n   vector<T>[]: vector<T>\n   vector<T>[e1, ..., en]: vector<T>\n   \n    }\n\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n\n(vector[]: vector<bool>);\n(vector[0u8, 1u8, 2u8]: vector<u8>);\n(vector<u128>[]: vector<u128>);\n(vector<address>[@0x42, @0x100]: vector<address>);\n\n\n    }\n"})}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["vector","<u8>"," 타입의 리터럴"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에서 벡터를 사용하는 일반적인 사례는",(0,r.jsx)("span",{style:{color:"purple"},children:"바이트 배열"}),"을 나타내는 것인데, 이는",(0,r.jsxs)("span",{style:{color:"purple"},children:[" ","vector<u8>"]}),"로 표현됩니다. 이러한 값들은 종종 공개 키나 해시 결과와 같은 암호화 목적으로 사용됩니다. 이러한 값들은 널리 사용되어 특정 구문이 제공되어 값을 더 가독성 있게 만들어줍니다. 각 개별 u8 값이 숫자 형태로 지정되는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"vector[]"}),"를 사용해야 하는 대신에 특정 구문을 사용할 수 있습니다."]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["현재 지원되는 두 가지 유형의 ","vector<u8>"," 리터럴은",(0,r.jsx)("span",{style:{color:"purple"},children:"바이트 문자열(byte strings)"}),"과",(0,r.jsx)("span",{style:{color:"purple"},children:"16진수 문자열(hex strings)"}),"입니다."]})]})}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h5",gutterBottom:!0,children:"바이트 문자열(Byte Strings)"})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"바이트 문자열"})," 은 b로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:'b"Hello!\\n"'})," 과 같습니다."]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"ASCII"})," 로 인코딩된 문자열로서",(0,r.jsx)("span",{style:{color:"purple"},children:"이스케이프 시퀀스"})," 를 허용합니다. 현재 지원되는 이스케이프 시퀀스는 다음과 같습니다:"]})]})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"이스케이프_시퀀스"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{이스케이프_시퀀스:"\\n",Description:"새 줄(또는 줄바꿈)"},{이스케이프_시퀀스:"\\r",Description:"캐리지 리턴(Carriage return)"},{이스케이프_시퀀스:"\\t",Description:"Tab"},{이스케이프_시퀀스:"\\\\",Description:"Backslash"},{이스케이프_시퀀스:"\\0",Description:"Null"},{이스케이프_시퀀스:'\\"',Description:"Quote"},{이스케이프_시퀀스:"\\xHH",Description:"Hex escape, inserts the hex byte sequence HH"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.이스케이프_시퀀스}),(0,r.jsx)(e,{children:null==n?void 0:n.Description})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h5",gutterBottom:!0,children:"16진수 문자열(Hex Strings)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["16진수 문자열은 x로 접두사가 붙은 따옴표로 둘러싸인 문자열 리터럴입니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:' x"48656C6C6F210A"'}),"와 같습니다. 각각의 바이트 쌍은",(0,r.jsx)("span",{style:{color:"purple"},children:" 00"}),"부터 ",(0,r.jsx)("span",{style:{color:"purple"},children:"FF"}),"까지의 16진수로 인코딩된 ",(0,r.jsx)("span",{style:{color:"purple"},children:"u8"}),"값을 의미합니다. 따라서 각 바이트 쌍은 결과적인 ","vector<u8>","에서 하나의 항목에 해당합니다. 예시 문자열 리터럴"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  script {\n    fun byte_and_hex_strings() {\n        assert!(b"" == x"", 0);\n        assert!(b"Hello!\\n" == x"48656C6C6F210A", 1);\n        assert!(b"\\x48\\x65\\x6C\\x6C\\x6F\\x21\\x0A" == x"48656C6C6F210A", 2);\n        assert!(\n            b"\\"Hello\\tworld!\\"\\n \\r \\Null=\\0" ==\n                x"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00",\n            3\n        );\n    }\n    }\n'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"vector는 아래와 같이 Move 표준 라이브러리의 std::vector 모듈을 통해 여러 작업을 제공합니다. 시간이 지남에 따라 더 많은 작업이 추가될 수 있습니다. 벡터에 대한 최신 문서는 여기에서 찾을 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"Function"}),(0,r.jsx)(e,{children:"Description"}),(0,r.jsx)(e,{children:"Aborts?"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{Function:"vector::empty<T>(): vector<T>	",Description:"T 유형의 값을 저장할 수 있는 빈 벡터를 만듭니다.",Aborts:"절대"},{Function:"vector::is_empty<T>(): bool",Description:"벡터 v에 요소가 없으면 true를 반환하고 그렇지 않으면 false를 반환합니다.",Aborts:"절대"},{Function:"vector::singleton<T>(t: T): vector<T>",Description:"t를 포함하는 크기 1의 벡터를 만듭니다.",Aborts:"절대"},{Function:"vector::length<T>(v: &vector<T>): u64",Description:"벡터 v의 길이를 반환합니다.",Aborts:"절대"},{Function:"vector::push_back<T>(v: &mut vector<T>, t: T)",Description:"v 끝에 t 추가",Aborts:"절대"},{Function:"vector::pop_back<T>(v: &mut vector<T>): T",Description:"v의 마지막 요소를 제거하고 반환",Aborts:"v가 비어 있는 경우"},{Function:"vector::borrow<T>(v: &vector<T>, i: u64): &T",Description:"인덱스 i에서 T에 대한 불변 참조를 반환합니다.",Aborts:"내가 경계 안에 있지 않다면"},{Function:"vector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T",Description:"인덱스 i에서 T에 대한 변경 가능한 참조를 반환합니다.",Aborts:"내가 경계 안에 있지 않다면"},{Function:"vector::destroy_empty<T>(v: vector<T>)",Description:"v 삭제",Aborts:"v가 비어 있지 않은 경우"},{Function:"vector::append<T>(v1: &mut vector<T>, v2: vector<T>)",Description:"v2의 요소를 v1의 끝에 추가",Aborts:"절대"},{Function:"vector::reverse_append<T>(lhs: &mut vector<T>, other: vector<T>)",Description:"다른 벡터에서 발생한 것과 반대 순서로 다른 벡터의 모든 요소를 ​​lhs 벡터로 푸시합니다.",Aborts:"절대"},{Function:"vector::contains<T>(v: &vector<T>, e: &T): bool",Description:"e가 벡터 v에 있으면 참을 반환합니다. 그렇지 않으면 거짓을 반환합니다.",Aborts:"절대"},{Function:"vector::swap<T>(v: &mut vector<T>, i: u64, j: u64)",Description:"벡터 v의 i번째 인덱스와 j번째 인덱스에 있는 요소를 교체합니다.",Aborts:"i 또는 j가 범위를 벗어난 경우"},{Function:"vector::reverse<T>(v: &mut vector<T>)",Description:"제자리에서 벡터 v의 요소 순서를 반대로 바꿉니다.",Aborts:"절대"},{Function:"vector::reverse_slice<T>(v: &mut vector<T>, l: u64, r: u64)",Description:"제자리에서 벡터 v의 요소 [l, r)의 순서를 반대로 바꿉니다.",Aborts:"절대"},{Function:"vector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)",Description:"e가 인덱스 i의 벡터 v에 있으면 (true, i)를 반환합니다. 그렇지 않으면 (거짓, 0)을 반환합니다.",Aborts:"절대"},{Function:"vector::insert<T>(v: &mut vector<T>, i: u64, e: T)",Description:"O(길이 - i) 시간을 사용하여 위치 0 <= i <= 길이에 새 요소 e를 삽입합니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::remove<T>(v: &mut vector<T>, i: u64): T",Description:"벡터 v의 i번째 요소를 제거하고 모든 후속 요소를 이동합니다. 이것은 O(n)이며 벡터에서 요소의 순서를 유지합니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::swap_remove<T>(v: &mut vector<T>, i: u64): T",Description:"벡터 v의 i번째 요소를 마지막 요소로 바꾼 다음 요소를 팝합니다. 이것은 O(1)이지만 벡터의 요소 순서는 유지하지 않습니다.",Aborts:"내가 범위를 벗어나면"},{Function:"vector::trim<T>(v: &mut vector<T>, new_len: u64): u64",Description:"벡터 v를 더 작은 크기의 new_len으로 자르고 제거된 요소를 순서대로 반환합니다.",Aborts:"new_len이 v의 길이보다 큽니다."},{Function:"vector::trim_reverse<T>(v: &mut vector<T>, new_len: u64): u64",Description:"벡터 v를 더 작은 크기의 new_len으로 자르고 제거된 요소를 역순으로 반환합니다.",Aborts:"new_len이 v의 길이보다 큽니다."},{Function:"vector::rotate<T>(v: &mut vector<T>, rot: u64): u64",Description:"rotate(&mut [1, 2, 3, 4, 5], 2) -> [3, 4, 5, 1, 2] 제자리에서 분할 지점을 반환합니다. 이 예에서 3",Aborts:"절대"},{Function:"vector::rotate_slice<T>(v: &mut vector<T>, left: u64, rot: u64, right: u64): u64",Description:"왼쪽 <= 회전 <= 오른쪽으로 길게 [ 왼쪽, 오른쪽 회전), 끝점 반환",Aborts:"절대"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.Function}),(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.Description}),(0,r.jsx)(e,{children:null==n?void 0:n.Aborts})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Example"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    \n    fun main(){\n      let v = vector::empty<u64>();\n      vector::push_back(&mut v, 5);\n      vector::push_back(&mut v, 6);\n\n      assert!(*vector::borrow(&v, 0) == 5, 42);\n      assert!(*vector::borrow(&v, 1) == 6, 42);\n      assert!(vector::pop_back(&mut v) == 6, 42);\n      assert!(vector::pop_back(&mut v) == 5, 42);\n    }\n"})}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"벡터 파괴 및 복사"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"vector<T>"}),"의 일부 동작은 원소 유형 T의 기능에 따라 달라집니다. 예를 들어,",(0,r.jsx)("span",{style:{color:"purple"},children:" 드롭(drop) "}),"기능이 없는 원소를 포함하는 벡터는 위의 예시에서 v와 같이 암묵적으로 폐기될 수 없으며, 명시적으로",(0,r.jsx)("span",{style:{color:"purple"},children:" vector::destroy_empty"}),"를 사용하여 파괴해야 합니다.",(0,r.jsx)("span",{style:{color:"purple"},children:" vector::destroy_empty"}),"는 vec에 원소가 없을 경우에만 실행 시점에서 중단됩니다:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun destory_any_vector<T>(vec:vector<T>){\n     vector::destory_empty(vec)//이 줄을 삭제하면 컴파일러 오류가 발생합니다.\n    }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["하지만 ",(0,r.jsx)("span",{style:{color:"purple"},children:" 드롭(drop) "}),"기능이 있는 원소를 포함하는 벡터를 폐기하려고 할 때 오류가 발생하지는 않습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun destroy_droppable_vector<T: drop>(vec: vector<T>) {\n       // 유효한!\n       // 벡터를 파괴하기 위해 명시적으로 수행할 필요가 없습니다.\n       // nothing needs to be done explicitly to destroy the vector\n   }\n   }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["마찬가지로, 원소 유형이",(0,r.jsx)("span",{style:{color:"purple"},children:"복사 가능한 경우"}),"에만 벡터를 복사할 수 있습니다. 다시 말해, T가 복사 가능한 경우에만","vector<T>","가 복사 가능합니다. 그러나 복사 가능한 벡터조차도 암묵적으로 복사되지는 않습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun example(){\n        let x = vector::singleton<u64>(10);\n        let y = copy x; // 사본이 없는 컴파일러 오류!\n    }\n    }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["대용량 벡터의 복사는 비용이 많이 들 수 있으므로 컴파일러는 복사가 명시적으로 이루어지도록 요구하여 어디에서 복사가 발생하는지 쉽게 파악할 수 있도록 합니다. 자세한 내용은",(0,r.jsx)("span",{style:{color:"purple"},children:"유형 능력(type abilities)"}),"과",(0,r.jsx)("span",{style:{color:"purple"},children:"제네릭(generics) "}),"섹션을 참조하십시오."]})})}),(0,r.jsx)(o.Z,{xs:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["위에서 언급한 대로,",(0,r.jsx)("span",{style:{color:"purple"},children:"원소가 복사 가능한 경우"}),"에만 벡터 값들을 복사할 수 있습니다. 이 경우에는 복사가 명시적으로 이루어져야 하며, 복사 또는",(0,r.jsx)("span",{style:{color:"purple"},children:" 역참조 *"}),"를 통해 이루어집니다."]})})})]})},S=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"서명자"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"서명자 "}),"는 기본 제공 이동 자원 유형입니다. 서명자는",(0,r.jsx)("span",{style:{color:"purple"},children:"소유자가 특정 주소를 대신하여 작업"}),"할 수 있도록 하는 기능입니다. 기본 구현을 다음과 같이 생각할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    struct signer has drop{\n     a:address\n    }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["서명자는 이동 외부의 코드(예:",(0,r.jsx)("span",{style:{color:"purple"},children:"암호화 서명 또는 암호 확인 "}),")로 인증된 사용자를 나타낸다는 점에서 Unix UID와 다소 유사합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"주소 비교"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 프로그램은 주소 리터럴을 사용하여 특별한 권한 없이 모든 주소 값을 만들 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n     let a1= @0x1;\n     let a1= @0x2;\n     // ... 다른 모든 가능한 주소에 대해 등등\n    }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["그러나 서명자 값은 리터럴이나 지침을 통해 생성할 수 없고",(0,r.jsx)("span",{style:{color:"purple"},children:"Move VM에서만 생성 "})," 할 수 있기 때문에 특별합니다. VM이 서명자 유형의 매개변수를 사용하여 스크립트를 실행하기 전에 서명자 값을 자동으로 생성하여 스크립트에 전달합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  script {\n    use std::signer;\n    fun main(s: signer) {\n        assert!(signer::address_of(&s) == @0x42, 0);\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"스크립트가 0x42 이외의 주소에서 전송되면 이 스크립트는 코드 0으로 중단됩니다. 트랜잭션 스크립트는 서명자가 다른 인수의 접두사인 한 임의의 수의 서명자를 가질 수 있습니다. 즉, 모든 서명자 인수가 먼저 와야 합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  script {\n    use std::signer;\n    fun main(s1: signer, s2: signer, x: u64, y: u8) {\n        // ...\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이는 여러 당사자의 권한으로 원자적으로 작동하는 다중 서명자 스크립트를 구현하는 데 유용합니다. 예를 들어, 위 스크립트의 확장은 s1과 s2 사이에 원자 통화 스왑을 수행할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"서명자 연산자"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:" std::signer "})," 표준 라이브러리 모듈은 서명자 값에 대해 두 가지 유틸리티 기능을 제공합니다."]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"함수"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{함수:"signer::address_of(&signer): address	",설명:"이 &signer로 래핑된 주소를 반환합니다."},{함수:"signer::borrow_address(&signer): &address		",설명:"이 &signer로 래핑된 주소에 대한 참조를 반환합니다."}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{children:null==n?void 0:n.함수}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["또한",(0,r.jsxs)("span",{style:{color:"purple"},children:["move_to","<T>","(&signer, T)"]}),"전역 저장소 연산자는 signer.address의 계정에 리소스 T를 게시하기 위해 ",(0,r.jsx)("span",{style:{color:"purple"},children:"&signer "}),"인수가 필요합니다. 이렇게 하면 인증된 사용자만 자신의 주소로 리소스를 게시하도록 선택할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["단순 스칼라 값과 달리 서명자 값은 복사할 수 없습니다. 즉",(0,r.jsx)("span",{style:{color:"purple"},children:"명시적 복사 명령을 통해서이든 역참조 *를 통해서든 어떤 작업에서도 복사할 수 없습니다."})]})})})]})},E=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"참조"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"불변 &"}),"및",(0,r.jsx)("span",{style:{color:"purple"},children:"가변 &mut"}),"의 두 가지 유형의 참조가 있습니다. 변경할 수 없는 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:" 읽기 전용"}),"이며 기본 값(또는 해당 필드)을 수정할 수 없습니다. 변경 가능한 참조는 해당 참조를 통한",(0,r.jsx)("span",{style:{color:"purple"},children:"쓰기를 통한 수정"}),"을 허용합니다. Move의 유형 시스템은 참조 오류를 방지하는 소유권 규율을 적용합니다. 참조 규칙에 대한 자세한 내용은 구조체 및 리소스를 참조하세요."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참조 연산자"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move는 참조를 만들고 확장할 뿐만 아니라 변경 가능한 참조를 변경 불가능한 참조로 변환하기 위한 연산자를 제공합니다. 여기와 다른 곳에서는",(0,r.jsx)("span",{style:{color:"purple"},children:'"표현식 e에는 T 유형이 있음"'}),"에 대해 표기법 ",(0,r.jsx)("span",{style:{color:"purple"},children:" e: T"}),"를 사용합니다."]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"&e",타입:"&T where e: T and T is a non-reference type	",설명:"e에 대한 불변 참조 생성"},{통사론:"&mut e",타입:"&mut T where e: T and T is a non-reference type	",설명:"e에 대한 변경 가능한 참조를 만듭니다."},{통사론:"&e.f",타입:"&T where e.f: T",설명:"구조체 e의 필드 f에 대한 불변 참조를 만듭니다."},{통사론:"&mut e.f",타입:"&mut T where e.f: T	",설명:"구조체의 필드 f에 대한 변경 가능한 참조를 만듭니다."},{통사론:"freeze(e)",타입:"&T where e: &mut T	",설명:"가변 참조 e를 불변 참조로 변환합니다."}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.타입}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:" &e.f"}),"및",(0,r.jsx)("span",{style:{color:"purple"},children:" &mut e.f "}),"연산자는 구조체에 대한 새 참조를 만들거나 기존 참조를 확장하는 데 모두 사용할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun  main(){\n      let s= S {f:10}\n      let f_ref1:&u64 = &s.f; //공장\n      let s_ref:&S= &s;\n      let f_ref2: &u64= &s_ref.f //또한 작동\n    }\n   }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"여러 필드가 있는 참조 표현식은 두 구조체가 동일한 모듈에 있는 한 작동합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    struct A {b:B}\n \n    struct B {\n        c:u64\n    }\n \n    fun f(a:&A): &u64{\n       &a.b.c\n    }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["마지막으로 참조에 대한 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:"허용되지 않습니다."})]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n  \n      let x= 7;\n      let y:&u64= &x;\n      let z:&&u64= &y;//컴파일 되지 않습니다.\n    }\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참고 문헌을 통한 읽기 및 쓰기"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["변경 가능한 참조와 변경 불가능한 참조를 모두 읽어 참조된 값의",(0,r.jsx)("span",{style:{color:"purple"},children:"복사본"}),"을 생성할 수 있습니다. 변경 가능한 참조만 작성할 수 있습니다. 쓰기",(0,r.jsx)("span",{style:{color:"purple"},children:" *x = v"}),"는 이전에 x에 저장된 값을 버리고 v로 업데이트합니다. 두 작업 모두 C와 유사한",(0,r.jsx)("span",{style:{color:"purple"},children:"* 구문"}),"을 사용합니다. 그러나 읽기는 표현식인 반면 쓰기는 등호의 왼쪽에서 발생해야 하는 변형입니다."]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"*e",타입:"T where e is &T or &mut T	",설명:"e가 가리키는 값을 읽습니다."},{통사론:"*e1 = e2	",타입:"() where e1: &mut T and e2: T	",설명:"e1의 값을 e2로 업데이트합니다."}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.타입}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["참조를 읽으려면 기본 유형에",(0,r.jsx)("span",{style:{color:"purple"},children:"복사"}),"기능이 있어야 합니다. 참조를 읽으면 값의 새 복사본이 생성되기 때문입니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"이 규칙은 리소스 값 복사를 방지합니다."})]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun copy_resource_via_ref_bad(c:Coin){\n      let c_ref= &c;\n      let counterfeit:Coin= *c_ref;//허용되지 않습니다!\n      pay(c);\n      pay(counterfeit);\n    }\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이중: 참조를 작성하려면 기본 유형에 삭제 기능이 있어야 합니다. 참조에 작성하면 이전 값이 삭제 (",(0,r.jsx)("span",{style:{color:"purple"},children:'또는 "삭제"'}),")되기 때문입니다. 이 규칙은 리소스 값의 파괴를 방지합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun destroy_resource_via_ref_bad(ten_coins:Coin,c:Coin){\n     let ref= &mut ten_coins;\n     *ref =c;//허용되지 않음-10개의 코인을 파괴합니다!\n    }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"동결 추론"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"변경 불가능한 참조가 예상되는 상황에서 변경 가능한 참조를 사용할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n      let x=  7;\n      let y= &u64= &mut x;\n    }\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이는 내부적으로 컴파일러가 필요한 곳에 고정 명령을 삽입하기 때문에 작동합니다. 다음은 고정 추론의 몇 가지 예입니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun takes_immut_returns_immut(x:&u64):&u64{x}\n \n    //반환값에 대한 추론 고정\n    fun takes_mut_returns_immut(x:&mut u64):&u64{x}\n \n    fun expression_examples(){\n \n     let x= 0;\n     let y= 0;\n     takes_immut_returns_immut(&x);//추론없음\n     takes_immut_returns_immut(&mut x);//추정 동결(&mut x)\n     takes_mut_returns_immut(&mut x);//추론없음\n \n     assert!(&x == &mut y,42);//추정 동결(&mut y)\n    }\n    \n \n    fun assignment_examples(){\n       let x= 0;\n       let y= 0;\n       let imm_ref:&u64 = &x;\n \n       imm_ref= &x;//추론없음\n       imm_ref= &mut y;//추정 동결(&mut y)\n     \n    }\n \n    \n    \n    }\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"하위 유형"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 동결 추론을 통해 Move 유형 검사기는",(0,r.jsx)("span",{style:{color:"purple"},children:"&mut T"}),"를",(0,r.jsx)("span",{style:{color:"purple"},children:"&T"}),"의 하위 유형으로 볼 수 있습니다. 위에 표시된 것처럼 이것은 &T 값이 사용되는 모든 표현식에 대해 &mut T 값도 사용할 수 있음을 의미합니다. 이 용어는 &T가 제공된 곳에 &mut T가 필요했음을 간결하게 나타내기 위해 오류 메시지에 사용됩니다. 예를 들어"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example{\n        fun read_and_assign(store:&mut u64,new_value:&u64){\n            *store= *new_value\n        }\n\n        fun subtype_examples(){\n            let x:&u64 = &0;\n            let y:&mut u64= &mut 1;\n\n            x= &mut 1;//유효한\n            y= &2 //유효하지 않은\n\n            read_and_assign(y,x);//유효한\n            read_and_assign(x,y);//유효하지 않은\n        }  \n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같은 오류 메시지가 나타납니다"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  error:\n\n  ┌── example.move:12:9 ───\n  │\n12 │         y = &2; // 유효하지 않은!\n  │         ^ Invalid assignment to local 'y'\n  \xb7\n12 │         y = &2; // 유효하지 않음!\n  │             -- The type: '&{integer}'\n  \xb7\n9 │         let y: &mut u64 = &mut 1;\n  │                -------- Is not a subtype of: '&mut u64'\n  │\n\nerror:\n\n  ┌── example.move:15:9 ───\n  │\n15 │         read_and_assign(x, y); // 유효하지 않음!\n  │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'\n  \xb7\n8 │         let x: &u64 = &0;\n  │                ---- The type: '&u64'\n  \xb7\n3 │     fun read_and_assign(store: &mut u64, new_value: &u64) {\n  │                                -------- Is not a subtype of: '&mut u64'\n  │\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["현재 하위 유형이 있는 유일한 다른 유형은",(0,r.jsx)("span",{style:{color:"purple"},children:"튜플"}),"입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"동일한 참조의 기존 복사본이나 확장이 있더라도 변경 가능한 참조와 변경 불가능한 참조는 항상 복사 및 확장될 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun reference_copies(s:&mut S){\n      let s_copy1=s;//유효\n      let s_extension= &mut s.f;//유효\n      let s_copy2 = s;//유효\n    }\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이것은 위의 코드를 거부하는 Rust의 소유권 시스템에 익숙한 프로그래머에게는 놀라운 일이 될 수 있습니다. Move의 타입 시스템은 복사본 처리에 있어서 더 관대하지만 쓰기 전에 변경 가능한 참조의 고유한 소유권을 보장하는 데 있어서도 똑같이 엄격합니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참조를 저장할 수 없음"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"참조"})," 와",(0,r.jsx)("span",{style:{color:"purple"},children:"튜플"}),"은 구조체의 필드 값으로 저장할 수 없는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"유일한 유형"}),"이며, 이는",(0,r.jsx)("span",{style:{color:"purple"},children:"전역 저장소에 존재할 수 없음을 의미"}),"하기도 합니다. 프로그램 실행 중에 생성된 모든 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:"Move 프로그램이 종료될 때 삭제"}),"됩니다. 그들은 완전히",(0,r.jsx)("span",{style:{color:"purple"},children:" 일시적"})," 입니다. 이 불변성은 저장 기능이 없는 유형의 값에도 적용되지만 참조와 튜플은 애초에 구조체에서 허용되지 않음으로써 한 단계 더 나아갑니다. 이것은 Move와 Rust의 또 다른 차이점으로, 구조체 내부에 참조를 저장할 수 있습니다. 현재 Move는 참조를 직렬화할 수 없기 때문에 이를 지원할 수 없지만 모든 Move 값은 직렬화 가능해야 합니다. 이 요구 사항은 프로그램 실행 간에 값을 유지하기 위해 값을 직렬화해야 하는 Move의 영구 전역 저장소에서 비롯됩니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체는 전역 저장소에 쓸 수 있으므로 직렬화 가능해야 합니다."}),"참조를 구조체에 저장하고 해당 구조체가 전역 저장소에 존재하는 것을 금지하는 더 멋지고 표현력이 뛰어난 유형 시스템을 상상할 수 있습니다. 저장 기능이 없는 구조체 내부의 참조를 허용할 수도 있지만 문제를 완전히 해결하지는 못합니다. Move에는 정적 참조 안전성을 추적하는 상당히 복잡한 시스템이 있으며 유형 시스템의 이러한 측면도 확장해야 합니다. 구조체 내부에 참조 저장을 지원합니다. 요컨대, Move의 유형 시스템(특히 참조 안전성에 관한 측면)은 저장된 참조를 지원하도록 확장되어야 합니다. 그러나 그것은 언어가 발전함에 따라 우리가 주시하고 있는 것입니다."]})})})]})},D=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"튜플 및 단위"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move는 튜플을 일급 값으로 사용하는 다른 언어에서 온 것으로 예상할 수 있으므로 튜플을 완전히 지원하지 않습니다. 그러나 여러 반환 값을 지원하기 위해 Move에는",(0,r.jsx)("span",{style:{color:"purple"},children:" 튜플과 같은 표현식"}),"이 있습니다. 이러한 식은 런타임에 구체적인 값을 생성하지 않으며(",(0,r.jsx)("span",{style:{color:"purple"},children:"바이트코드에 튜플이 없음"}),") 결과적으로 매우 제한적입니다. 식에만 나타날 수 있습니다(",(0,r.jsx)("span",{style:{color:"purple"},children:"일반적으로 함수의 반환 위치"}),"). 지역 변수에 바인딩할 수 없습니다. 구조체에 저장할 수 없습니다. 제네릭을 인스턴스화하는 데 튜플 유형을 사용할 수 없습니다. 마찬가지로 ",(0,r.jsx)("span",{style:{color:"purple"},children:"unit()"}),"은 표현식 기반이 되기 위해 Move 소스 언어에서 만든 유형입니다. 단위 값()은 런타임 값을 생성하지 않습니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"unit()"})," 을 빈 튜플로 간주할 수 있으며 튜플에 적용되는 모든 제한 사항이 유닛에도 적용됩니다. 이러한 제한 사항을 감안할 때 언어에 튜플이 있는 것이 이상하게 느껴질 수 있습니다. 그러나 다른 언어에서 튜플의 가장 일반적인 사용 사례 중 하나는 함수가 여러 값을 반환할 수 있도록 하는 함수입니다. 일부 언어는 사용자가 여러 반환 값을 포함하는 구조체를 작성하도록 강제하여 이 문제를 해결합니다. 그러나 Move에서는",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체 내부에 참조를 넣을 수 없습니다."}),"여러 반환 값을 지원하려면 Move가 필요했습니다. 이러한 여러 반환 값은 모두 바이트 코드 수준에서 스택에 푸시됩니다. 소스 수준에서 이러한 여러 반환 값은 튜플을 사용하여 표시됩니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"튜플은 괄호 안에 쉼표로 구분된 표현식 목록으로 생성됩니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"()",타입:"(): ()",설명:"단위, 빈 튜플 또는 인수가 0인 튜플"},{통사론:"(e1, ..., en)",타입:"(e1, ..., en): (T1, ..., Tn) where e_i: Ti s.t. 0 < i <= n and n > 0",설명:"n-튜플, 개수 n의 튜플, n개의 요소가 있는 튜플"}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.타입}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"(e)"})," 에는",(0,r.jsx)("span",{style:{color:"purple"},children:"(e): (t)"})," 유형이 없습니다. 즉,",(0,r.jsx)("span",{style:{color:"purple"},children:"하나의 요소가 있는 튜플이 없습니다."}),"괄호 안에 하나의 요소만 있는 경우 괄호는 명확성을 위해서만 사용되며 다른 특별한 의미는 없습니다. 때로는 요소가 두 개인 튜플을",(0,r.jsx)("span",{style:{color:"purple"},children:' "쌍"'}),"이라고 하고 요소가 세 개인 튜플을 ",(0,r.jsx)("span",{style:{color:"purple"},children:' "트리플"'}),"이라고 합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  address 0x42 {\n    module example {\n        // 이 세 가지 기능은 모두 동일합니다.\n    \n    //반환 유형이 제공되지 않으면 ()로 간주됩니다.\n        fun returns_unit_1() { }\n    \n    \n    // 빈 표현식 블록에 암시적() 값이 있습니다.\n        fun returns_unit_2(): () { }\n    \n    \n    // returns_unit_1 및 returns_unit_2의 명시적 버전\n        fun returns_unit_3(): () { () }\n    \n    \n        fun returns_3_values(): (u64, bool, address) {\n            (0, false, @0x42)\n        }\n        fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n            (x, 0, 1, b"foobar")\n        }\n    }\n    }\n'})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Operations"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["현재 튜플에서 수행할 수 있는 유일한 작업은",(0,r.jsx)("span",{style:{color:"purple"},children:"구조 분해"})," 입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Destructuring"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모든 크기의 튜플에 대해 let 바인딩이나 할당에서 해체될 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  address 0x42 {\n    module example {\n        \n    // 이 3개의 함수는 모두 동일합니다.\n    \n    \n     fun returns_uint(){}\n    \n     fun returns_2_values():(bool,bool){\n        (true,false)\n     } \n    \n     fun return_4_values(x:&u64):(&u64,u8,u128,vector<u8>){\n        (x,0,1,b"foobar")\n     }\n    \n     fun examples(cond:bool){\n        let ()= ();\n        let (x,y):(u8,u64)= (0,1);\n        let (a,b,c,d)= (@0x0,0,false,b"");\n    \n        ()= ();\n        (x,y)= if(cond)(1,2)else (3,4);\n        (a,b,c,d)= (@0x1,1,true,b"1");\n     }\n    \n     fun example_with_function_calls(){\n        let ()=  returns_unit();\n        let (x,y):(bool,bool)= returns_2_values();\n        let (a,b,c,d)= returns_4_values(&0);\n    \n        ()= returns_unit();\n        (x,y)= returns_2_values();\n        (a,b,c,d )= return_4_values(&1);\n     }\n    \n    \n    }\n    }\n'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"자세한 내용은 변수 이동을 참조하십시오."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Subtyping"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["참조와 함께 튜플은 Move에서",(0,r.jsx)("span",{style:{color:"purple"},children:"하위 유형"})," 이 있는 유일한 유형입니다. 튜플은 (",(0,r.jsx)("span",{style:{color:"purple"},children:" 공변량 방식으로"})," ) 참조가 있는 하위 유형이라는 의미에서만 하위 유형이 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example ::test {\n    fun main(){\n     let x:&u64= &0;\n     let y:&mut u64= &mut 1;\n    \n     // (&u64, &mut u64)는 (&u64, &u64)의 하위 유형입니다.\n     //&mut u64는 &u64의 하위 유형이므로\n     let (a, b): (&u64, &u64) = (x, y);\n      \n \n     // (&mut u64, &mut u64)는 (&u64, &u64)의 하위 유형입니다.\n     // &mut u64는 &u64의 하위 유형이므로 \n     let (c, d): (&u64, &u64) = (y, y);\n     \n \n      // 오류! (&u64, &mut u64)는 (&mut u64, &mut u64)의 하위 유형이 아닙니다.\n     // &u64는 &mut u64의 하위 유형이 아니므로\n \n     let (e, f): (&mut u64, &mut u64) = (x, y);\n \n \n     }\n }\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["위에서 언급했듯이 튜플 값은 런타임에 실제로",(0,r.jsx)("span",{style:{color:"purple"},children:" 존재하지 않습니다. "}),"그리고 현재 이 때문에 로컬 변수에 저장할 수 없습니다(",(0,r.jsx)("span",{style:{color:"purple"},children:"그러나 이 기능이 곧 제공될 가능성이 높습니다"}),"). 따라서 튜플을 복사하려면 먼저 지역 변수에 넣어야 하므로 튜플은 현재에만 이동할 수 있습니다."]})})})]})};function N(e){let{text:t}=e;return(0,r.jsx)("span",{style:{color:"purple"},children:t})}var z=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"지역변수에 변수 및 범위"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move의 지역 변수는 어휘(",(0,r.jsx)(N,{text:"정적으로"}),") 범위가 지정됩니다. 새 변수는",(0,r.jsx)(N,{text:"let"}),"키워드로 도입되며 동일한 이름을 가진 이전의 지역 변수를 가려버립니다. 지역 변수는 가변(",(0,r.jsx)(N,{text:"mutable"}),")이며, 직접적으로 업데이트하거나 가변 참조를 통해 업데이트할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"let bindings"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move는 ",(0,r.jsx)(N,{text:"let"}),"을 사용하여 변수 이름과 값을 바인딩합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 1;\n  let y = x + x:\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"}),"은 지역변수에 값을 바인딩하지 않고도 사용할 수도 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x;\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["그런 다음 ",(0,r.jsx)(N,{text:"지역변수"}),"에 나중에 값을 할당할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,children:(0,r.jsx)(g,{code:" let x;\n  if (cond) {\n    x = 1\n  } else {\n    x = 0\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이는 기본값을 제공할 수 없는 경우에 루프에서 값을 추출하려고 할 때 매우 유용할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,children:(0,r.jsx)(g,{code:"  let x;\n  let cond = true;\n  let i = 0;\n  loop {\n      (x, cond) = foo(i);\n      if (!cond) break;\n      i = i + 1;\n  }\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"변수는 사용하기 전에 할당되어야 합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 언어의 유형 시스템은 지역 변수가 할당되기 전에 사용되는 것을 방지합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x;\n  x + x // 에러발생!\n\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x;\n  if (cond) x = 0;\n  x + x // 에러발생!"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x;\n  while (cond) x = 0;\n  x + x // 에러발생!\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"유효한 변수 이름"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["변수 이름에는 밑줄 ",(0,r.jsx)(N,{text:"_, 문자 a~z, 문자 A~Z, 숫자 0~9"}),"가 포함될 수 있습니다. 변수 이름은 ",(0,r.jsx)(N,{text:"밑줄 _"}),"또는 문자 ",(0,r.jsx)(N,{text:" a~z"}),"로 시작해야 합니다.대문자로 시작할 수는 없습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  //모두 유효\n  let x = e;\n  let _x = e;\n  let _A = e;\n  let x0 = e;\n  let xA = e;\n  let foobar_123 = e;\n  \n  // 모두 유효하지 않음\n  let X = e; // 에러!\n  let Foo = e; // 에러!\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"유형 주석"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["지역 변수의 유형은 거의 항상 Move의 유형 시스템에 의해 추론될 수 있습니다. 그러나 Move는 ",(0,r.jsx)(N,{text:"가독성, 명확성"})," 또는",(0,r.jsx)(N,{text:"디버깅"}),"가능성을 위해 유용한 명시적인 유형 주석을 허용합니다. 유형 주석을 추가하는 구문은 다음과 같습니다:"]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"center"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:(0,r.jsx)(N,{text:"    *유형주석:변수, 매개변수, 반환 값 등에 대해 유형 정보를 명시적으로 표기하는 것을 의미"})})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x: T = e; // T 유형의 변수 x는 표현식 e로 초기화됩니다.\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"명시적 유형 주석의 몇 가지 예:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  address 0x42 {\n    module example {\n    \n        struct S { f: u64, g: u64 }\n    \n        fun annotated() {\n            let u: u8 = 0;\n            let b: vector<u8> = b"hello";\n            let a: address = @0x0;\n            let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n            let S { f, g: f2 }: S = S { f: 0, g: 1 };\n        }\n    }\n}\n'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"유형 주석은 항상 패턴의 오른쪽에 위치해야 합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let (x: &u64, y: &mut u64) = (&0, &mut 1); // 오류! (x, y): ... =여야 합니다. "})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"주석이 필요한 경우"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일부 경우에는 유형 시스템이 유형을 추론할 수 없는 경우 로컬 유형 주석이 필요합니다. 이는 일반적으로 제네릭 유형의 유형 인수를 추론할 수 없는 경우에 발생합니다. 예를 들면:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let _v1 = vector::empty(); // 에러가 발생!\n  //        ^^^^^^^^^^^^^^^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요.\n  let v2: vector<u64> = vector::empty(); //에러가 발생하지않음\n  "})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["더 드물게, 유형 시스템은 타입을 추론할 수 없는 비상귀 코드(",(0,r.jsx)(N,{text:"모든 다음 코드는 접근 불가능한 경우"}),")에 대한 타입을 결정할 수 없을 수도 있습니다.",(0,r.jsx)(N,{text:"return"})," 과 ",(0,r.jsx)(N,{text:"abort"}),"는 모두 식(",(0,r.jsx)(N,{text:"expression"}),")이므로 어떤 타입이든 가질 수 있습니다. ",(0,r.jsx)(N,{text:"break"}),"가 있는 경우 loop의 타입은 ()이지만, loop에서 ",(0,r.jsx)(N,{text:"break"}),"가 없는 경우 어떤 타입이든 가질 수 있습니다. 이러한 경우에는 타입 주석이 필요합니다. 예를 들어, 다음 코드:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let a: u8 = return ();\n  let b: bool = abort 0;\n  let c: signer = loop ();\n  \n  let x = return (); // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n  let y = abort 0; // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n  let z = loop (); // 오류!\n  //  ^ 이 유형을 추론할 수 없습니다. 주석을 추가해 보세요\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 코드에 유형 주석을 추가하면 사용되지 않는 지역 변수나 죽은 코드에 대한 다른 오류가 드러날 수 있지만, 이 예시는 이러한 문제를 이해하는 데 도움이 될 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"튜플을 사용한 여러개의 선언"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"}),"키워드를 사용하면 튜플을 사용하여 한 번에 여러 개의 지역 변수를 동시에 선언할 수 있습니다. 괄호 내에 선언된 지역 변수들은 튜플에서 해당하는 값으로 ",(0,r.jsx)(N,{text:"초기화"}),"됩니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let () = ();\n  let (x0, x1) = (0, 1);\n  let (y0, y1, y2) = (0, 1, 2);\n  let (z0, z1, z2, z3) = (0, 1, 2, 3);\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"표현식의 유형은 튜플 패턴의 개수와 정확히 일치해야 합니다. 예를 들어, 다음과 같은 코드를 살펴보겠습니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let (x, y) = (0, 1, 2); // 오류!\n  let (x, y, z, q) = (0, 1, 2); // 오류!\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["하나의 ",(0,r.jsx)(N,{text:"let"})," 문 내에서 동일한 이름으로 여러 개의 지역 변수를 선언할 수는 없습니다. 예를 들어, 다음과 같은 코드를 살펴보겠습니다:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let (x, x) = 0; // 오류!\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"구조체가 있는 여러개의 선언"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"})," 키워드는 구조체를 분해하거나 구조체에 대한 매칭을 할 때 한 번에 여러 개의 로컬 변수를 동시에 선언할 수도 있습니다. 이 형태에서 ",(0,r.jsx)(N,{text:"let"}),"은 구조체의 필드 값으로 초기화된 지역 변수 집합을 생성합니다. 구문은 다음과 같습니다:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  struct T { f1: u64, f2: u64 }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n  // local1: u64\n  // local2: u64\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음은 더 복잡한 예입니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n        struct Y { x1: X, x2: X }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        fun example() {\n            let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };\n            assert!(f + x2.f == 2, 42);\n    \n            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };\n            assert!(f1 + f2 == 2, 42);\n        }\n    }\n    }\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"구조체"}),"의 필드는 변수를 바인딩할 때와 변수의 이름으로 사용될 수 있는 두 가지 역할을 동시에 수행할 수 있습니다. 이는 때때로 ",(0,r.jsx)(N,{text:"punning"}),"이라고도 불립니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let X { f } = e;"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let X { f: f } = e;"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["튜플과 마찬가지로, 하나의 ",(0,r.jsx)(N,{text:"let"})," 문 내에서 동일한 이름으로 여러 개의 지역 변수를 선언할 수는 없습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let Y { x1: x, x2: x } = e; // 오류!"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참조를 통한 구조분해(Destructuring against references)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["구조체 예제에서 ",(0,r.jsx)(N,{text:"let"})," 문에서 바인딩된 값은 이동(",(0,r.jsx)(N,{text:"move"}),")되어 구조체 값이 파괴되고 그 필드들이 바인딩됩니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  struct T { f1: u64, f2: u64 }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n  // local1: u64\n  // local2: u64"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 경우",(0,r.jsx)(N,{text:" T { f1: 1, f2: 2 }"}),"와 같은 구조체 값은",(0,r.jsx)(N,{text:" let"})," 이후에 더 이상 존재하지 않습니다. 대신 구조체 값을 이동시키지 않고 파괴하지 않고 각 필드를 빌림(",(0,r.jsx)(N,{text:"borrow"}),")하려면 다음과 같이 할 수 있습니다:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let t = T { f1: 1, f2: 2 };\n  let T { f1: local1, f2: local2 } = &t;\n  // local1: &u64\n  // local2: &u64"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["마찬가지로 가변 참조( ",(0,r.jsx)(N,{text:"mutabale references"}),")를 사용하여 비슷한 방식으로 수행할 수 있습니다:"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let t = T { f1: 1, f2: 2 };\n  let T { f1: local1, f2: local2 } = &mut t;\n  // local1: &mut u64\n  // local2: &mut u64"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 동작은 중첩된 구조체에 대해서도 동작할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n        struct Y { x1: X, x2: X }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        fun example() {\n            let y = Y { x1: new_x(), x2: new_x() };\n    \n            let Y { x1: X { f }, x2 } = &y;\n            assert!(*f + x2.f == 2, 42);\n    \n            let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;\n            *f1 = *f1 + 1;\n            *f2 = *f2 + 1;\n            assert!(*f1 + *f2 == 4, 42);\n        }\n    }\n    }"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"값 무시 (Ignoring Values)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"})," 바인딩에서는 가끔씩 몇 가지 값을 무시하는 것이 유용합니다.",(0,r.jsx)(N,{text:"_"}),"로 시작하는 지역 변수는 무시되며 새로운 변수를 도입하지 않습니다"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  fun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let (x1, _, z1) = three();\n  let (x2, _y, z2) = three();\n  assert!(x1 + z1 == x2 + z2, 42);"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이는 때때로 필요할 수 있습니다. 사용되지 않는 지역 변수에 대해서는 컴파일러가 ",(0,r.jsx)(N,{text:"에러"}),"를 발생시킵니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let (x1, y, z1) = three(); // 오류!\n  //       ^ 미사용 지역 변수 'y'"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"일반적인 let 문법(General let grammar)"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["모든 다양한 구조들을 let에서 결합할 수 있습니다! 그렇게 함으로써 let 문에 대한 ",(0,r.jsx)(N,{text:"일반적인 문법"}),"을 얻을 수 있습니다:"]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:" let-binding → let pattern-or-list type-annotationopt\n            initializeropt > pattern-or-list → pattern | ( pattern-list ) >\n            pattern-list → pattern ,opt | pattern , pattern-list >\n            type-annotation → : type initializer → = expression"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["바인딩을 도입하는 항목에 대한 일반적인 용어는 패턴입니다. 패턴은 데이터를 해체하고(",(0,r.jsx)(N,{text:"가능한 경우 재귀적으로"}),") 바인딩을 도입하는 데 사용됩니다. 패턴 문법은 다음과 같습니다:"]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"pattern → local-variable | struct-type { field-binding-list } > field-binding-list → field-binding ,opt | field-binding , field-binding-list > field-binding → field | field : pattern"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 문법을 적용한 몇 가지 구체적인 예시를 살펴보겠습니다."})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"      let (x, y): (u64, u64) = (0, 1);\n  //       ^                           지역변수\n  //       ^                           패턴\n  //          ^                        지역변수\n  //          ^                        패턴\n  //          ^                        패턴목록\n  //       ^^^^                        패턴목록\n  //      ^^^^^^                       패턴 또는 목록\n  //            ^^^^^^^^^^^^           타입주석\n  //                         ^^^^^^^^  초기화자\n  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-바인딩\n  \n      let Foo { f, g: x } = Foo { f: 0, g: 1 };\n  //      ^^^                                    구조체타입\n  //            ^                                필드\n  //            ^                                필드-binding\n  //               ^                             필드\n  //                  ^                          지역변수\n  //                  ^                          패턴\n  //               ^^^^                          필드-binding\n  //            ^^^^^^^                          필드 바인딩 목록\n  //      ^^^^^^^^^^^^^^^                        패턴\n  //      ^^^^^^^^^^^^^^^                        패턴 또는 목록\n  //                      ^^^^^^^^^^^^^^^^^^^^   초기화자\n  //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-바인딩"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"변경(Mutations)"})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"할당(Assignments)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["지역 변수가 도입된 후 (",(0,r.jsx)(N,{text:"let 또는 함수 매개변수로 도입됨"}),"), 할당을 통해 지역 변수를 수정할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  x = e"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"})," 바인딩과 달리 할당은 표현식입니다. 일부 언어에서는 할당이 할당된 값 자체를 반환하지만, Move에서는 어떤 할당이든 항상",(0,r.jsx)(N,{text:"()"})," 타입을 갖습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  (x = e: ())"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["실제로, 할당이 ",(0,r.jsx)(N,{text:"표현식"}),"이라는 것은 중괄호",(0,r.jsx)(N,{text:"({ ... })"})," 로 새로운 표현식 블록을 추가하지 않고도 사용할 수 있다는 의미입니다"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  if (cond) x = 1 else x = 2;"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["할당은 ",(0,r.jsx)(N,{text:"let"})," 바인딩과 동일한 패턴 구문 체계를 사용합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct X { f: u64 }\n    \n        fun new_x(): X {\n            X { f: 1 }\n        }\n    \n        //이 예제는 사용되지 않은 변수와 할당에 대한 경고를 발생시킬 것입니다.\n        fun example() {\n           let (x, _, z) = (0, 1, 3);\n           let (x, y, f, g);\n    \n           (X { f }, X { f: x }) = (new_x(), new_x());\n           assert!(f + x == 2, 42);\n    \n           (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);\n        }\n    }\n    }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"지역변수"})," 는 하나의 타입만 가질 수 있으므로, 지역 변수의 타입은 할당 사이에 변경될 수 없습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x;\n  x = 0;\n  x = false; // 오류!"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참조를 통한 변경(Mutating through a reference)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["할당을 통해 지역 변수를 직접 수정하는 것 외에도, 지역 변수는 가변 참조( ",(0,r.jsx)(N,{text:"&mut"})," )를 통해 수정할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  let r = &mut x;\n  *r = 1;\n  assert!(x == 1, 42);"})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 기능은 특히 다음과 같은 경우에 유용합니다:"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"(1) 어떤 조건에 따라 다른 변수를 수정하고 싶은 경우"})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  let y = 1;\n  let r = if (cond) &mut x else &mut y;\n  *r = *r + 1;"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"(2) 다른 함수가 로컬 값을 수정하도록 하려는 경우"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  modify_ref(&mut x);"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이러한 수정 작업은 구조체(",(0,r.jsx)(N,{text:"struct"}),")와 벡터(",(0,r.jsx)(N,{text:"vector"}),")를 수정하는 방법입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let v = vector::empty();\n  vector::push_back(&mut v, 100);\n  assert!(*vector::borrow(&v, 0) == 100, 42);"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"범위(Scope)"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"let"}),"으로 선언된 모든 지역 변수는 해당 범위 내에서 이후의 모든 표현식에서 사용할 수 있습니다. 범위는 표현식 블록",(0,r.jsx)(N,{text:" {...}"}),"으로 선언됩니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"지역 변수는 선언된 범위 외부에서 사용할 수 없습니다."})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  {\n      let y = 1;\n  };\n  x + y // 오류!\n  //  ^ 선언되었지만 어떠한 값에도 바인딩되지 않은 'y'"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["하지만, 외부 범위의 지역 변수는 ",(0,r.jsx)(N,{text:"중첩"}),"된 범위에서 사용할 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  {\n    let x = 0;\n    {\n        let y = x + 1; // 유효\n    }\n}"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"지역 변수는 접근 가능한 모든 범위에서 변경할 수 있습니다. 그 변경은 해당 지역 변수와 함께 유지되며, 변경을 수행한 범위와는 관계없이 유지됩니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  x = x + 1;\n  assert!(x == 1, 42);\n  {\n      x = x + 1;\n      assert!(x == 2, 42);\n  };\n  assert!(x == 2, 42);"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"표현식 블록(Expression Blocks)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"표현식 블록"}),"은 세미콜론 (",(0,r.jsx)(N,{text:";"}),")으로 구분된 일련의 문장들입니다. 표현식 블록의 결과값은 블록 내 마지막 표현식의 값입니다. 표현식 블록은 여러 개의 문장을 순차적으로 실행하고, 각 문장의 결과를 연속적으로 평가할 수 있는 유용한 도구입니다. 또한, 표현식 블록은 논리적인 코드 블록을 구성하고 제어 흐름을 조작하는 데 사용될 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  { let x = 1; let y = 1; x + y }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 예시에서 블록의 결과는 ",(0,r.jsx)(N,{text:"x + y"}),"입니다. 문장은 let 선언이나 표현식이 될 수 있습니다. 기억해 주세요, 할당문 ",(0,r.jsx)(N,{text:"(x = e)"}),"은 ",(0,r.jsx)(N,{text:"()"})," 타입의 표현식입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  { let x; let y = 1; x = 1; x + y }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["함수 호출은 ",(0,r.jsx)(N,{text:"()"})," 타입의 또 다른 일반적인 표현식입니다. 데이터를 수정하는 함수 호출은 주로 문장으로 사용됩니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  { let v = vector::empty(); vector::push_back(&mut v, 1); v }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이것은 ",(0,r.jsx)(N,{text:"()"}),"유형에만 국한되지 않습니다. 어떤 표현식이든 순서에서 문장으로 사용될 수 있습니다!"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  {\n    let x = 0;\n    x + 1; // 값이 버려졌습니다\n    x + 2; // 값이 버려졌습니다\n    b"hello"; // 값이 버려졌습니다\n}'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["하지만! 만약 표현식에 리소스 (",(0,r.jsx)(N,{text:"drop기능이 없는 값"}),")가 포함되어 있다면 오류가 발생합니다. 이는 Move의 유형 시스템이 버림(",(0,r.jsx)(N,{text:"drop"}),")이 있는 모든 값이 drop 기능을 가지고 있다는 것을 보장하기 때문입니다. (",(0,r.jsx)(N,{text:"소유권은 전달되거나 선언된 모듈 내에서 명시적으로 파괴되어야 함을 보장합니다."}),")"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  {\n    let x = 0;\n    Coin { value: x }; // 오류!\n//  ^^^^^^^^^^^^^^^^^ 삭제(drop) 기능 없이 사용되지 않는 값\n    x\n}"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["만약 블록 안에 최종 표현식이 없는 경우 - 즉, 후행 세미콜론",(0,r.jsx)(N,{text:";"})," 이 있는 경우 - 암시적으로 단위",(0,r.jsx)(N,{text:"()"})," 값이 존재합니다. 마찬가지로, 표현식 블록이 비어있는 경우에도 암시적으로 단위 ",(0,r.jsx)(N,{text:"()"})," 값이 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  // 두 번역은 동등합니다\n  { x = x + 1; 1 / x; }\n  { x = x + 1; 1 / x; () }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  // 두 번역은 동등합니다\n  { }\n  { () }"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"표현식블록"}),"은 그 자체로 표현식이며, 표현식이 사용되는 모든 곳에서 사용할 수 있습니다. (참고:",(0,r.jsx)(N,{text:"함수의 본문도 표현식 블록이지만, 함수 본문은 다른 표현식으로 대체할수 없습니다."}),")"]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  let my_vector: vector<vector<u8>> = {\n    let v = vector::empty();\n    vector::push_back(&mut v, b"hello");\n    vector::push_back(&mut v, b"goodbye");\n    v\n};'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"(이 예시에서는 타입 주석이 필요하지 않지만, 명확성을 위해 추가되었습니다.)"})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"섀도잉(shadowing)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["만약 let을 사용하여 이미 ",(0,r.jsx)(N,{text:"scope"}),"에 존재하는 이름의 지역 변수를 도입한다면, 해당 이전 변수는 이후에 해당 스코프에서 더 이상 접근할 수 없습니다. 이를 ",(0,r.jsx)(N,{text:"shadowing"}),"이라고 합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  assert!(x == 0, 42);\n  \n  let x = 1; // x 가 가려졌습니다\n  assert!(x == 1, 42);\n  \n  "})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["지역 변수가 ",(0,r.jsx)(N,{text:"shadowing"}),"되면, 이전과 동일한 타입을 유지할 필요는 없습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  let x = 0;\n  assert!(x == 0, 42);\n  \n  let x = b"hello"; // x 가 가려졌습니다\n  assert!(x == b"hello", 42);\n  \n  '})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["지역 변수가 ",(0,r.jsx)(N,{text:"shadowing"}),"된 후에도 해당 변수에 저장된 값은 여전히 존재하지만 더 이상 접근할 수 없습니다. 이는",(0,r.jsx)(N,{text:"drop"})," 기능이 없는 타입의 값들에 대해 유의해야 하는 중요한 사항입니다. 해당 값의 ",(0,r.jsx)(N,{text:"소유권"}),"은 함수가 끝나기 전에 전달되어야 합니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct Coin has store { value: u64 }\n\n        fun unused_resource(): Coin {\n            let x = Coin { value: 0 }; // 오류!\n//              ^ 이 지역 변수는 여전히 삭제 기능이 없는 값을 포함하고 있습니다.\n            x.value = 1;\n            let x = Coin { value: 10 };\n            x\n//          ^ 잘못된 반환\n        }\n    }\n}"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["지역 변수가 ",(0,r.jsx)(N,{text:"scope"})," 내에서",(0,r.jsx)(N,{text:"shadowing"}),"된 경우, 해당 ",(0,r.jsx)(N,{text:"shadowing"}),"은 그 ",(0,r.jsx)(N,{text:"scope"})," 내에서만 유지됩니다. 해당 scope가 종료되면 ",(0,r.jsx)(N,{text:"shadowing"}),"은 사라집니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  {\n      let x = 1;\n      assert!(x == 1, 42);\n  };\n  assert!(x == 0, 42);"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["기억해 주세요, 지역 변수는 ",(0,r.jsx)(N,{text:"shadowing"}),"될 때 타입이 변경될 수 있습니다."]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  let x = 0;\n  {\n      let x = b"hello";\n      assert!(x = b"hello", 42);\n  };\n  assert!(x == 0, 42);'})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"이동 및 복사"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 언어에서는 모든 지역 변수를 ",(0,r.jsx)(N,{text:"move"})," 또는",(0,r.jsx)(N,{text:"copy"}),"의 두 가지 방법으로 사용할 수 있습니다. 둘 중 하나가 명시되지 않은 경우, Move 컴파일러는 복사(",(0,r.jsx)(N,{text:"copy"}),") 또는 이동( ",(0,r.jsx)(N,{text:"move"}),")을 사용해야 하는지를 추론할 수 있습니다. 이는 위의 모든 예제에서 컴파일러가 ",(0,r.jsx)(N,{text:"move"})," 또는 ",(0,r.jsx)(N,{text:"copy"}),"를 삽입한다는 것을 의미합니다. 지역변수 변수는 ",(0,r.jsx)(N,{text:"move"}),"또는",(0,r.jsx)(N,{text:"copy"})," 없이 사용할 수 없습니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)(N,{text:"copy"}),"는 다른 프로그래밍 언어에서 익숙할 것입니다. 변수 내부의 값을 새로 복사하여 해당 표현식에서 사용합니다.",(0,r.jsx)(N,{text:"copy"}),"를 사용하면 로컬 변수를 한 번 이상 사용할 수 있습니다."]})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 0;\n  let y = copy x + 1;\n  let z = copy x + 2;"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["copy와 달리, ",(0,r.jsx)(N,{text:"move"}),"는 데이터를 복사하지 않고 지역 변수에서 값을 가져옵니다. Move가 발생한 후에는 해당 지역 변수를 사용할 수 없습니다. move는 지역 변수에서 값을 가져오는 동시에",(0,r.jsx)(N,{text:"변수를 비웁니다."})]})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  let x = 1;\n  let y = move x + 1;\n  //      ------ \b지역 변수가 여기로 이동되었습니다\n  let z = move x + 2; // 오류!\n  //      ^^^^^^\"지역 변수 'x'의 잘못된 사용\"\n  y + z"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"안전"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move의 타입 시스템은 값을 ",(0,r.jsx)(N,{text:"move"}),"한 후에 사용되는 것을 방지합니다. 이는 let 선언에서 설명한 것과 동일한 안전성 검사입니다. 이는 로컬 변수가 값을 할당하기 전에 사용되는 것을 방지하는 기능입니다."]})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"추론"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["앞서 언급한대로, Move 컴파일러는 명시적으로 복사(",(0,r.jsx)(N,{text:"copy"}),") 또는 이동( ",(0,r.jsx)(N,{text:"move"}),")가 지정되지 않은 경우에도 자동으로 ",(0,r.jsx)(N,{text:"복사"})," 또는",(0,r.jsx)(N,{text:"이동"}),"을 추론합니다. 이를 위한 알고리즘은 매우 간단합니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["﹥복사( ",(0,r.jsx)(N,{text:"copy"}),") 능력을 갖는 스칼라 값은 복사(",(0,r.jsx)(N,{text:"copy"}),")로 처리됩니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["    ⇥참조자 ( ",(0,r.jsx)(N,{text:"가변 &mut 및 불변 &"}),") 는 복사( ",(0,r.jsx)(N,{text:"copy"}),")로 처리됩니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"﹥ 다만, 예측 가능한 대여 검사 오류를 위해 특수한 상황에서 이동(move)으로 처리될 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["﹥다른 모든 값은 이동( ",(0,r.jsx)(N,{text:"move"}),")으로 처리됩니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["    ⇥이는 다른 값들이 복사( ",(0,r.jsx)(N,{text:"copy"}),") 능력을 가질지라도, 프로그래머가 명시적으로 복사를 해주어야 한다는 것을 의미합니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"    ⇥이는 실수로 큰 데이터 구조체를 복사하는 것을 방지하기 위한 것입니다."})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  let s = b"hello";\n  let foo = Foo { f: 0 };\n  let coin = Coin { value: 0 };\n  \n  let s2 = s; // move\n  let foo2 = foo; // move\n  let coin2 = coin; // move\n  \n  let x = 0;\n  let b = false;\n  let addr = @0x42;\n  let x_ref = &x;\n  let coin_ref = &mut coin2;\n  \n  let x2 = x; // copy\n  let b2 = b; // copy\n  let addr2 = @0x42; // copy\n  let x_ref2 = x_ref; // copy\n  let coin_ref2 = coin_ref; // copy'})})]}),P=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"평등"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move는 ==와 !=라는 두 가지 동등성 연산을 지원합니다."})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"==",작업:"qual",설명:"만약 두 피연산자가 동일한 값을 가지고 있다면 true를 반환하고, 그렇지 않으면 false를 반환합니다."},{통사론:"!=",작업:"not qual",설명:"만약 두 피연산자가 서로 다른 값을 가지고 있다면 true를 반환하고, 그렇지 않으면 false를 반환합니다."}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.작업}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"타이핑"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"같음(==) 및 같지 않음(!=) 연산은 두 피연산자가 동일한 유형이어야만 작동합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  0 == 0; //true\n  1u128 == 2u128; //false\n  b"hello" != x"00"; //true\n'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"사용자 정의된 유형에 대해서도 같음(==)과 같지 않음(!=) 연산이 작동합니다!"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:'  address 0x42 {\n    module example {\n        struct S has copy,drop {\n            f:u64,\n            s:vector<u8>\n        }\n        fun alwats_true():bool {\n            let s= S {\n                f:0,\n                s:b""\n            };\n            //괄호는 필요하지 않지만 이 예시에서 명확성을 위해 추가되었습니다.\n            (copy s) == s\n        }\n        fun alwats_false():bool {\n            let s = S {\n                f:0,\n                s:b""\n            };\n            //괄호는 필요하지 않지만 이 예시에서 명확성을 위해 추가되었습니다.\n            (copy s) != s\n        }\n    }\n}\n'})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"피연산자가 서로 다른 유형을 가지고 있다면, 유형 검사 오류가 발생합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  1u8 == 1u128; // 오류!\n  //     ^^^^^ 'u8' 유형의 인수가 필요합니다.\n  b\"\" != 0; // 오류!\n  //     ^ 'vector<u8>' 유형의 인수가 필요합니다.\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"참조를 사용한 유형 지정"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"참조를 비교할 때 참조의 유형(불변 또는 가변)은 중요하지 않습니다. 즉, 동일한 기저 유형의 불변한 & 참조와 가변한 &mut 참조를 비교할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let i = &0;\n        let n = &mut 1;\n        i == m;//false\n        m == i;//false\n        m == m;//true\n        i == i;//true\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위 내용은 필요한 경우 각 가변 참조에 명시적인 freeze를 적용하는 것과 동일합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let i = &0;\n        let m = &mut 1;\n\n        i == freeze(m); //false\n        freeze(m) == i;//false\n        m == m;//true\n        i == i;//true\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다시 말씀드리면, 기저 유형은 동일한 유형이어야 합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let i = &0;\n        let s = &b\"\";\n\n        i == s;//오류\n        //   ^ '&u64' 유형의 인수가 필요합니다.\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제약사항(제한 사항)"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"== 및 != 모두 비교 시 값을 소비합니다. 결과적으로, 유형 시스템은 해당 유형이 drop을 가져야 한다는 사실을 강제합니다. drop 능력이 없으면 함수가 종료될 때 소유권이 전달되어야 하며, 이러한 값은 선언된 모듈 내에서 명시적으로만 파괴될 수 있습니다. 이러한 값들이 직접적으로 == 또는 !=와 함께 사용된다면 값이 파괴되어 drop 능력의 안전성 보장이 깨질 것입니다!"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct Coin has store {\n            value: u64\n        }\n        fun invalid(c1:Coin,c2:Coin){\n            c1 == c2 //오류발생!!\n    //      ^^    ^^ 이러한 리소스들이 파괴될 것입니다!\n        }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그러나, 프로그래머는 값을 직접 비교하는 대신 값이 먼저 대여될 수 있으며, 참조 유형은 drop 기능을 가지고 있습니다. 예를 들어, 다음과 같습니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct Coin as store {\n            value:u64\n        }\n        fun swap_if_equal(c1:Coin,c2:Coin):(Coin,Coin) {\n            let are_equal = &c1 == &c2 ; //유효\n            if (are_equal) (c2,c1) else (c1,c2)\n        }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"추가적인 복사는 피해야 합니다"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"프로그래머는 drop이 있는 모든 유형의 값을 비교할 수 있지만, 복사 비용이 큰 경우 참조를 사용하여 비교하는 것이 좋습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let v1: vector<u8>= function_that_returns_vector();\n        let v2: vector<u8>= function_that_returns_vector();\n        assert!(copy v1 == copy v2, 42);\n         //     ^^^^       ^^^^\n        use_two_vectors(v1,v2);\n\n        let s1: Foo = function_that_returns_large_struct();\n        let s2: Foo = function_that_returns_large_struct();\n        assert!(copy s1 == copy s2, 42);\n         //     ^^^^       ^^^^\n        use_two_foos(s1, s2);\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 코드는 완벽하게 허용됩니다 (Foo가 drop을 가진다고 가정할 때), 그러나 효율적이지는 않습니다. 강조된 복사본은 제거되고 대신 참조를 사용할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let v1: vector<u8> = function_that_returns_vector();\n        let v12 vector<u8> = function_that_returns_vector();\n        assert!(&v1 == &v2, 42);\n        //     ^      ^\n        use_two_vectors(v1, v2);\n\n\n        let s1:Foo= function_that_returns_large_struct();\n        let s2:Foo= function_that_returns_large_struct();\n        assert!(&s1 == &s2, 42);\n        //     ^      ^\n        use_two_foos(s1, s2);\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"== 연산 자체의 효율성은 동일하지만, 복사본은 제거되어 프로그램이 더 효율적이게 됩니다."})})})]})},R=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"Abort와 Assert"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"return과 abort는 실행을 종료하는 두 개의 제어 흐름 구조입니다. return은 현재 함수의 실행을 종료하고, abort는 전체 트랜잭션을 종료합니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Abort"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"abort는 하나의 인수를 받는 표현식으로, u64 타입의 중단 코드를 의미합니다. 예를 들어:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        abort 42\n    }\n}\n"})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'abort 표현식은 현재 함수의 실행을 중단하고, 현재 트랜잭션에 의해 전역 상태에 가해진 모든 변경 사항을 되돌립니다. abort를 "catch"하거나 다른 방식으로 처리하는 메커니즘은 존재하지 않습니다.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'다행히도 Move에서는 트랜잭션은 "모두 또는 아무것도"의 원칙을 따르며, 트랜잭션이 성공한 경우에만 전역 스토리지에 대한 모든 변경 사항이 한 번에 이루어집니다. 이러한 트랜잭션의 변경 사항 커밋 기능으로 인해, 중단된 후에는 변경 사항을 되돌리는 작업에 대해 걱정할 필요가 없습니다. 이 접근 방식은 유연성이 부족하지만 매우 간단하고 예측 가능합니다.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"abort는 return과 유사하게, 어떤 조건을 충족시킬 수 없을 때 제어 흐름을 종료하는 데 유용합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 예제에서는 함수가 벡터에서 두 개의 항목을 꺼내오지만, 벡터에 두 개의 항목이 없는 경우에는 중간에 실행을 중단할 것입니다."})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    fun pop_twice<T>(v:&mut vector<T>):(T,T){\n        if (vector::length(v)<2)abort 42;\n\n        (vector::pop_back(v),vector::pop_back(v))\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이는 제어 흐름 구조 내부에서 더욱 유용합니다. 예를 들어, 이 함수는 벡터 내의 모든 숫자가 지정된 한계 값보다 작은지 확인하고, 그렇지 않은 경우 중단합니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    fun check_vec(v:&vector<u64>,bound:u64){\n        let i = 0;\n        let n = vector::length(v);\n        while (i < n){\n            let cur = *vector::borrow(v,i);\n            if (cur>bound)abort 42;\n            i = i+1;\n        }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Assert"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"assert는 Move 컴파일러에서 제공하는 내장 매크로와 유사한 연산입니다. assert는 두 개의 인자를 받습니다. 첫 번째는 bool 타입의 조건(condition)이고, 두 번째는 u64 타입의 코드(code)입니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module exmaple::test {\n    fun main(){\n      assert!(condition: bool, code: u64)\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"assert는 매크로로 구현되어 있기 때문에 호출 시에는 느낌표(!)를 사용해야 합니다. 이는 assert의 인자가 표현식으로 호출되는 것을 나타내기 위한 것입니다. 다시 말해, assert는 일반적인 함수가 아니며 바이트코드 수준에서 존재하지 않습니다. 컴파일러 내부에서 번역되어 처리됩니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        if (continue) () else abort code\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"assert는 abort 단독으로 사용되는 것보다 더 일반적으로 사용됩니다. 위의 abort 예제들은 assert를 사용하여 다시 작성할 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    fun pop_twice<T>(v:&mut vector<T>):(T,T){\n        assert!(vector::length(v) >= 2,42);//이제 'assert'를 사용합니다.\n\n        (vector::pop_back(v),vector::pop_back(v))                \n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"and"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    fun check_vec(v:&vector<u64>,bound:u64){\n        let i = 0;\n        let n = vector::length(v);\n        while (i < n){\n            let cur = *vector::borrow(v,i);\n            assert!(cur <= bound ,42);//\n            i = i + 1;\n        }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"주의할 점은 해당 작업이 이렇게 if-else로 대체되기 때문에 코드의 인자가 항상 평가되지는 않는다는 것입니다. 예를 들어:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"   assert!(true,1/0)"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"산술 오류가 발생하지 않으며, 다음과 동등합니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"if (true) () else (1/0)"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"따라서 산술식은 평가되지 않습니다!"})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Move VM에서의 중단 코드"})})}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"abort를 사용할 때는 u64 코드가 VM에서 어떻게 사용되는지 이해하는 것이 중요합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 성공적인 실행 후에 Move VM은 전역 스토리지에 대한 변경 사항(리소스 추가/제거, 기존 리소스 업데이트 등)에 대한 변경 세트를 생성합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"중단(abort)이 발생하는 경우 VM은 오류를 나타내며, 해당 오류에는 두 가지 정보가 포함됩니다:"})})]}),(0,r.jsxs)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"    ⇥ 발생한 중단(abort)을 생성한 모듈(주소와 이름)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"    ⇥ 중단 코드"})})]}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"   address 0x42 {\n    module example {\n        public fun aborts(){\n            abort 42\n        }\n    }\n}\n\nscript {\n    fun always_abort() {\n        0x2::example::aborts()\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 위에서 언급한 스크립트인 always_aborts와 같은 트랜잭션이 0x2::example::aborts를 호출하면, VM은 모듈 0x2::example과 코드 42를 나타내는 오류를 생성합니다. 이는 모듈 내에서 여러 중단(abort)을 그룹화하는 데 유용할 수 있습니다. 이 예시에서는 모듈에 두 개의 별도 오류 코드가 있으며, 여러 함수에서 사용됩니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"   address 0x42 {\n    module example {\n        use std::vector;\n\n        const EMPTY_VECTOR : u64 = 0;\n        const INDEX_OUT_OF_BOUNDES:u64  = 1;\n\n        // move i to j, move j to k, move k to i\n        public fun rotate_three<T>(v:&mut vector<T>,i:u64,j:u64,k:u64){\n            let n = vector::length(v);\n            assert!(n>0,EMPTY_VECTOR);\n            assert!(i<n,INDEX_OUT_OF_BOUNDES);\n            assert!(j<n,INDEX_OUT_OF_BOUNDES);\n            assert!(k<n,INDEX_OUT_OF_BOUNDES);\n\n            vector::swap(v, i, k);\n            vector::swap(v, j, k);\n        }\n\n        public fun remove_twice<T>(v:&mut vector<T>,i:u64,j:u74):(T,T){\n           let n = vector::length(v); \n           assert!(n>0,EMPTY_VECTOR);\n           assert!(i<n,INDEX_OUT_OF_BOUNDES);\n           assert!(j<n,INDEX_OUT_OF_BOUNDES);\n           assert!(i>j,INDEX_OUT_OF_BOUNDES);\n           \n           (vector::remove<T>(v,i),vector::remove<T>(v,j))\n        }\n    } \n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"중단(abort)의 종류"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"abort 식은 어떤 타입이든 가질 수 있습니다! 이는 두 개의 구조 모두 일반적인 제어 흐름을 탈출하기 때문에 해당 타입의 값을 평가할 필요가 없기 때문입니다. 다음은 유용하지는 않지만 타입 체크를 통과할 것입니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"   module example::test {\n    fun main(){\n        let y:address = abort 0;\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 동작은 가지 분기 지시문에서 일부 분기에서 값이 생성되지만 다른 분기에서는 생성되지 않는 상황에서 유용할 수 있습니다. 예를 들어:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"   module example::test {\n    fun main(){\n        let b = \n             if(x==0)false\n             else if (x==1)true\n             else abort 42;\n               // ^^^^^^^^ abort 42의 타입은 bool입니다.\n    }\n}\n"})})]}),O=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"조건부"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"if 문은 특정 조건이 참일 때에만 코드를 실행해야 함을 명시하는 표현입니다. 예를 들어:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        if (x>5) x= x-5\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"조건은 bool 형식의 표현식이어야 합니다. if 표현식은 선택적으로 else 절을 포함할 수 있습니다. else 절은 조건이 거짓일 때 평가할 다른 표현식을 지정합니다. else 절은 if 표현식의 조건이 거짓인 경우 실행될 대체 코드 경로를 제공합니다. 다음은 예시입니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        if (x <= 5 ) y = y+1 else y = 10\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'if 표현식에서는 "참" 분기 또는 "거짓" 분기 중 하나가 평가되지만, 둘 다 평가되지는 않습니다. 각 분기는 단일 표현식 또는 표현식 블록일 수 있습니다. 조건부 표현식은 결과를 가질 수 있도록 값으로 평가될 수 있습니다. 따라서 if 표현식은 결과를 가집니다. 예를 들어:'})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n       let z = if (x < 100) x else 100;\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"참(True)과 거짓(False) 분기의 표현식은 호환 가능한 타입을 가져야 합니다. 예를 들어:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        // x와 y는 u64 정수여야 합니다.\n        let maximum:u64 = if(x>y) x else y;\n        // 오류! 분기가 다른 타입입니다.\n        let z= if (maximum <10 )10u8 else 100u64;\n        // 오류! 분기가 다른 타입입니다. 기본적으로 거짓 분기는 u64가 아닌 ()입니다.\n        if (maximum >= 10) maximum;\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 else 절이 지정되지 않은 경우, 거짓 분기는 기본적으로 unit 값으로 설정됩니다. 다음은 동등한 표현입니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        if (condition) true_branch\n        if (condition) true_branch else  ()\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로, 표현식 블록과 함께 if 표현식이 사용됩니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let maximum = if(x>y) x else y;\n        if (maximum <10){\n            x= x+10;\n            y= y+10;\n        }else if(x>-10 && y>=10){\n            x= x-10;\n            y= y-10;\n        }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"조건문의 문법"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"if-expression → if ( expression ) expression else-clauseopt else-clause → else expression"})})})]}),I=()=>(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"While과 Loop"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move는 두 가지 루핑 구조를 제공합니다: while과 loop입니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"While반복문"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"while 구조는 조건(타입이 bool인 표현식)이 거짓으로 평가될 때까지 본문(타입이 unit인 표현식)을 반복합니다. 다음은 1부터 n까지의 숫자의 합을 계산하는 간단한 while 루프의 예입니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun sum(n: u64): u64 {\n        let sum = 0;\n        let i = 1;\n        while (i <= n) {\n            sum = sum + i;\n            i = i + 1\n        };\n    \n        sum\n    }\n\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"무한 루프는 허용됩니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun foo() {\n        while (true) { }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Break"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"break 표현식은 조건이 거짓으로 평가되기 전에 루프를 종료하는 데 사용될 수 있습니다. 예를 들어, 다음 루프는 1보다 큰 n의 가장 작은 인수를 찾기 위해 break를 사용합니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun smallest_factor(n:u64):u64 {\n        //입력이 0 또는 1이 아닌 것으로 가정합니다.\n        let i = 2;\n        while (i <=n) {\n            if (n % i ==0 )break;\n            i = i + +1\n        }\n        i\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"break 표현식은 루프 외부에서 사용할 수 없습니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"continue"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"continue 표현식은 루프의 나머지 부분을 건너뛰고 다음 반복으로 진행합니다. 다음 예시의 루프는 숫자가 10으로 나누어떨어지지 않는 경우를 제외하고 1부터 n까지의 합을 계산하기 위해 continue를 사용합니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun sum_intermediate(n: u64): u64 {\n        let sum = 0;\n        let i = 0;\n        while (i < n) {\n            i = i + 1;\n            if (i % 10 == 0) continue;\n            sum = sum + i;\n        };\n    \n        sum\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"continue 표현식은 루프 외부에서 사용할 수 없습니다."})})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"break와 continue의 유형"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"break과 continue는 실제로 임의의 타입을 가질 수 있습니다. 다음 예제는 이러한 유연한 타입 지정이 도움이 되는 경우를 보여줍니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun pop_smallest_while_not_equal(\n        v1: vector<u64>,\n        v2: vector<u64>,\n    ): vector<u64> {\n        let result = vector::empty();\n        while (!vector::is_empty(&v1) && !vector::is_empty(&v2)) {\n            let u1 = *vector::borrow(&v1, vector::length(&v1) - 1);\n            let u2 = *vector::borrow(&v2, vector::length(&v2) - 1);\n            let popped =\n                if (u1 < u2) vector::pop_back(&mut v1)\n                else if (u2 < u1) vector::pop_back(&mut v2)\n                else break;//여기서 break는 u64 타입입니다.\n            vector::push_back(&mut result, popped);\n        };\n    \n        result\n    }\n    \n    \n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun pick(\n        indexes: vector<u64>,\n        v1: &vector<address>,\n        v2: &vector<address>\n    ): vector<address> {\n        let len1 = vector::length(v1);\n        let len2 = vector::length(v2);\n        let result = vector::empty();\n        while (!vector::is_empty(&indexes)) {\n            let index = vector::pop_back(&mut indexes);\n            let chosen_vector =\n                if (index < len1) v1\n                else if (index < len2) v2\n                else continue; //continue는 &vector<address> 타입입니다\n            vector::push_back(&mut result, *vector::borrow(chosen_vector, index))\n        };\n    \n        result\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Loop 표현식"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"루프 표현식은 루프 본문(타입이 ()인 표현식)을 반복해서 실행하며, break를 만날 때까지 계속됩니다. break 없이 루프가 계속되면, 루프는 영원히 계속됩니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun foo() {\n        let i = 0;\n        loop { i = i + 1 }\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음은 루프를 사용하여 합계 함수를 작성하는 예시입니다:"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun sum(n: u64): u64 {\n        let sum = 0;\n        let i = 0;\n        loop {\n            i = i + 1;\n            if (i > n) break;\n            sum = sum + i\n        };\n    \n        sum\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예상하신 대로, continue는 루프 내부에서도 사용할 수 있습니다. 이전에 사용한 while 대신 루프를 사용하여 위의 sum_intermediate 함수를 다시 작성해보겠습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun sum_intermediate(n: u64): u64 {\n        let sum = 0;\n        let i = 0;\n        loop {\n            i = i + 1;\n            if (i % 10 == 0) continue;\n            if (i > n) break;\n            sum = sum + i\n        };\n    \n        sum\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"while과 loop의 타입"})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"루프는 타입이 있는 표현식입니다. while 표현식은 항상 () 타입을 가집니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let () = while (i < 10) { i = i + 1 };\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 루프에 break문이 포함되어 있다면, 해당 표현식은 unit () 타입을 갖습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        (loop { if (i < 10) i = i + 1 else break }: ());\n        let () = loop { if (i < 10) i = i + 1 else break };\n    }\n}\n"})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"30px"},children:(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 루프에 break문이 없다면, return, abort, break, continue와 마찬가지로 루프는 어떤 타입이든 가질 수 있습니다."})})}),(0,r.jsx)(o.Z,{xs:12,md:12,sx:{marginTop:"0px"},children:(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        (loop (): u64);\n        (loop (): address);\n        (loop (): &vector<vector<u8>>);\n    }\n}\n"})})]}),q=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"함수"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move에서의 함수 구문은 모듈 함수와 스크립트 함수 간에 공유됩니다. 모듈 내부의 함수는 재사용 가능한 함수로 사용되며, 스크립트 함수는 트랜잭션을 호출하는 데 한 번만 사용됩니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"선언"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수는 fun 키워드를 사용하여 선언됩니다. 함수 선언은 함수 이름, 타입 매개변수, 매개변수, 반환 타입, 어카이어(획득) 어노테이션들, 그리고 마지막으로 함수 본문으로 구성됩니다."})}),(0,r.jsx)(g,{code:"  fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <acquires [identifier],*> <function_body>\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예를들어"})}),(0,r.jsx)(g,{code:"  fun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"가시성"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 함수는 기본적으로 동일한 모듈 내에서만 호출할 수 있습니다. 이러한 내부 함수(가끔은 private 함수라고도 함)는 다른 모듈이나 스크립트에서 호출할 수 없습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        fun foo(): u64 { 0 }\n        fun calls_foo(): u64 { foo() } // 유효\n    }\n    \n    module other {\n        fun calls_m_foo(): u64 {\n            0x42::m::foo() // 오류!\n    //      ^^^^^^^^^^^^ 'foo'는 '0x42::m' 내부에서만 사용 가능합니다.\n        }\n    }\n    }\n    \n    script {\n        fun calls_m_foo(): u64 {\n            0x42::m::foo() // 오류!\n    //      ^^^^^^^^^^^^ 'foo'는 '0x42::m' 내부에서만 사용 가능합니다.\n        }\n    }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다른 모듈이나 스크립트에서 접근할 수 있도록 하려면 함수를 public 또는 public(friend)로 선언해야 합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"public: 가시성 public 함수는 어떤 모듈이나 스크립트에서든지 호출할 수 있습니다. 다음 예시에서와 같이, public 함수는 다음과 같은 경우에 호출될 수 있습니다:"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"동일한 모듈에서 정의된 다른 함수에서,"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다른 모듈에서 정의된 함수에서,"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"스크립트에서 정의된 함수에서."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"또한 public 함수는 인수의 타입과 반환 타입에 대한 제한이 없습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        public fun foo():u64 {0}\n        fun calls_foo():u64 {foo()}//유효\n    \n    }\n\n    module other {\n        fun calls_m_foo():u64 {\n            0x42::m::foo()//유효\n        }\n    }\n}\nscript {\n    fun calls_m_foo():u64 {\n        0x42::m::foo() //유효\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"public(friend) 가시성 public(friend) 가시성 한정자는 함수를 사용할 수 있는 위치를 더 정밀하게 제어하기 위한 public 한정자의 제한된 형태입니다. public(friend) 함수는 다음과 같은 경우에 호출될 수 있습니다:"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"동일한 모듈에서 정의된 다른 함수에서,"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 목록에 명시적으로 지정된 모듈에서 정의된 함수에서 (친구 목록의 지정 방법은 Friends 문서를 참조하십시오)."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈을 친구로 지정하는 것은 스크립트를 친구로 지정할 수 없으므로, 스크립트에서 정의된 함수는 public(friend) 함수를 호출할 수 없습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        friend 0x42::n;  // friend 선언\n        public(friend) fun foo(): u64 { 0 }\n        fun calls_foo(): u64 { foo() } // 유효\n    }\n    \n    module n {\n        fun calls_m_foo(): u64 {\n            0x42::m::foo() // 유효\n        }\n    }\n    \n    module other {\n        fun calls_m_foo(): u64 {\n            0x42::m::foo() // 오류!\n    //       ^^^^^^^^^^^^ 'foo'는 모듈 '0x42::m'의 'friend'에서만 호출할 수 있습니다.\n    \n    \n    \n    \n        }\n    }\n    }\n    \n    script {\n        fun calls_m_foo(): u64 {\n            0x42::m::foo() // 오류!\n    //       ^^^^^^^^^^^^ 'foo'는 모듈 '0x42::m'의 'friend'에서만 호출할 수 있습니다.\n        }\n    }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"entry 한정자"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"entry 한정자는 모듈 함수를 스크립트와 마찬가지로 안전하고 직접적으로 호출할 수 있도록 설계되었습니다. 이를 통해 모듈 작성자는 어떤 함수가 실행을 시작할 수 있는지를 지정할 수 있습니다. 모듈 작성자는 비-entry 함수가 이미 실행 중인 Move 프로그램에서 호출될 것임을 알 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'기본적으로, entry 함수는 모듈의 "main" 함수로 생각할 수 있으며, Move 프로그램이 실행을 시작하는 지점을 지정합니다.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"하지만, entry 함수는 여전히 다른 Move 함수에 의해 호출될 수 있습니다. 따라서 Move 프로그램의 시작점으로 사용될 수는 있지만, 이에 제한되지는 않습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예를 들어:"})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        public entry fun foo():u64 {0}\n        fun calls_foo():u64 {foo()}//유효\n    }\n    \n    module n {\n        fun calls_m_foo():u64 {\n            0x42::m::foo()//유효\n        }\n    }\n\n\n    module other {\n        public entry fun calls_m_foo():u64 {\n            0x42::m::foo()//유효\n        }\n    }\n\n}\n\nscript {\n    fun calls_m_foo():u64 {\n        0x42::m::foo()//유효\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"심지어 내부 함수도 entry로 표시할 수 있습니다! 이를 통해 해당 함수가 실행의 시작 부분에서만 호출되는 것을 보장할 수 있습니다 (모듈 내 다른 곳에서 호출하지 않는다고 가정할 경우). 예를 들어:"})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        entry fun foo():u64 {0}//// 유효! entry 함수는 public이 필요하지 않습니다.\n    }\n\n    module n {\n        fun calls_m_foo():u64 {\n            0x42::m::foo()//오류 \n            // ^^^^^^^^^^^^ 'foo'는 '0x42::m' 내부에서만 사용 가능합니다.\n        }\n    }\n    \n    module other {\n        public entry fun calls_m_foo():u64 {\n            0x42::m::foo()//오류 \n            // ^^^^^^^^^^^^ 'foo'는 '0x42::m' 내부에서만 사용 가능합니다.\n        }\n    }\n}\nscript {\n    fun calls_m_foo():u64 {\n        0x42::m::foo()//오류 \n     // ^^^^^^^^^^^^ 'foo'는 '0x42::m' 내부에서만 사용 가능합니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"entry 함수는 원시 타입, String, vector와 같은 인수를 받을 수 있지만, Struct (예: Option)는 받을 수 없습니다. 또한, entry 함수는 반환값을 가져서는 안 됩니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Name"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수 이름은 첫 번째 문자로 a부터 z까지의 소문자 또는 A부터 Z까지의 대문자를 사용할 수 있습니다. 첫 번째 문자 이후에는 밑줄 _, a부터 z까지의 소문자, A부터 Z까지의 대문자 또는 숫자 0부터 9까지의 문자를 포함할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun FOO(){}\n    fun bar_42(){}\n    fun _bAZ19(){}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"타입 매개변수 (Type Parameters)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이름 이후에 함수에는 타입 매개변수(Type Parameters)가 올 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun id<T>(x:T):T {x}\n    fun example<T1:copy,T2>(x:T1,y:T2):(T1,T1,T2){(copy,x,x,y)}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"매개변수 (Parameters)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수 파라미터는 로컬 변수 이름 다음에 타입 어노테이션을 사용하여 선언됩니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun add(x:u64,y:u64):u64 {x+y}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'이것을 "x는 u64 타입을 갖는다"로 읽습니다. 함수는 전혀 파라미터를 가지지 않을 수도 있습니다.'})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun useless(){}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이것은 새로운 데이터 구조를 생성하거나 비어있는 데이터 구조를 만드는 함수에서 매우 흔히 사용됩니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example{\n        struct Counter {\n            count:u64\n        }\n        fun new_counter():Counter {\n            Counter {count:0}\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"획득자"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수가 move_from, borrow_global 또는 borrow_global_mut을 사용하여 리소스에 접근할 때, 함수는 해당 리소스를 획득(acquires)한다고 표시해야 합니다. 이는 Move의 타입 시스템에서 전역 저장소로의 참조가 안전하다는 것을 보장하기 위해 사용됩니다. 특히, 전역 저장소로의 끊어진 참조가 없는지 확인합니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct Balance has key {\n            value :u64\n        }\n        public fun add_balance(s:&signer, value :u64){\n            move_to(s,Balance{value})\n        }\n\n        public fun extract_balance(addr:address ) :u64 acquires Balance {\n            let Balance {value}= move_from(addr);//acquires 필요\n            value\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 내에서 전이적인 호출(transitive calls)에 대해서도 acquires 어노테이션을 추가해야 합니다. 다른 모듈에서 이러한 함수를 호출할 때는 이러한 acquires 어노테이션을 추가할 필요가 없습니다. 왜냐하면 한 모듈은 다른 모듈에서 선언된 리소스에 접근할 수 없기 때문에 참조 안전성을 보장하기 위해 어노테이션이 필요하지 않습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        struct Balance has key {\n            value:u64\n        }\n       public fun add_balance(s:&signer) {\n        move_to(s,Balance{value})\n       }\n\n\n       public fun extract_balance(addr:address):u64 acquires Balance {\n            let Balance { value}= move_from(addr);//acquires 필요\n            value\n        }  \n        public fun extract_and_add(sender:address,receiver:&signer)acquires Balance {\n            let value = extract_balance(sender);//여기에서는 acquires가 필요합니다.\n            add_balance(receiver, value)\n\n        }\n    }\n}\naddress 0x42 {\n    module other {\n        fun extract_balance(addr:address):u64 {\n            0x42::example::extract_balance(addr)//acquires이 필요하지 않습니다.\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수는 필요한 만큼 많은 리소스를 획득할 수 있습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        use std::vector;\n\n        struct Balance has key { \n            value:u64\n        }\n\n        struct Box<T> has key {\n            items:vector<T>\n        }\n\n        public fun store_two<Item1:store,Item2:store>(\n            addr:address,\n            item1:Item1,\n            item2:Item2,\n        )acquires Balance ,Box {\n            let balance = borrow_global_mut<Balance>(addr);//acquires 필요\n            balance.value= balance.value - 2;\n            let box1=borrow_global_mut<Box<Item1>>(addr);//acquires 필요\n            vector::push_back(&mut box1.items,item1);\n            let box2= borrow_global_mut<Box<Item2>>(addr);//acquires 필요\n            vector::push_back(&mut box2,items,item2);\n        }\n\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"반환 유형"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"파라미터 이후에 함수는 반환 타입을 지정합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun zero():u64 {0}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"여기서 : u64는 함수의 반환 타입이 u64임을 나타냅니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"팁 함수는 입력 참조에서 유도된 경우 불변한 & 또는 가변한 &mut 참조를 반환할 수 있습니다. 주의해야 할 점은 이것은 함수가 인라인 함수인 경우가 아니라면 전역 저장소에 대한 참조를 반환할 수 없다는 것입니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"튜플을 사용하여 함수는 여러 개의 값을 반환할 수 있습니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun one_two_three(): (u64, u64, u64) {\n         (0, 1, 2) \n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 반환 타입이 명시되지 않은 경우, 함수의 암묵적인 반환 타입은 unit ()입니다. 다음 함수들은 동등합니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun just_unit(): () { () }\n    fun just_unit() { () }\n    fun just_unit() { }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"스크립트 함수는 반드시 unit () 타입의 반환 타입을 가져야 합니다:"})}),(0,r.jsx)(g,{code:"  script {\n    fun do_nothing(){\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'앞서 튜플 섹션에서 언급한 대로, 이러한 튜플 "값"은 가상적이며 실제 실행 시 존재하지 않습니다. 따라서 unit ()을 반환하는 함수는 실행 중에 어떤 값도 반환하지 않습니다. unit ()은 반환되지 않는다는 것을 나타내는 특별한 타입입니다.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"함수본문"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수의 본문은 표현식 블록(expression block)입니다. 함수의 반환 값은 시퀀스에서 마지막 값입니다."})}),(0,r.jsx)(g,{code:"  module examples::test {\n    fun example(): u64 {\n    let x = 0;\n    x = x + 1;\n    x // returns 'x'\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"네이티브 함수"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일부 함수는 본문이 명시되지 않고, 대신 가상 머신(VM)에서 본문을 제공하는 경우가 있습니다. 이러한 함수는 native로 표시됩니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"VM 소스 코드를 수정하지 않는 이상, 프로그래머는 새로운 네이티브 함수를 추가할 수 없습니다. 또한, 네이티브 함수는 표준 라이브러리 코드 또는 해당 Move 환경에서 필요한 기능에 사용되는 것이 의도되어 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"아마도 가장 많이 볼 수 있는 네이티브 함수는 vector와 같은 표준 라이브러리 코드에 있을 것입니다."})}),(0,r.jsx)(g,{code:"  module std::vector {\n    native public fun empty<Element>(): vector <Element>;\n    ...\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"함수 호출 (Calling)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수를 호출할 때, 이름은 별칭(alias)이나 완전한 정규 이름(fully qualified name)을 통해 지정할 수 있습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        public fun zero():u64 {0}\n    }\n}\n\nscript {\n    use 0x42::example::{Self,zero};\n    fun call_zero(){\n        0x42::example::zero();\n        example::zero();\n        zero();\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수를 호출할 때는 매개변수마다 인수를 제공해야 합니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        public fun takes_none():u64{0}\n        public fun takes_one(x:u64):u64 {x}\n        public fun takes_two(x:u64,y:u64):u64{x+y}\n        public fun takes_three(x:u64,y:u64,z:u64):u64 {x+y+z}\n    }\n}\n\nscript {\n    use 0x42::example;\n    fun call_all(){\n        example::takes_none();\n        example::takes_one(0);\n        example::takes_two(0,1);\n        example::takes_three(0,1,2);\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"타입 인수는 명시적으로 지정하거나 추론될 수 있습니다. 두 가지 호출은 동일합니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n       public fun id<T>(x:T):T{x}\n    }\n   }\n   script {\n       use 0x42::example;\n       fun call_all() {\n           example::id(0);\n           example::id<u64>(0);\n       }\n   }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"반환 값 (Returning Values)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'함수의 결과, 즉 "반환 값"은 함수 본문의 마지막 값입니다. 예를 들어, 다음과 같습니다:'})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun add(x:u64,y:u64):u64 {\n        x+y\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"앞서 언급한 대로, 함수의 본문은 표현식 블록(expression block)입니다. 표현식 블록은 여러 문장을 순차적으로 나열할 수 있으며, 블록의 마지막 표현식은 해당 블록의 값이 됩니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun double_and_add(x:u64,yPu64):u64 {\n        let double_x = x*2;\n        let double_y = y*2;\n        double_x + double_y\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"여기서 반환 값은 double_x + double_y입니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"return 표현식 (Return Expression)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수는 본문이 평가한 값을 암묵적으로 반환합니다. 그러나 함수는 명시적인 return 표현식을 사용할 수도 있습니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun f1():u64 {return 0}\n    fun f2():u64 {0}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 두 함수는 동등합니다. 약간 더 복잡한 예제에서는 함수가 두 개의 u64 값 차감하고, 두 번째 값이 너무 크면 일찍 0을 반환합니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun safe_sub(x:u64,y:u64):u64 {\n        if(x>y)return 0;\n        x-y\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["참고로, 이 함수의 본문은 ","if (y > x) 0 else x - y","와 같이 작성할 수도 있습니다. 그러나 return이 정말 빛을 발하는 것은 다른 제어 흐름 구조 내부에서 깊숙이 종료할 때입니다. 다음 예제에서는 함수가 벡터를 반복하여 주어진 값의 인덱스를 찾습니다:"]})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    use std::option::{Self,Option};\n    fun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n        let i = 0;\n        let n = vector::legnth(v);\n        while (i < n) {\n            if (vector::borrow(v,i) == target)return option::some(i);\n            i = i +1\n        };\n\n        option::none(i)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"return 키워드를 인자 없이 사용하는 것은 return ()의 약식 표현입니다. 즉, 다음 두 함수는 동일합니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo() { return }\n    fun foo() { return () }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"인라인 함수(Inline functions)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"인라인 함수(Inline functions)는 Move 바이트코드로 컴파일되는 대신 호출하는 쪽에서 확장되는 함수입니다. 이는 가스를 절약하고 실행 속도를 높일 수 있게 해줍니다. 예를 들어, 다음과 같이 인라인 함수를 정의할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    inline fun percent(x: u64, y: u64):u64 { x * 100 / y }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이제 percent(2, 200)을 호출할 때, 컴파일러는 사용자가 2 * 100 / 200으로 작성한 것처럼 함수 정의를 인라인으로 처리합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"함수 파라메타(Function Parameters)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"인라인 함수는 함수 매개변수를 지원합니다. 이를 통해 Move에서 일반적인 프로그래밍 패턴을 이해할 수 있는 고계 함수(higher-order functions)를 정의할 수 있습니다. 인라인 함수는 컴파일 시간에 확장되므로, 함수 매개변수의 이러한 기능을 Move 바이트코드에서 직접 지원하지 않더라도 지원할 수 있습니다. 다음은 vector 모듈에서 가져온 다음 함수를 고려해 봅시다. 번역"})}),(0,r.jsx)(g,{code:'  module example::test {\n    //주어진 코드는 주어진 컬렉션의 요소에 함수를 "접어"나가는 개념을 나타냅니다. 예를 들어, fold(vector[1,2,3], 0, f)는 f(f(f(0, 1), 2), 3)와 같이 실행됩니다.\n    public inline fun fold<Accumulator, Element>(\n        v:vector<Element>,\n        init:Accumulator,\n        f:|Accumulator,Element|Accumulator\n    ):Accumulator{\n        let accu = init;\n        foreach(v, |elem| accu = g(accu, elem));\n        accu\n    }\n}\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"여기서 foreach는 인라인 함수입니다. 일반적으로, 함수 매개변수로는 람다 표현식만 전달할 수 있습니다. 인라인 함수와 마찬가지로, 이러한 람다 표현식은 호출자 측에서 확장됩니다. 예시에서와 같이 람다는 컨텍스트 내의 변수에 접근할 수 있다는 점에 유의하세요. 예제에서는 변수 accu에 접근하고 있습니다."})})]})}),U=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"구조체 와 자원"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체(struct)는 타입화된 필드를 포함하는 사용자 정의 데이터 구조입니다. 구조체는 다른 구조체를 포함하여 모든 비참조(non-reference) 타입을 저장할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체 값이 복사될 수 없고 삭제될 수 없는 경우, 우리는 종종 해당 구조체 값을 자원(resource)으로 참조합니다. 이 경우 자원 값은 함수의 종료시에 소유권이 전달되어야 합니다. 이 특성은 자원을 전역 저장 스키마를 정의하거나 중요한 값을 표현하는 데 매우 유용하게 사용됩니다(예: 토큰)."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"기본적으로 구조체는 선형(linear)이고 일시적(ephemeral)입니다. 이는 구조체가 복사될 수 없고 삭제될 수 없으며, 전역 저장소에 저장될 수 없다는 것을 의미합니다. 이는 모든 값이 소유권이 전달되어야 한다는 것을 의미하며, 프로그램의 실행이 끝날 때까지 값들을 처리해야 한다는 것을 의미합니다. 우리는 구조체에 값을 복사하거나 삭제하고 전역 저장소에 저장하거나 전역 저장 스키마를 정의하는 능력을 부여함으로써 이 동작을 완화시킬 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"구조체(Structs) 정의하기"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체는 모듈 내부에서 정의되어야 합니다."})}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo {x:u64,y:bool}\n        struct Bar {}\n        struct Baz {foo:Foo,}\n        //                 ^ 참고: 끝에 쉼표(Trailing comma)가 있는 것도 괜찮습니다.\n    }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체는 재귀적으로 정의될 수 없으므로, 다음과 같은 정의는 올바르지 않습니다."}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Foo {x:Foo}\n   //              ^ 오류! Foo는 Foo를 포함할 수 없습니다.\n}\n"}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["앞서 언급한 대로, 기본적으로 구조체 선언은 선형적이고 일시적입니다. 따라서 값을 복사하거나 삭제하거나 전역 저장소에 저장하거나 저장 스키마로 사용하는 등의 작업에 값을 사용할 수 있도록 하려면, 구조체에 has"," <ability>"," 주석을 추가하여 구조체에 능력을 부여할 수 있습니다."]}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo has copy,drop {\n            x:u64,\n            y:bool\n        }\n    }\n}\n"})]}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"이름 짓기"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체는 반드시 영문 대문자 A부터 Z까지의 문자로 시작해야 합니다. 첫 글자 다음에는 밑줄(_), 영문 소문자 a부터 z까지의 문자, 영문 대문자 A부터 Z까지의 문자, 또는 숫자 0부터 9까지 포함될 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Foo {}\n    struct BAR {}\n    struct B_a_z_4_2 {}\n}\n\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"A부터 Z로 시작하는 이름 지정 제한은 향후 언어 기능을 위한 여지를 주기 위해 설정되었습니다. 이 제한은 나중에 제거될 수도 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"구조체(Structs) 생성"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'구조체 타입의 값을 생성하려면 구조체 이름을 지정하고, 각 필드에 대한 값들을 지정하여 "패킹"할 수 있습니다.'})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module m {\n        struct Foo has drop {x:u64,y:bool}\n        struct Baz has drop {foo:Foo}\n\n        fun example(){\n            let foo = Foo {x:0,y:false};\n            let baz = Baz {foo :foo};\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 필드와 동일한 이름을 가진 로컬 변수를 사용하여 구조체 필드를 초기화하려면 다음과 같은 축약형을 사용할 수 있습니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        //둘은 동등합니다\n        let baz = Baz {foo:foo};\n    \n        let baz= Baz {foo};\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'이를 종종 "필드 이름 퍼닝"이라고 부릅니다.'})}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo {\n            x:u64,\n            y:bool\n        }\n\n        struct Bar {\n            foo:Foo\n        }\n\n        struct Baz {\n\n        }\n\n        fun example_destroy_foo(){\n            let foo = Foo { x:3 ,y:false};\n            let Foo { x ,y:foo_y} = foo;\n            //        ^ x: x와 같은 축약형\n\n            // 두 개의 새로운 바인딩\n            //   x: u64 = 3\n           //    foo_y: bool = false\n        }\n\n        fun example_detroy_foo_wildcard(){\n            let foo = Foo{x:3,y:false};\n            let Foo {x,y:_}= foo;\n            // y가 와일드카드에 바인딩되었으므로 새로운 바인딩은 하나뿐입니다.\n            // x: u64 = 3\n        }\n\n        fun example_destroy_foo_assignment(){\n            let x= u64;\n            let y =bool;\n            Foo {x,y}= Foo{x:3,y:false};\n             // 기존 변수 x와 y를 변경합니다.\n             // x = 3, y = false\n\n        }\n\n        fun exmaple_foo_ref(){\n            let foo= Foo{x:3,y:false};\n            let Foo {x,y}=&foo;\n\n           // 두 개의 새로운 바인딩이 있습니다.\n           // x: &u64\n           // y: &bool\n        }\n\n        fun example_foo_ref_mut(){\n            let foo = Foo {x:3,y:false};\n            let Foo {x,y}= &mut foo;\n            // 두 개의 새로운 바인딩이 있습니다.\n            // x: &mut u64\n            // y: &mut bool\n        }\n\n        fun example_destroy_bar(){\n            let bar = Bar {foo:Foo{x:3,y:false}};\n            let Bar {foo:Foo {x,y}}= bar;\n                       // ^ 중첩된 패턴\n\n          // 두 개의 새로운 바인딩이 있습니다.\n          // x: u64 = 3\n          // y: bool = false\n        }\n\n        fun example_destroy_baz(){\n            let baz = Baz{};\n            let Baz {}= baz;\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"구조체와 필드 빌림"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"& 및 &mut 연산자는 구조체나 필드에 대한 참조를 생성하는 데 사용될 수 있습니다. 이 예시들은 몇 가지 선택적인 타입 어노테이션 (예: : &Foo)을 포함하여 작업의 타입을 보여주기 위해 포함되었습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo = Foo{x:3,y:true};\n        let foo_ref:&Foo = &foo;\n        let y= bool= foo_ref.y; // 구조체에 대한 참조를 통해 필드를 읽는 중입니다.\n        let x_ref:&u64 = &foo.x;\n\n        let x_ref_mut:&mut u64= &mut foo.x;\n        *x_ref_mut= 42;// 가변 참조를 통해 필드를 수정 중입니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"중첩된 구조체의 내부 필드를 빌릴 수 있습니다. ."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo= Foo{x:3,y:true};\n        let bar= Bar{foo};\n        \n        let x_ref= &bar.foo.x;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"또한 구조체에 대한 참조를 통해 필드를 대여할 수도 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo = Foo {x:3,y:true};\n        let foo_ref= &foo;\n        let x_ref= &foo_ref.x;\n        // 이는 let x_ref = &foo.x와 동일한 효과를 가지고 있습니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"필드 읽기와 쓰기"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 필드의 값을 읽고 복사해야 한다면, 대여한 필드를 역참조할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo = Foo {x:3,y:true};\n        let bar = Bar {foo:copy foo};\n        let x:u64 = *foo.x;\n        let y:bool = *&foo.y;\n        let foo2:Foo= *&bar.foo;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"필드가 암시적으로 복사 가능한 경우, 점 연산자를 사용하여 구조체의 필드를 대여하지 않고 읽을 수 있습니다. (복사 가능한 스칼라 값만 암시적으로 복사 가능합니다.)"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo =Foo{x:3,y:true};\n        let x= foo.x; //x==3\n        let y= foo.y; //y ==true;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"점 연산자는 연쇄적으로 사용하여 중첩된 필드에 접근할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let baz= Baz{ foo:Foo{x:3,y:true}};\n        let x= baz.foo.x;;//x= 3;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그러나 이는 벡터나 다른 구조체와 같은 비기본 타입을 포함하는 필드에 대해서는 허용되지 않습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo =Foo{x:3,y:true};\n        let bar= Bar {foo};\n        let foo2:Foo= *&bar.foo;\n        let foo3:Foo= bar.foo;// 오류! *&를 사용하여 명시적으로 복사를 추가해야 합니다.\n    }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 설계 결정의 이유는 벡터나 다른 구조체를 복사하는 것이 비용이 많이 들 수 있는 작업일 수 있기 때문입니다. 프로그래머는 이 복사 작업을 인식하고 다른 사람들도 명시적인 *& 구문을 통해 인식하도록 주의해야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"필드를 읽는 것 외에도, 점 구문을 사용하여 필드를 수정할 수 있습니다. 이는 필드가 기본 타입이든 다른 구조체이든 상관없이 가능합니다."})]}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n       let foo = Foo { x: 3, y: true };\n       foo.x = 42;     // foo = Foo { x: 42, y: true }\n       foo.y = !foo.y; // foo = Foo { x: 42, y: false }\n       let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }\n       bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }\n       bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }\n    }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 설계 결정의 이유는 벡터나 다른 구조체를 복사하는 것이 비용이 많이 들 수 있는 작업일 수 있기 때문입니다. 프로그래머는 이 복사 작업을 인식하고 다른 사람들도 명시적인 *& 구문을 통해 인식하도록 주의해야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"점 구문은 구조체에 대한 참조를 통해서도 동작합니다. ."})]}),(0,r.jsx)(g,{code:"  module example::test {\n    fun main(){\n        let foo = Foo {x:3,y:true};\n        let foo_ref= &mut foo;\n        foo_ref.x= foo_ref.x+1;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"특권 있는 구조체 작업"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체 타입 T에 대한 대부분의 구조체 작업은 T를 선언한 모듈 내에서만 수행할 수 있습니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'- 구조체 타입은 구조체를 정의한 모듈 내에서만 생성("패킹") 및 해제("언패킹")할 수 있습니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 구조체의 필드는 구조체를 정의한 모듈 내에서만 접근할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 규칙을 따르면, 모듈 외부에서 구조체를 수정하려면 해당 구조체를 위한 공개 API를 제공해야 합니다. 이 장의 마지막 부분에는 이에 대한 예제가 포함되어 있습니다. 그러나 구조체 타입은 항상 다른 모듈이나 스크립트에서 볼 수 있습니다."})]}),(0,r.jsx)(g,{code:"  //m.move\n  address 0x2 {\n      module m {\n        struct Foo has drop {x:u64}\n  \n        public fun new_foo() : Foo {\n            Foo { x : 42}\n        }\n      }\n  }\n"}),(0,r.jsx)(g,{code:"  //n.move\n  address 0x2 {\n      module n {\n          use 0x2::m;\n  \n          struct Wrapper has drop {\n              foo: m::Foo\n          }\n  \n          fun f1(foo: m::Foo){\n              let x= foo.x;\n              //      ^ 오류! 여기서 foo의 필드에 접근할 수 없습니다.\n          }\n  \n          fun f2(){\n              let foo_wrapper= Wrapper{foo:m::new_foo()}\n          }\n      }\n  }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"참고로, 구조체에는 가시성 수정자(예: public 또는 private)가 없습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위에서 언급한 대로, 구조체는 기본적으로 선형적이고 일시적입니다. 이는 구조체가 복사되거나 삭제되지 않는다는 것을 의미합니다. 이 특성은 돈과 같은 실제 세계 자원을 모델링할 때 매우 유용할 수 있습니다. 돈을 복제하거나 유통 중에 잃어버리지 않기를 원하기 때문입니다."})}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo { x:u64 }\n\n        public fun copying_resource(){\n            let foo = Foo {x:100};\n            let foo_copy= copy foo;//오류! '복사'는 '복사' 능력을 요구합니다.\n            let foo_ref = &foo;\n            let another_copy= *foo_ref//오류! 역참조는 '복사' 능력을 요구합니다.\n        }\n        public fun destroying_resource1(){\n            let foo = Foo{x:100};\n            // 오류! 함수가 반환되었을 때, foo는 여전히 값이 남아 있습니다.\n            // 이 파괴는 'drop' 능력을 요구합니다.\n        }\n        public fun destroying_resource2(f: &mut Foo) {\n           *f = Foo {x:100}//오류\n                           //과거 값을 파괴하기 위해 쓰기를 통해 'drop' 능력이 필요합니다.\n        }\n    }\n\n    \n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'두 번째 예제 (fun destroying_resource1)를 수정하려면 리소스를 수동으로 "언팩(unpack)"해야 합니다.'})}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo {x:u64}\n\n        public fun destroying_resource!_fixed(){\n            let foo = Foo {x:100};\n            let Foo {x:_}= foo;\n        }\n    }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"기억하시죠? 정의된 모듈 내에서만 리소스를 해체할 수 있다는 사실입니다. 이는 시스템에서 특정 불변식을 강제하는 데 활용될 수 있습니다. 예를 들어, 돈의 보존 등이 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"반대로, 만약 구조체가 가치 있는 것을 나타내지 않는다면, 복사(copy)와 삭제(drop) 능력을 추가하여 다른 프로그래밍 언어에서 익숙한 구조체 값을 얻을 수 있습니다."})]}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module m {\n        struct Foo has copy,drop {x:u64}\n\n        public fun run(){\n            let foo = Foo{x:100};\n            let foo_copy= copy foo;\n            // ^ 이 코드는 foo를 복사합니다. 반면, let x = foo 또는 let x = move foo는 모두 foo를 이동시킵니다.\n            let x= foo.x;//x= 100\n            let x_copy= foo_copy.x; //x=100\n\n            //함수가 반환될 때 foo와 foo_copy 모두 암묵적으로 폐기됩니다.\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"전역 저장소에 리소스 저장하기"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"영속적인 전역 저장소에 직접 저장할 수 있는 것은 키(key) 능력을 가진 구조체(structs) 뿐입니다. 이러한 키 구조체 내에 저장된 모든 값은 저장(store) 능력을 가져야 합니다. 자세한 내용은 능력(ability)과 전역 저장소(global storage) 장을 참조하십시오."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"예제들"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음은 가치 있는 데이터를 나타내기 위해 구조체를 사용하는 두 가지 간단한 예시입니다. Coin의 경우 가치 있는 데이터를, Point와 Circle의 경우 더 고전적인 데이터를 나타내는 방법을 보여줍니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Example 1: Coin"})}),(0,r.jsx)(g,{code:"  address 0x2{\n    module m {\n        //Coin이 복사되지 않도록 하고자 하기 때문에 \"돈\"을 복제하는 것은 바람직하지 않습니다. 따라서 구조체에 'copy' 능력을 부여하지 않습니다.\n        //마찬가지로, 프로그래머가 코인을 파괴하는 것을 원치 않기 때문에 구조체에 'drop' 능력을 부여하지 않습니다.\n        //그러나, 모듈 사용자가 이 코인을 영속적인 전역 저장소에 저장할 수 있기를 원하기 때문에 구조체에 'store' 능력을 부여합니다. 이 구조체는 전역 저장소 내의 다른 리소스 내에만 존재하게 될 것이므로 'key' 능력은 부여하지 않습니다.\n        struct Coin has store {\n            value:u64,\n        }\n        public fun mint(value:u64):Coin{\n        //누구나 이 모듈을 사용하여 무한한 양의 코인을 발행하는 것을 방지하기 위해, 이 함수에는 액세스 제어(access control) 형태의 게이트(gate)를 구현해야 합니다.\n         Coin{value}\n        }\n        public fun withdraw(coin:&mut Coin,amount:u64):Coin{\n          assert!(coin.balance>=amount,1000);\n          Coin.value = coin.value -amount;\n          Coin {value:amount}\n        }\n        public fun deposit(coin:&mut Coin,other :Coin){\n            let Coin {value}= other;\n            coin.value= coin.value +value;\n        }\n\n        public fun split(coin:Coin,amount:u64):(Coin,Coin){\n            let other= withdraw(&mut coin,amount);\n            (coin,other)\n        }\n        public fun merge(coin1:Coin,coin2:Coin):Coin{\n            deposit(&mut coin1,coin2);\n            coin1\n        }\n        public fun destroy_zero(coin:Coin){\n            let Coin {value}= coin;\n            assert!(value == 0,1001);\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Example 2: Geometry"})}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module point {\n        struct Point has copy,drop,store {\n            x:u64,\n            x:u64\n        }\n\n        public fun new (x:u64,y:u64):Point {\n            Point {\n                x,y\n            }\n        }\n        public fun x(p:&Point):u64 {\n            p.x\n        }\n        public fun y(p:&Point):u64 {\n            p.y\n        }\n        \n        fun abs_sub(a:u64,b:u64):u64 {\n            if (a>b){\n                b - a\n            }else {\n                a - b\n            }\n        }\n        public fun dist_squared(p1:&Point,p2:&Point):u64 {\n            let dx= abs_sub(p1.x,p2.x);\n            let dy= abs_sub(p1.y,p2.y);\n            dx *dx +dy*dy\n        }\n    }\n}\n"}),(0,r.jsx)(g,{code:"  address 0x2 {\n    module circle {\n        use 0x2::point::{Self,Point};\n\n        struct Circle has copy,drop,store {\n            center:Point,\n            redius:u64\n        }\n        public fun new(center:Point,redius:u64):Circle {\n            Circle{center,redius}\n        }\n\n        public fun overlaps(c1:&Circle,c2:&Circle):bool{\n          let d = point::dist_squared(&c1.center, &c2.center);\n          let r1 = c1.radius;\n          let r2 = c2.radius;\n          d*d <= r1*r1 + 2*r1*r2 + r2*r2\n        }\n    }\n}\n"})]})}),V=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"상수"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"상수(Constant)는 모듈 또는 스크립트 내에서 공유되는 정적인 값을 이름으로 지정하는 방법입니다. 상수의 값은 컴파일 시에 알려져야 합니다. 상수의 값은 컴파일된 모듈 또는 스크립트에 저장되며, 상수가 사용될 때마다 해당 값의 새로운 복사본이 생성됩니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"선언"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"상수 선언은 const 키워드로 시작하여 이름, 유형 및 값이 이어집니다. 상수 선언은 스크립트나 모듈 어디에서든 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    const <name>: <type> = <expression>;\n}\n"}),(0,r.jsx)(g,{code:"  script {\n    const MY_ERROR_CODE:u64 =0;\n\n    fun main(input :u64){\n        assert!(input >0,MY_ERROR_CODE);\n    }\n}\n\naddress 0x42 {\n    module exampe {\n        const MY_ADDRESS:address= @0x42;\n\n        public fun permissioned(s:&signer){\n            assert!(std::signer::address_of(s)==MY_ADDRESS,0);\n        }\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"이름지정"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"상수는 A부터 Z까지의 대문자로 시작해야 합니다. 첫 번째 글자 이후에는 밑줄(_), 소문자 a부터 z, 대문자 A부터 Z, 또는 숫자 0부터 9까지의 문자를 포함할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    const FLAG: bool = false;\n    const MY_ERROR_CODE: u64 = 0;\n    const ADDRESS_42: address = @0x42;\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"상수에는 소문자 a부터 z까지의 문자를 사용할 수 있지만, 일반적인 스타일 가이드는 각 단어 사이에 밑줄(_)을 사용하여 대문자 A부터 Z까지의 문자만 사용하는 것입니다. A부터 Z로 시작하는 이름 지정 제한은 향후 언어 기능을 위해 공간을 확보하기 위해 존재합니다. 나중에 제거될 수도 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"가시성"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"현재 public 상수는 지원되지 않습니다. const 값은 선언된 모듈에서만 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"유효한 표현식"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["현재 상수는 bool, u8, u16, u32, u64, u128, u256, address, 그리고 vector","<u8>",'와 같은 기본 타입에 제한됩니다. "string" 스타일 리터럴 이외의 다른 vector 값에 대한 미래 지원은 나중에 제공될 예정입니다.']})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"값"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로, 상수는 해당 유형의 간단한 값을 또는 리터럴을 할당받습니다. 예를 들어, 다음과 같습니다."})}),(0,r.jsx)(g,{code:'  module example::test {\n    const MY_BOOL:bool= false;\n    const MY_ADDRESS:address = @0x70DD;\n    const BYTES:vector<u8> =b"hello world";\n    const HEX_BYTES :vector<u8>= x"DEADBEEF";\n}\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"복잡한 표현식"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"리터럴 외에도, 상수에는 보다 복잡한 표현식을 포함할 수 있습니다. 단, 컴파일러가 표현식을 컴파일 시간에 값으로 축소할 수 있어야 합니다. 현재, 동등 연산, 모든 논리 연산, 모든 비트 연산, 그리고 모든 산술 연산을 사용할 수 있습니다"})}),(0,r.jsx)(g,{code:"  module example::test {\n    const RULE:bool = true && false;\n    const CAP:u64 = 10* 100+1;\n    const SHIFTY:u8= {\n        (1 <<1)*(1<<2) * (1 << 3) * (1 << 4)\n    };\n    const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\n    const REM: u256 = 57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\n    const EQUAL: bool = 1 == 1;\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 연산이 실행 시 예외를 발생시킬 경우, 컴파일러는 상수의 값을 생성할 수 없다는 오류를 발생시킵니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    const DIV_BY_ZERO: u64 = 1 / 0; // 오류!\n    const SHIFT_BY_A_LOT: u64 = 1 << 100; // 오류!\n    const NEGATIVE_U64: u64 = 0 - 1; // 오류!\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"현재로서는 상수가 다른 상수를 참조할 수 없습니다. 이 기능은 다른 표현식과 함께 나중에 추가될 예정입니다."})})]})}),X=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"일반화(Generics)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제네릭(Generic)은 서로 다른 입력 데이터 유형에 대해 함수와 구조체를 정의하는 데 사용될 수 있습니다. 이 언어 기능은 때때로 파라미터 다형성(parametric polymorphism)으로도 참조됩니다. Move에서는 종종 일반적으로 타입 매개변수(type parameter)와 타입 인자(type argument)와 같은 용어를 상호 교환하여 사용합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제네릭은 주로 벡터(vector)와 같은 라이브러리 코드에서 사용되며, 특정 제약 조건을 만족하는 모든 인스턴스에 대해 작동하는 코드를 선언하는 데 사용됩니다. 다른 프레임워크에서는 제네릭 코드를 사용하여 여러 가지 다른 방식으로 전역 저장소와 상호 작용할 수도 있지만, 그들은 여전히 동일한 구현을 공유합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"타입 매개변수(Type Parameters) 선언"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["함수와 구조체 모두 시그니처 내에서 각각의 타입 매개변수(Type Parameters) 목록을 받을 수 있습니다. 이는 각각의 타입 매개변수를 각괄호 ","<...>","로 감싸서 표현합니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Generic 함수"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"함수의 타입 매개변수는 함수 이름 뒤에 오고 (값) 매개변수 목록 앞에 위치합니다. 다음 코드는 제네릭한 항등 함수(identity function)를 정의합니다. 이 함수는 어떤 타입의 값을 받아들이고 그 값을 변경하지 않고 반환합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일단 정의되면, 타입 매개변수 T는 매개변수 유형(parameter types), 반환 유형(return types), 그리고 함수 본문 내에서 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun id<T>(x:T):T {\n        // 이 타입 주석은 필요하지 않지만 유효합니다.\n        (x:T)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일단 정의된 형식 매개변수 T는 매개변수 유형, 반환 유형 및 함수 본문 내에서 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제네릭 구조체(Generic Structs)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체의 형식 매개변수는 구조체 이름 뒤에 배치되며, 필드의 형식을 지정하는 데 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Foo<T> has copy,drop{x:T}\n\n    struct Bar<T1,T2>has copy,drop {\n        x:T1,\n        y:vector<T2>,\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형식 인수(Type Arguments)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제네릭 함수 호출"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["제네릭 함수를 호출할 때는 각 형식 매개변수에 대한 형식 인수를 각괄호","(< >)","로 묶은 목록으로 지정할 수 있습니다."]})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo(){\n        let x = id<bool>(true);\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"형식 인수를 지정하지 않으면 Move의 형식 추론 기능이 대신 형식 인수를 제공합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제네릭 구조체 사용"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제네릭 구조체의 값 생성 또는 해체 시에도, 제네릭 타입의 형식 매개변수에 대한 형식 인수 목록을 첨부할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo(){\n        let foo = Foo<bool>{x:true};\n        let Foo<bool>{x}= foo;\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"형식 인수를 지정하지 않으면 Move의 형식 추론 기능이 대신 형식 인수를 제공합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형식 인수 불일치"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"형식 인수를 지정하고 제공된 실제 값과 충돌하는 경우에는 오류가 발생합니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo(){\n        let x= id<u64>(true);//오류입니다! true는 u64 형식이 아닙니다.\n    }\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo(){\n        let foo = Foo<bool>{x:0};// 오류입니다! 0은 (bool) 형식이 아닙니다.\n        let Foo<address>{x}= foo;// 오류입니다! (bool)은 주소(address)와 호환되지 않습니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"형식 추론"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"대부분의 경우, Move 컴파일러는 형식 인수를 추론하여 명시적으로 작성하지 않아도 됩니다. 아래 예시에서 형식 인수를 생략한 경우를 보여드리겠습니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun foo(){\n        let x= id(true);\n         //      ^ <bool>가 추론됩니다.\n        let foo =Foo {x:true};\n           //      ^ <bool>가 추론됩니다.\n        let Foo{x}= foo;\n      //      ^ <bool>가 추론됩니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"참고: 컴파일러가 형식을 추론할 수 없는 경우에는 수동으로 형식을 주석으로 지정해야 합니다. 일반적인 시나리오는 반환 위치에서만 형식 매개변수가 나타나는 함수를 호출하는 경우입니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    using std::vector;\n\n    fun foo(){\n       // let v = vector::new();\n       //                   ^ 컴파일러가 원소의 형식을 결정할 수 없습니다.\n          let v = vector::new<u64>();\n          //                ^~~~~ 수동으로 주석을 추가해야 합니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그러나 만약 해당 반환 값이 함수 내에서 나중에 사용된다면, 컴파일러는 형식을 추론할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    using std::vector;\n\n    fun foo (){\n       let v= vector::new();\n       //               ^ <u64>가 추론됩니다.\n       vector::push_back(&mut v,42);\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"사용되지 않는 타입 매개변수"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체 정의에서 사용되지 않는 타입 매개변수란 구조체에서 정의된 필드에 나타나지 않지만 컴파일 시 정적으로 확인되는 매개변수를 말합니다. Move는 사용되지 않는 타입 매개변수를 허용하므로 다음과 같은 구조체 정의가 유효합니다:"})}),(0,r.jsx)(g,{code:"  struct Foo<T> {\n    foo: u64\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"특정 개념을 모델링할 때 이는 편리할 수 있습니다. 다음은 예시입니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    /// 통화 지정자\n    struct Currency1 {}\n    struct Currency2 {}\n/// 통화 지정자 타입을 사용하여 인스턴스화할 수 있는 제네릭한 코인 타입입니다.\n/// 예: Coin<Currency1>, Coin<Currency2> 등.\n    struct Coin<Currency1> has srotre {\n        value:u64\n    }\n// 모든 통화에 대해 일반적으로 코드를 작성하세요.\n    public fun mint_generic<Currency>(value:u64):Coin<Currency>{\n        Coin {value}\n    }\n// 한 가지 통화에 대해 구체적으로 코드를 작성하세요.\n    public fun mint_concreate(value:u64):Coin<Currency1>{\n        Coin {value}\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 예제에서, 구조체 Coin","<Currency>","은 Currency 타입 매개변수에 대해 제네릭하게 정의되어 있으며, 코인의 통화를 지정하고 코드를 통화에 관계없이 일반적으로 작성하거나 특정한 통화에 대해 구체적으로 작성할 수 있도록 합니다. 이 제네릭성은 Currency 타입 매개변수가 Coin에서 정의된 어떤 필드에도 사용되지 않더라도 적용됩니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"팬텀 타입 매개변수"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["위의 예시에서는 struct Coin이 저장 능력을 요구하지만 Coin","<Currency1>","이나 Coin","<Currency2>","는 저장 능력을 갖지 않습니다. 이는 조건부 능력과 제네릭 타입의 규칙, 그리고 Currency1과 Currency2가 저장 능력을 갖지 않기 때문입니다. 심지어 Currency1과 Currency2가 struct Coin의 본문에서 사용되지 않는다고 해도 그렇습니다. 이는 일부 불편한 결과를 초래할 수 있습니다. 예를 들어, 우리는 Coin","<Currency1>","을 전역 저장소의 지갑에 넣을 수 없게 됩니다."]}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["한 가지 해결책은 Currency1과 Currency2에 불필요한 능력 주석을 추가하는 것입니다 (즉, struct Currency1 has store ","). 그러나 이는 불필요한 능력 선언으로 인해 타입을 약화시킬 수 있는 버그나 보안 취약점을 초래할 수 있습니다. 예를 들어, 우리는 전역 저장소의 리소스가 Currency1 타입의 필드를 가질 것을 기대하지 않지만, 불필요한 저장 능력으로 이는 가능해질 수 있습니다. 게다가, 불필요한 주석은 전염성을 가지며, 사용되지 않는 타입 매개변수에 대해 일반화된 많은 함수들도 필요한 제약 조건을 포함해야 합니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"팬텀 타입 매개변수는 이 문제를 해결합니다. 사용되지 않는 타입 매개변수를 팬텀 타입 매개변수로 표시할 수 있으며, 이는 구조체의 능력 유도에 참여하지 않습니다. 이렇게 함으로써 팬텀 타입 매개변수의 인수는 제네릭 타입의 능력 유도에 고려되지 않으므로 불필요한 능력 주석이 필요하지 않게 됩니다. 이 완화된 규칙이 올바르게 적용되기 위해서는 Move의 타입 시스템이 팬텀으로 선언된 매개변수가 구조체 정의 내에서 전혀 사용되지 않거나, 팬텀으로 선언된 다른 타입 매개변수의 인수로만 사용된다는 것을 보장합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조체 정의에서 타입 매개변수 앞에 phantom 키워드를 추가하여 타입 매개변수를 팬텀으로 선언할 수 있습니다. 타입 매개변수가 팬텀으로 선언되면 팬텀 타입 매개변수라고 합니다. Move의 타입 체커는 구조체를 정의할 때, 모든 팬텀 타입 매개변수가 구조체 정의 내에서 사용되지 않거나, 팬텀 타입 매개변수에만 인수로 사용되는지를 확인합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"더 정확히 말하면, 타입이 팬텀 타입 매개변수의 인수로 사용되면 해당 타입은 팬텀 위치에 나타난다고 말합니다. 이 정의에 따라 팬텀 매개변수를 올바르게 사용하기 위한 규칙은 다음과 같이 명시될 수 있습니다: 팬텀 타입 매개변수는 팬텀 위치에만 나타날 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음 두 가지 예시는 팬텀 매개변수의 올바른 사용법을 보여줍니다. 첫 번째 예시에서는 매개변수 T1이 구조체 정의 내에서 전혀 사용되지 않습니다. 두 번째 예시에서는 매개변수 T1이 팬텀 타입 매개변수에 대한 인수로만 사용됩니다."})]}),(0,r.jsx)(g,{code:"  module example::test {\n    struct S1<phantom T1,T2>{f:u64}\n                   // ^^\n                   //올바름: T1은 구조체 정의 내에서 나타나지 않습니다.\n    struct S2<phantom T1,T2>{f:S1<T1,T2>}\n                               // ^^\n                               //올바름: T1은 팬텀 위치에 나타납니다.\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음 코드는 규칙을 위반하는 예시를 보여줍니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct S1<phantom T>{f:T} \n                         //^ 오류: 팬텀 위치가 아닙니다.\n\n    struct S2<T> { f: T }\n\n    struct S3<phantom T> { f: S2<T> }\n                               //^ 오류: 팬텀 위치가 아닙니다.\n\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["인스턴스화: 구조체를 인스턴스화할 때, 팬텀 매개변수에 대한 인수는 구조체의 능력 유도에서 제외됩니다. 예를 들어, 다음 코드를 살펴봅시다"," "]})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct S<T1,phantom T2> has copy {f:T1}\n    struct NoCopy {}\n    struct HasCopy has copy {}\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이제 타입 ","S<HasCopy, NoCopy>","를 살펴봅시다. S는 복사를 갖고 있고, 모든 팬텀이 아닌 인자는 복사를 갖고 있기 때문에","S<HasCopy, NoCopy>","도 복사를 갖습니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"능력 제약 조건이 있는 팬텀 타입: 매개변수 능력 제약 조건과 팬텀 타입 매개변수는 직교하는 기능입니다. 즉, 팬텀 매개변수는 능력 제약 조건과 함께 선언될 수 있습니다. 팬텀 타입 매개변수에 능력 제약 조건을 사용하여 인스턴스화할 때, 타입 인수는 해당 제약 조건을 만족해야 합니다. 예를 들어, 다음 정의는 완전히 유효합니다:"})]}),(0,r.jsx)(g,{code:"  module exmaple::test {\n    struct S <phantom T :copy> {}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적인 제약 조건이 적용되며, T는 복사를 갖는 인자로만 인스턴스화될 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제약 조건"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'위의 예제에서는 호출자가 나중에 삽입할 수 있는 "알 수 없는" 타입을 정의하기 위해 타입 매개변수를 사용하는 방법을 보여주었습니다. 그러나 이는 타입 시스템이 해당 타입에 대해 매우 보수적인 방식으로 검사를 수행해야 한다는 것을 의미합니다. 어떤 의미에서는, 타입 시스템은 제약이 없는 일반적인 타입 매개변수에 대해 최악의 경우를 가정해야 합니다. 간단히 말해서, 기본적으로 제네릭 타입 매개변수는 어떠한 능력도 가지지 않습니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"여기에서 제약 조건이 필요한 이유가 나타납니다. 제약 조건을 사용하면 이러한 알 수 없는 타입이 어떤 속성을 갖고 있는지를 지정할 수 있으므로, 타입 시스템은 그렇지 않으면 안전하지 않을 수 있는 작업을 허용할 수 있습니다."}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제약 조건 선언"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음 구문을 사용하여 타입 매개변수에 제약 조건을 설정할 수 있습니다."})}),(0,r.jsx)(g,{code:"  // T는 타입 매개변수의 이름입니다.\n  T: <ability> (+ <ability>)*\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["<ability>","는 네 가지 능력 중 하나일 수 있으며, 타입 매개변수는 동시에 여러 능력으로 제약 조건을 받을 수 있습니다. 따라서 다음과 같은 모든 타입 매개변수 선언은 유효합니다:"]})}),(0,r.jsx)(g,{code:"  T: copy\n  T: copy + drop\n  T: copy + drop + store + key\n"})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"제약 조건 확인"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제약 조건은 호출 지점에서 확인되므로 다음 코드는 컴파일되지 않습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Foo<T:Key> {x:T}\n   \n    struct Bar {x:Foo<u8>}\n    //                ^ 오류! u8에는 'key' 능력이 없습니다.\n    \n     struct Baz<T> { x: Foo<T> }\n    //                      ^ 오류! T에는 'key' 능력이 없습니다.\n\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    struct R {}\n \n    fun unsafe_consume<T>(x: T) {\n     // 오류! x에는 'drop' 능력이 없습니다.\n    }\n \n    fun consume<T: drop>(x: T) {\n     // 유효합니다!\n     // x는 자동으로 드롭됩니다.\n    }\n \n    fun foo() {\n     let r = R {};\n     consume<R>(r);\n     //      ^ 오류! R에는 'drop' 능력이 없습니다.\n }\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    struct R {}\n\n    fun unsafe_double<T>(x:T) {\n        (copy x,x)\n        // 오류! x에는 'copy' 능력이 없습니다.\n    }\n\n    fun double<T:copy>(x:T) {\n        (copy x,x)= //유효\n    } \n    \n    fun foo():(R,R) {\n        let r= R {};\n        double<R>(r)\n        //     ^ 오류! R에는 'copy' 능력이 없습니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"재귀에 대한 제한"})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"재귀적인 구조체"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제네릭 구조체는 동일한 타입의 필드를 직접 또는 간접적으로 포함할 수 없습니다. 심지어 다른 타입 인수를 사용하더라도 동일한 타입의 필드를 포함하는 모든 다음 구조체 정의는 잘못된 것입니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Foo<T> {\n        x:Foo<u64>// 오류! 'Foo'가 'Foo'를 포함하고 있습니다.\n    }\n\n    struct Bar<T> {\n        x:Bar<T>// 오류! 'Bar'가 'Bar'를 포함하고 있습니다.\n    }\n  // 오류! 'A'와 'B'는 사이클을 형성하여 허용되지 않습니다.\n    struct A<T> {\n        x:B<T,u64>\n    }\n\n    struct B<T1,T2>{\n        x:A<T1>\n        y:A<T2>\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"고급 주제: 타입 수준의 재귀"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 언어는 제네릭 함수를 재귀적으로 호출할 수 있게 허용합니다. 그러나 이를 제네릭 구조체와 함께 사용할 경우 특정한 경우에는 무한한 수의 타입이 생성될 수 있으며, 이를 허용하는 것은 컴파일러, 가상 머신 및 다른 언어 구성 요소에 불필요한 복잡성을 추가하는 것을 의미합니다. 따라서 이러한 재귀는 금지되어 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"허용되는 것:"})]}),(0,r.jsx)(g,{code:"  module example::test {\n    struct A<T>{}\n\n   // 유한한 수의 타입 -- 허용됩니다.\n   // foo<T> -> foo<T> -> foo<T> -> ...는 유효합니다.\n   fun foo<T>() {\n        foo<T>();\n    }\n    // 유한한 수의 타입 -- 허용됩니다.\n    // foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ...는 유효합니다.\n     fun foo<T>() {\n        foo<A<u64>>();\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"허용되지 않는 것:"})}),(0,r.jsx)(g,{code:"  module example:test {\n    struct A<T>{}\n    // 무한한 수의 타입 -- 허용되지 않습니다.\n    // 오류!\n    // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...\n    fun foo<T>() {\n        foo<A<T>>();\n    }\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    struct A<T> {}\n    // 무한한 수의 타입 -- 허용되지 않습니다.\n    // 오류!\n    // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>\n    // -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>\n    // -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>\n    // -> ...\n   fun foo<T1, T2>() {\n        bar<T2, T1>();\n    }\n\n    fun bar<T1, T2> {\n        foo<T1, A<T2>>();\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"참고로, 타입 수준의 재귀에 대한 체크는 호출 지점에 대한 보수적인 분석을 기반으로 하며, 제어 흐름이나 런타임 값은 고려하지 않습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct A<T>{}\n\n    fun foo<T>(n:u64) {\n        if (n>0){\n            foo<A<T>>(n-1);\n        };\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위의 예시에서 함수는 기술적으로는 주어진 입력에 대해 종료되며, 따라서 유한한 수의 타입만 생성됩니다. 그러나 Move의 타입 시스템에서는 여전히 이를 유효하지 않은 것으로 간주합니다."})})]})}),L=()=>{let e="  module example::test {\n    fun main(){\n        vector<T> has copy, drop, store;\n    }\n}\n",t="  module example::test {\n    struct NoAbilities {}\n    struct S has copy,drop {f:bool}\n    struct Cup<T> has copy,drop,store {item:T}\n\n    fun example(c_x:Cup<u64>,c_:Cup<S>) {\n        // 유효함, 'Cup<u64>'은 'u64'이 'copy'를 가지기 때문에 'copy'를 가집니다.\n        let c_x2 = copy c_x;\n       // 유효함, 'Cup<S>'는 'S'가 'copy'를 가지기 때문에 'copy'를 가집니다.\n        let c_s2 = copy c_s;\n    }\n\n    fun invalid(c_account:Cup<signer>,c_n:Cup<NoAbilities>){\n       // 유효하지 않음, 'Cup<signer>'은 'copy'를 가지지 않습니다.\n       // 'Cup'은 'copy'로 선언되었지만, 인스턴스는 'copy'를 가지지 않습니다.\n       // 이는 'signer'가 'copy'를 가지지 않기 때문입니다.\n       let c_account2= copy c_account;\n       // 유효하지 않음, 'Cup<NoAbilities>'은 'copy'를 가지지 않습니다.\n       // 'NoAbilities'가 'copy'를 가지지 않기 때문입니다\n       let c_n2= copy c_n;\n    }\n}\n";return(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"능력(Abilities)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'"Abilities"는 Move에서의 유형(type)에 따라 값들이 수행할 수 있는 동작을 제어하는 타이핑 기능입니다. 이 시스템은 값들의 "선형(linear)" 타이핑 동작과 값들이 전역 저장소에서 어떻게 사용되는지에 대한 세밀한 제어를 제공합니다. 이를 위해 특정 바이트코드 명령어에 대한 액세스를 제한하여 해당 바이트코드 명령어를 사용하기 위해서는 해당 기능(ability)이 필요합니다 (모든 명령어가 기능에 의해 제한되는 것은 아닙니다).'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'예를 들어, "Ability A allows a value to be stored in global storage"라는 문장은 "기능 A는 값이 전역 저장소에 저장될 수 있도록 허용합니다"라고 번역될 수 있습니다. 이는 Move에서 값을 전역 저장소에 저장하려면 특정 기능이 필요하다는 것을 의미합니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'따라서, "Abilities"는 Move에서 값들의 허용 가능한 동작을 제어하는 기능이며, 해당 값이 어떤 동작을 수행할 수 있는지를 선별적으로 조절합니다.'})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"네 가지 능력"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"copy 이 능력을 갖는 유형의 값들이 복사될 수 있도록 허용합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"drop 이 능력을 갖는 유형의 값들이 제거/버려질 수 있도록 허용합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"store 이 능력을 갖는 유형의 값들이 전역 저장소 내의 구조체에 존재할 수 있도록 허용합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"key 이 유형이 전역 저장소 작업에서 키(key)로서 사용될 수 있도록 허용합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["copy"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"복사 능력(copy ability)은 해당 능력을 갖는 유형의 값들이 복사될 수 있도록 허용합니다. 이는 복사 연산자를 사용하여 지역 변수에서 값을 복사하거나 참조를 통해 값들을 복사하는 작업에 대한 액세스를 제어합니다. 만약 한 값이 복사 능력을 갖는다면, 그 값 안에 포함된 모든 값들도 복사 능력을 가집니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일단 정의되면, 타입 매개변수 T는 매개변수 유형(parameter types), 반환 유형(return types), 그리고 함수 본문 내에서 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["drop"," "]})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'제거 능력(drop ability)은 해당 능력을 갖는 유형의 값들이 제거될 수 있도록 허용합니다. 여기서 "제거(dropped)"란 값이 전달되지 않고 Move 프로그램이 실행되는 동안 사실상 파괴되는 것을 의미합니다. 따라서 이 능력은 다음과 같은 여러 위치에서 값을 무시하는 능력을 제어합니다:'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 로컬 변수나 매개변수에서 값 사용하지 않기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 시퀀스 내에서 값 사용하지 않기 (예: ;를 통한 구분)"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 할당문에서 변수의 값 덮어쓰기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 참조를 통해 값을 기록할 때 값 덮어쓰기 (*e1 = e2)"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"한 값이 제거 능력을 갖는다면, 그 값 안에 포함된 모든 값들도 제거 능력을 가집니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["store"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"저장 능력(store ability)은 해당 능력을 갖는 유형의 값들이 전역 저장소 내의 구조체(리소스) 안에 존재할 수 있도록 허용하지만, 반드시 전역 저장소의 최상위 리소스로 존재할 필요는 없습니다. 이 능력은 직접적으로 작업을 제어하지 않습니다. 대신 키(key)와 함께 사용될 때 전역 저장소 내의 존재 여부를 제어합니다. 한 값이 저장 능력을 갖는다면, 그 값 안에 포함된 모든 값들도 저장 능력을 가집니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["key"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"키(key) 능력은 해당 유형이 전역 저장소 작업에서 키로 사용될 수 있도록 허용합니다. 이 능력은 모든 전역 저장소 작업을 제어하므로, move_to, borrow_global, move_from 등의 작업에서 유형을 사용하려면 해당 유형은 키 능력을 가져야 합니다. 이때 주의할 점은 작업은 키 유형이 정의된 모듈에서 사용되어야 한다는 것입니다 (어떤 의미에서는 작업은 정의하는 모듈에게만 공개된다고 볼 수 있습니다). 한 값이 키 능력을 가지면, 그 값 안에 포함된 모든 값들도 저장 능력을 갖게 됩니다. 이러한 비대칭성이 있는 유일한 능력입니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["내장된 타입들(Builtin Types)"," "]})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"대부분의 기본 내장 타입은 copy, drop, 그리고 store를 갖고 있습니다. 단, signer 타입은 drop만을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"bool, u8, u16, u32, u64, u128, u256, 그리고 address 타입은 copy, drop, 그리고 store를 갖고 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"signer 타입은 drop만을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"signer 타입은 복사되거나 전역 저장소에 넣을 수 없습니다."}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["vector<T>"," 타입은 T의 능력에 따라 copy, drop, 그리고 store를 갖을 수 있습니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"불변 참조 &와 가변 참조 &mut는 copy와 drop을 갖고 있습니다. 이는 참조 자체를 복사하고 제거하는 것을 의미하며, 참조 대상에 대한 복사와 제거가 아닙니다. 참조는 전역 저장소에 나타날 수 없으므로 store를 갖지 않습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"기본 내장 타입 중 어느 것도 key를 갖지 않으며, 이는 이들이 직접적으로 전역 저장소 작업과 함께 사용될 수 없음을 의미합니다."})]}),(0,r.jsx)(g,{code:e}),(0,r.jsx)(g,{code:t}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"구조체 능력"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["구조체가 특정 능력을 갖는다고 선언하려면, 구조체 이름 뒤에 필드들 앞에 ","has <ability>"," 형식으로 선언합니다. 예를 들어:"]})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Ignorable has drop {f:u64 }\n    struct Pair has copy, drop, store { x: u64, y: u64 }\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'이 경우에는 "Ignorable"은 drop 능력을 갖고 있고, "Pair"는 copy, drop, 그리고 store 능력을 갖고 있습니다. 이러한 능력들은 해당하는 작업에 대해 강력한 보장을 제공합니다. 해당 능력을 갖는 값에 대해서만 해당 작업을 수행할 수 있으며, 값이 다른 컬렉션의 깊은 내부에 중첩되어 있더라도 해당됩니다!'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"따라서 구조체의 능력을 선언할 때, 필드에 특정 요구 사항이 있습니다. 모든 필드는 이러한 제약 조건을 만족해야 합니다. 이 규칙은 구조체가 위에서 설명한 능력에 대한 도달성 규칙을 충족하도록 필요합니다. 구조체가 다음 능력과 함께 선언된 경우..."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"copy: 모든 필드는 copy를 가져야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"drop: 모든 필드는 drop을 가져야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"store: 모든 필드는 store를 가져야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"key: 모든 필드는 store를 가져야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"key는 현재 자기 자신을 필요로하지 않는 유일한 능력입니다."})]}),(0,r.jsx)(g,{code:"  module exampe::test {\n    // 능력을 갖지 않는 구조체\n     struct NoAbilities {}\n     struct WantsCopy hsa copy {\n         f:NoAbilities,, // 오류: 'NoAbilities'은 'copy'를 갖지 않습니다.\n     }\n }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"반대로, 예를 들어:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    // 능력을 갖지 않는 구조체\n    struct NoAbilities {}\n\n    struct MyResource has key {\n        f: NoAbilities, // 오류: 'NoAbilities'은 'store'를 갖지 않습니다.\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"조건부 능력 및 제네릭 유형"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"제네릭 타입에 능력이 주석 처리되면 해당 타입의 모든 인스턴스가 그 능력을 갖는 것이 보장되는 것은 아닙니다. 다음과 같은 구조체 선언을 고려해 봅시다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Cup<T> has copy, drop, store, key { item: T }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Cup이 능력과 상관없이 모든 유형을 보유할 수 있는 기능이 있다면 매우 유용할 것입니다. 타입 시스템은 타입 매개변수를 볼 수 있으므로, 해당 능력에 대한 보장을 위반하는 유형 매개변수를 발견하면 Cup에서 능력을 제거할 수 있어야 합니다. 이 동작은 처음에는 약간 혼란스러울 수 있지만, 컬렉션 유형에 대해 생각해보면 이해하기 쉬울 수 있습니다. 내장된 vector 타입의 다음과 같은 타입 선언을 고려해 볼 수 있습니다:"})}),(0,r.jsx)(g,{code:e}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"우리는 벡터가 모든 유형과 함께 작동하도록 원합니다. 서로 다른 능력에 대해 별도의 벡터 타입을 원하지 않습니다. 그렇기 때문에 우리가 원하는 규칙은 무엇일까요? 바로 앞에서 설명한 필드 규칙과 동일한 규칙입니다. 따라서, 내부 요소가 복사될 수 있는 경우에만 벡터 값 복사가 안전하고, 내부 요소가 무시/제거될 수 있는 경우에만 벡터 값 무시가 안전하며, 내부 요소가 전역 저장소에 존재할 수 있는 경우에만 벡터를 전역 저장소에 넣는 것이 안전합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 추가적인 표현성을 가지기 위해, 특정 타입은 해당 타입의 인스턴스화에 따라 선언된 능력을 모두 갖지 않을 수 있습니다. 대신, 타입이 갖게 될 능력은 선언과 타입 인자 모두에 따라 결정됩니다. 어떤 타입이든 타입 매개변수는 구조체 내에서 사용될 것으로 예상되므로, 능력은 타입 매개변수가 필드에 대한 요구 사항을 충족하는 경우에만 부여됩니다. 위에서 언급한 Cup을 예로 들면:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- Cup은 T가 copy를 갖는 경우에만 copy 능력을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- T가 drop를 갖는 경우에만 drop 능력을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- T가 store를 갖는 경우에만 store 능력을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- T가 store를 갖는 경우에만 key 능력을 갖습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"각 능력에 대한 이 조건부 시스템의 예시를 살펴보겠습니다:"})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"예시: 조건부 복사 (conditional copy)"})}),(0,r.jsx)(g,{code:t}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"예시: 조건부 제거 (conditional drop)"})}),(0,r.jsx)(g,{code:"  module exmaple::test {\n    struct NoAbilities {}\n    struct S has copy,drop {f:bool}\n    struct Cup<T>has copy,drop,store {item:T}\n\n    fun unused (){\n        Cup<bool>{item:true}//유효함, 'Cup<bool>'은 'drop'을 가집니다.\n        Cup<S> { item: S { f: false }};// 유효함, 'Cup<S>'는 'drop'을 가집니다.\n    }\n\n    fun left_in_local(c_account:Cup<signer>):u64 {\n        let c_b= Cup<bool>{item:true};\n        let c_s= Cup<S>{item:S{f:false}};\n       // 유효한 반환: 'c_account', 'c_b', 'c_s'는 값을 가지고 있으며\n       // 'Cup<signer>', 'Cup<bool>', 'Cup<S>'는 'drop'을 가집니다.\n        0\n    }\n\n    fun invalid_unused(){\n        // 유효하지 않음, 'Cup<NoAbilities>'을 무시할 수 없습니다. 'NoAbilities'는 'drop'을 가지지 않기 때문입니다.\n        // 'Cup'은 'drop'으로 선언되었지만, 인스턴스는 'drop'을 가지지 않습니다. 이는 'NoAbilities'가 'drop'을 가지지 않기 때문입니다.\n        Cup<NoAbilities>{item:NoAbilities{}};\n\n    }\n\n    fun invalid_left_in_local():u64 {\n        let n= Cup<NoAbilities>{item:NoAbilities{}};\n        // 유효하지 않은 반환: 'c_n'은 값이 있고 'Cup<NoAbilities>'는 'drop'을 가지지 않습니다.\n        0 \n    }\n\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"예시: 조건부 저장 (conditional store)"})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct Cup<T> has copy,drop,store{item:T}\n// 'MyInnerResource'는 'store'로 선언되어 있으므로 모든 필드가 'store'를 가져야 합니다.\n    struct MyInnerResource has store {\n        yes:Cup<u64>,// 유효함, 'Cup<u64>'은 'store'를 가집니다.\n// no: Cup<signer>, 유효하지 않음, 'Cup<signer>'는 'store'를 가지지 않습니다.\n    }\n\n    // 'MyResource'는 'key'로 선언되어 있으므로 모든 필드가 'store'를 가져야 합니다.\n    struct MyResource has key {\n        yes:Cup<u64>, // 유효함, 'Cup<u64>'은 'store'를 가집니다.\n        inner:Cup<MyInnerResource>\n// no: Cup<signer>, 유효하지 않음, 'Cup<signer>'는 'store'를 가지지 않습니다.\n\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"예시: 조건부 키 (conditional key)"})}),(0,r.jsx)(g,{code:"  module example::test {\n    struct NoAbilities {}\n    struct MyResource<T> has key {f:T}\n\n    fun valid(account:&signer) acquires MyResource {\n        let addr= signer::address_of(account);\n\n        let has_resource = exists<MyResource<u64>>(addr);\n        if(!has_resource){\n            move_to(account,MyResource<u64>{f:0})\n        };\n        let r= borrow_global_mut<MyResource<u64>>(addr)\n        r.f= r.f+1;\n\n    }\n\n\n    fun invalid(account: &signer) {\n    // 유효하지 않음, 'MyResource<NoAbilities>'은 'key'를 가지지 않습니다.\n    let has_it = exists<MyResource<NoAbilities>>(addr);\n    // 유효하지 않음, 'MyResource<NoAbilities>'은 'key'를 가지지 않습니다.\n    let NoAbilities {} = move_from<NoAbilities>(addr);\n    // 유효하지 않음, 'MyResource<NoAbilities>'은 'key'를 가지지 않습니다.\n    move_to(account, NoAbilities {});\n    // 유효하지 않음, 'MyResource<NoAbilities>'은 'key'를 가지지 않습니다.\n    borrow_global<NoAbilities>(addr);\n   }\n}\n"})]})})},Y=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"용도 및 별칭(Uses and Aliases )"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use 문법을 사용하여 다른 모듈의 멤버에 대한 별칭을 생성할 수 있습니다. use는 모듈 전체 또는 특정 표현식 블록 범위에 대해 지속되는 별칭을 생성하는 데 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"통사론(Syntax)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use 문법에는 여러 가지 다른 구문이 있습니다. 가장 간단한 것부터 시작하여 다른 모듈에 대한 별칭을 생성하는 다음과 같은 구문이 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use <address>::<module name>;\n    use <address>::<module name> as <module alias name>;\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    use std::vector as V;\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use std::vector;는 std::vector에 대한 별칭으로서 vector를 도입합니다. 이는 스코프 내에서 사용할 때 std::vector 대신에 vector를 사용할 수 있다는 의미입니다. use std::vector;는 use std::vector as vector;와 동일합니다. 마찬가지로 use std::vector as V;는 std::vector 대신 V를 사용할 수 있게 합니다."})}),(0,r.jsx)(g,{code:"  module examples::test {\n    use std::vector;\n    use std::vector as V;\n\n    fun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n       let v1 = std::vector::empty();\n       let v2 = vector::empty();\n       let v3 = V::empty();\n       (v1, v2, v3)\n    }\n    \n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"만약 특정한 모듈 멤버(함수, 구조체, 상수 등)를 가져오고 싶다면 다음과 같은 구문을 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use <address>::<module name>::<module member>;\n    use <address>::<module name>::<module member> as <member alias>;\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::empty;\n    use std::vector::empty as empty_vec;\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이렇게 하면 std::vector::empty 함수를 완전한 한정 없이 사용할 수 있습니다. 대신 각각 empty와 empty_vec을 사용할 수 있습니다. 다시 말하면, use std::vector::empty;는 use std::vector::empty as empty;와 동일합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::empty;\n    use std::vector::empty as empty_vec;\n\n    fun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {\n        let v1 = std::vector::empty();\n        let v2 = empty();\n        let v3 = empty_vec();\n        (v1, v2, v3)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"한 번에 여러 모듈 멤버에 대한 별칭을 추가하려면 다음과 같은 구문을 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use <address>::<module name>::{<module member>, <module member> as <member alias> ... };\n}\n"}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{push_back, length as len, pop_back};\n\n    fun swap_last_two<T>(v: &mut vector<T>) {\n        assert!(len(v) >= 2, 42);\n        let last = pop_back(v);\n        let second_to_last = pop_back(v);\n        push_back(v, last);\n        push_back(v, second_to_last)\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 멤버에 별칭을 추가하는 것 외에도 모듈 자체에 별칭을 추가해야 할 경우, Self를 사용하여 단일 use문에서 수행할 수 있습니다"})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{Self, empty};\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"명확하게 하기 위해, 다음은 모두 동등한 표현입니다:"})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector;\n    use std::vector as vector;\n    use std::vector::Self;\n    use std::vector::Self as vector;\n    use std::vector::{Self};\n    use std::vector::{Self as vector};\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"필요한 경우, 어떤 항목에 대해 원하는 만큼의 별칭을 가질 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{\n    Self,\n    Self as V,\n    length,\n    length as len,\n};\n\n    fun pop_twice<T>(v: &mut vector<T>): (T, T) {\n        // 위의 use 선언에 따른 모든 옵션 사용 가능\n        assert!(vector::length(v) > 1, 42);\n        assert!(V::length(v) > 1, 42);\n        assert!(length(v) > 1, 42);\n        assert!(len(v) > 1, 42);\n\n        (vector::pop_back(v), vector::pop_back(v))\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"모듈의 내부"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈 내부에서는 사용 선언의 순서에 관계없이 모든 use 선언을 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n        use std::vector;\n    \n        fun example(): vector<u8> {\n            let v = empty();\n            vector::push_back(&mut v, 0);\n            vector::push_back(&mut v, 10);\n            v\n        }\n    \n        use std::vector::empty;\n    }\n    }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'모듈 내에서 use로 선언된 별칭은 해당 모듈 내에서 사용할 수 있습니다. 또한, 도입된 별칭은 다른 모듈 멤버와 충돌하지 않아야 합니다. 자세한 내용은 "고유성(Uniqueness)"을 참조하십시오.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"표현식 내부"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use 선언을 어떤 표현식 블록의 시작 부분에 추가할 수 있습니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun example(): vector<u8> {\n        use std::vector::{empty, push_back};\n\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"let과 마찬가지로, 표현식 블록에서 use로 도입된 별칭은 해당 블록의 끝에서 제거됩니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun example(): vector<u8> {\n        let result = {\n            use std::vector::{empty, push_back};\n            let v = empty();\n            push_back(&mut v, 0);\n            push_back(&mut v, 10);\n            v\n        };\n        result\n    }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"블록이 끝난 후에 별칭을 사용하려고 시도하면 오류가 발생합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    fun example(): vector<u8> {\n    let result = {\n        use std::vector::{empty, push_back};\n        let v = empty();\n        push_back(&mut v, 0);\n        push_back(&mut v, 10);\n        v\n    };\n    let v2 = empty(); //오류\n//           ^^^^^ 바운드되지 않은 함수 'empty'\n    result\n}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use 문은 블록 내에서 첫 번째 항목이어야 합니다. use 문이 표현식이나 let 문 뒤에 나오면 구문 분석 오류가 발생합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    {\n    let x = 0;\n    use std::vector; // 오류!\n    let v = vector::empty();\n}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"이름 지정 규칙"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"별칭은 다른 모듈 멤버와 동일한 규칙을 따라야 합니다. 즉, 구조체나 상수에 대한 별칭은 A부터 Z로 시작해야 합니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module data {\n        struct S {}\n        const FLAG: bool = false;\n        fun foo() {}\n    }\n    module example {\n        use 0x42::data::{\n            S as s, // 오류!\n            FLAG as fLAG, // 오류!\n            foo as FOO,  // 유효\n            foo as bar, // 유효\n        };\n    }\n    }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["고유성"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"주어진 스코프 내에서 use 선언에 의해 도입된 모든 별칭은 고유해야 합니다. 모듈의 경우, use에 의해 도입된 별칭은 서로 겹치지 않아야 합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{empty as foo, length as foo}; // ERROR!\n//                                             ^^^ 중복된 'foo'\n\n\n   use std::vector::empty as bar;\n\n   use std::vector::length as bar; // 오류!\n   //                         ^^^ 중복된 'bar'\n\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"또한, 모듈의 다른 멤버와도 겹치지 않아야 합니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{empty as foo, length as foo}; // ERROR!\n//                                             ^^^ 중복된 'foo'\n\n\n   use std::vector::empty as bar;\n\n   use std::vector::length as bar; // 오류!\n   //                         ^^^ 중복된 'bar'\n\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"표현식 블록 내에서는 별칭끼리 겹치면 안 되지만, 외부 스코프에서의 다른 별칭이나 이름을 가려서 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Shadowing"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"표현식 블록 내에서 사용된 use 별칭은 외부 스코프의 이름(모듈 멤버 또는 별칭)을 가려서 사용할 수 있습니다. 로컬 변수의 가려짐과 마찬가지로, 가려짐은 표현식 블록의 끝에서 끝납니다."})}),(0,r.jsx)(g,{code:"  address 0x42 {\n    module example {\n    \n        struct WrappedVector { vec: vector<u64> }\n    \n        fun empty(): WrappedVector {\n            WrappedVector { vec: std::vector::empty() }\n        }\n    \n        fun example1(): (WrappedVector, WrappedVector) {\n            let vec = {\n                use std::vector::{empty, push_back};\n                // 'empty'는 이제 std::vector::empty을 가리킵니다.\n    \n                let v = empty();\n                push_back(&mut v, 0);\n                push_back(&mut v, 1);\n                push_back(&mut v, 10);\n                v\n            };\n            // 'empty'는 이제 Self::empty을 가리킵니다.\n            (empty(), WrappedVector { vec })\n        }\n    \n        fun example2(): (WrappedVector, WrappedVector) {\n            use std::vector::{empty, push_back};\n            let w: WrappedVector = {\n                use 0x42::example::empty;\n                empty()\n            };\n            push_back(&mut w.vec, 0);\n            push_back(&mut w.vec, 1);\n            push_back(&mut w.vec, 10);\n    \n            let vec = empty();\n            push_back(&mut vec, 0);\n            push_back(&mut vec, 1);\n            push_back(&mut vec, 10);\n    \n            (w, WrappedVector { vec })\n        }\n    }\n    }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"사용되지 않은 use 문 또는 별칭"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"사용되지 않는 use 문은 오류를 발생시킵니다."})}),(0,r.jsx)(g,{code:"  module example::test {\n    use std::vector::{empty, push_back}; // ERROR!\n    //                       ^^^^^^^^^ 사용되지 않은 별칭 'push_back'\n\n    fun example(): vector<u8> {\n        empty()\n    }\n}\n"})]})}),G=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h3",gutterBottom:!0,children:["Friends"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"friend 문법은 현재 모듈에서 신뢰할 수 있는 모듈을 선언하는 데 사용됩니다. 신뢰할 수 있는 모듈은 현재 모듈에서 public(friend) 가시성을 가진 모든 함수를 호출할 수 있습니다. 함수의 가시성에 대한 자세한 내용은 Functions 섹션의 가시성을 참조하십시오."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"친구 선언 (Friend declaration)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈은 friend 선언문을 통해 다른 모듈을 친구로 선언할 수 있습니다. 이는 다음과 같은 형식으로 사용됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- friend address::name - 아래 예시와 같이 완전한 모듈 이름을 사용한 친구 선언, 또는"})]}),(0,r.jsx)(g,{code:"  module 0x42::a {\n    friend 0x42::b;\n\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["- friend ","<module-name-alias>"," - use 문을 통해 도입된 모듈 이름 별칭을 사용한 친구 선언입니다."]})}),(0,r.jsx)(g,{code:"  module 0x42::a {\n    use 0x42::b;\n    friend b; \n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"한 모듈은 여러 개의 친구 선언을 가질 수 있으며, 모든 친구 모듈의 합집합은 친구 목록을 형성합니다. 아래 예시에서는 0x42::B와 0x42::C가 0x42::A의 친구로 간주됩니다."})}),(0,r.jsx)(g,{code:"  module 0x42::a {\n    friend 0x42::b;\n    friend 0x42::c;\n}\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"use 문과는 달리, friend는 표현식 블록 범위가 아닌 모듈 범위에서만 선언할 수 있습니다. friend 선언은 use, function, struct 등의 최상위 구조가 허용되는 위치에 배치할 수 있습니다. 그러나 가독성을 위해 friend 선언을 모듈 정의의 시작 부근에 배치하는 것이 권장됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 개념은 Move 스크립트에 적용되지 않습니다: Move 스크립트는 스크립트에서 정의된 함수를 호출하는 메커니즘이 없으므로 스크립트는 친구 모듈을 선언할 수 없습니다. Move 모듈도 스크립트를 친구로 선언할 수 없습니다. 스크립트는 일회성의 코드 조각이며 전역 저장소에 게시되지 않기 때문입니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"친구 선언 규칙"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 선언은 다음 규칙에 따릅니다: 모듈은 자신을 친구로 선언할 수 없습니다."})}),(0,r.jsx)(g,{code:" module 0x42::m {\n    friend Self;//오류\n    //     ^^^^ 모듈 자체를 친구로 선언할 수 없습니다.\n}\nmodule 0x43::m {\n    friend 0x42::M;//오류\n        // ^^^^^^^ 모듈 자체를 친구로 선언할 수 없습니다.\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 모듈은 컴파일러에서 알고 있어야 합니다."})}),(0,r.jsx)(g,{code:"  module 0x42::m { \n    friend 0x42::nonexistent; // ERROR! \n//   ^^^^^^^^^^^^^^^^^ 연결되지 않은 모듈 '0x42::nonexistent'입니다.\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 모듈은 동일한 계정 주소 내에 있어야 합니다. (참고: 이는 기술적인 요구사항이 아닌 정책 결정으로, 나중에 완화될 수 있습니다.)"})}),(0,r.jsx)(g,{code:"  module 0x42::m {\n}\n\nmodule 0x42::n{\n    friend 0x42::m;//오류\n//       ^^^^^^^ 현재 주소 외부의 모듈을 친구로 선언할 수 없습니다.\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"친구 관계에서는 순환 모듈 종속성을 생성할 수 없습니다. 친구 관계에서는 순환 사이클을 허용하지 않습니다. 예를 들어, 0x2::a가 0x2::b를 친구로 선언하고, 0x2::b가 0x2::c를 친구로 선언하고, 0x2::c가 다시 0x2::a를 친구로 선언하는 관계는 허용되지 않습니다. 일반적으로, 친구 모듈을 선언하면 친구 모듈은 현재 모듈에 대한 종속성이 추가됩니다 (친구가 현재 모듈의 함수를 호출하는 것이 목적이기 때문입니다). 만약 해당 친구 모듈이 이미 직접적으로나 간접적으로 사용되고 있다면, 종속성의 순환 사이클이 생성됩니다."})}),(0,r.jsx)(g,{code:"  module 0x2::a{\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a(){\n        c::c()\n    }\n}\n\nmodule 0x2::b{\n    friend 0x2::c;//오류\n        // ^^^^^^ 이 친구 관계는 종속성 사이클을 생성합니다: '0x2::b'는 '0x2::a'의 친구이며 '0x2::c'를 사용하고, '0x2::c'는 '0x2::b'의 친구입니다.\n}\n\nmodule 0x2::c {\n    public fun c(){}\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"한 모듈의 친구 목록에는 중복된 항목이 포함될 수 없습니다."})}),(0,r.jsx)(g,{code:"  module 0x42::a {}\n  module 0x42::m {\n      use 0x42::a as aliased_a;\n      friend aliased_a;//오류\n      // ^^^^^^^^^ 중복된 친구 선언 '0x42::a'입니다. 모듈 내의 친구 선언은 고유해야 합니다.\n  }\n"})]})}),H=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h3",gutterBottom:!0,children:["Packages"," "]})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"패키지를 사용하면 Move 프로그래머가 코드를 쉽게 재사용하고 프로젝트 간에 공유할 수 있습니다. Move 패키지 시스템을 사용하면 프로그래머가 다음을 쉽게 수행할 수 있습니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- Move 코드를 포함하는 패키지 정의하기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 이름이 지정된 주소에 의해 패키지 매개변수화하기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 다른 Move 코드에서 패키지를 가져오고 사용하기 및 이름이 지정된 주소를 인스턴스화하기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 패키지 빌드하고 패키지에서 관련 컴파일 아티팩트 생성하기"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 컴파일된 Move 아티팩트 주위에서 공통 인터페이스로 작업하기"})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"패키지 레이아웃과 매니페스트 구문"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 패키지 소스 디렉토리는 Move.toml 패키지 매니페스트 파일과 하위 디렉토리 세트를 포함합니다."})}),(0,r.jsx)(g,{code:"  a_move_package\n  ├── Move.toml      (required)\n  ├── sources        (required)\n  ├── examples       (optional, test & dev mode)\n  ├── scripts        (optional)\n  ├── doc_templates  (optional)\n  └── tests          (optional, test mode)\n  \n  \n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"필수로 표시된 디렉토리는 디렉토리가 Move 패키지로 간주되고 컴파일되기 위해 반드시 존재해야 합니다. 선택적인 디렉토리는 존재할 수 있으며, 그렇다면 컴파일 과정에 포함될 것입니다. 패키지가 빌드되는 모드에 따라 (테스트 또는 개발 모드), 테스트와 예제 디렉토리도 포함됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"sources 디렉토리에는 Move 모듈과 Move 스크립트 (트랜잭션 스크립트 및 스크립트 함수를 포함하는 모듈)를 모두 포함할 수 있습니다. examples 디렉토리는 컴파일 시에는 포함되지 않지만 개발 및/또는 튜토리얼 목적으로만 사용되는 추가 코드를 저장할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"scripts 디렉토리는 패키지 작성자가 원하는 경우 트랜잭션 스크립트를 모듈에서 분리할 수 있도록 지원됩니다. scripts 디렉토리는 항상 컴파일에 포함되며, doc_templates 디렉토리에 있는 문서 템플릿을 사용하여 문서를 작성할 수 있습니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Move.toml"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 패키지 매니페스트는 Move.toml 파일 내에 정의되며 다음과 같은 구문을 따릅니다. 선택적 필드는 *로 표시되고, +는 하나 이상의 요소를 나타냅니다:"})}),(0,r.jsx)(g,{code:'  [package]\n  name = <string> # 예: "MoveStdlib"\n  version = "<uint>.<uint>.<uint>" # 예: "0.1.1"\n  license* = <string> # 예: "MIT", "GPL", "Apache 2.0"\n  authors* = [<string>] # 예: ["Joe Smith (joesmith@noemail.com)", "Jane Smith (janesmith@noemail.com)"]\n  \n  [addresses]  # (선택적 섹션) 이 패키지에서 명명된 주소를 선언하고 패키지 그래프 내에서 명명된 주소를 인스턴스화합니다.\n  # 다음 형식으로 명명된 주소를 선언하는 하나 이상의 줄\n  <addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"\n  \n  [dependencies]  # (선택적 섹션) [addresses] 섹션과 동일하지만 "dev" 및 "test" 모드에서만 포함됩니다.\n  # 다음 형식으로 의존성을 선언하는 하나 이상의 줄\n  <string> = { local = <string>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # local dependencies\n  <string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # git dependencies\n  \n  [dev-addresses] # (선택적 섹션) [dependencies] 섹션과 동일하지만 "dev" 및 "test" 모드에서만 포함됩니다.\n  # 다음 형식으로 개발용 명명된 주소를 선언하는 하나 이상의 줄\n  <addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"\n  \n  [dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in "dev" and "test" modes\n  # 다음 형식으로 개발용 의존성을 선언하는 하나 이상의 줄\n  <string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }\n  \n  \n  \n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음은 로컬 의존성 하나와 git 의존성 하나가 포함된 최소한의 패키지 매니페스트의 예입니다."})}),(0,r.jsx)(g,{code:'  [package]\n  name = "AName"\n  version = "0.0.0"\n  \n  \n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음은 더 표준적인 패키지 매니페스트의 예시입니다. 이 예시에는 Move 표준 라이브러리가 포함되어 있으며, 주소 값이 0x1인 'Std'로부터 해당 주소 값을 인스턴스화합니다."})}),(0,r.jsx)(g,{code:' [package]\n  name = "AName"\n  version = "0.0.0"\n  license = "Apache 2.0"\n  \n  [addresses]\n  address_to_be_filled_in = "_"\n  specified_address = "0xB0B"\n  \n  [dependencies]\n  # Local dependency\n  LocalDep = { local = "projects/move-awesomeness", addr_subst = { "std" = "0x1" } }\n  # Git dependency\n  MoveStdlib = { git = "https://github.com/diem/diem.git", subdir="language/move-stdlib", rev = "56ab033cc403b489e891424a629e76f643d4fb6b" }\n  \n  [dev-addresses] # For use when developing this module\n  address_to_be_filled_in = "0x101010101"\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"패키지 매니페스트의 대부분 섹션은 자명한 것이지만, named addresses는 약간 이해하기 어려울 수 있으므로 더 자세히 살펴볼 가치가 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"컴파일 중의 명명된 주소(Named Addresses)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 언어는 명명된 주소(named addresses)를 가지며, 명명된 주소는 Move에서 선언할 수 없습니다. 따라서 지금까지는 명명된 주소와 그 값들을 컴파일러에게 명령줄 인자로 전달해야 했습니다. 그러나 Move 패키지 시스템을 사용하면 이제 이러한 과정이 필요하지 않으며, 패키지 내에서 명명된 주소를 선언하고, 스코프 내에서 다른 명명된 주소를 생성하고, Move 패키지 시스템 매니페스트 파일에서 다른 패키지의 명명된 주소를 이름 변경할 수 있습니다. 이를 개별적으로 살펴보겠습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"선언(Declaration)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예를 들어, example_pkg/sources/A.move 파일에 다음과 같은 Move 모듈이 있다고 가정해 봅시다."})}),(0,r.jsx)(g,{code:"  module named_addr::A {\n    public fun x(): address { @named_addr }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예시로, example_pkg/Move.toml 파일에서 명명된 주소인 named_addr을 두 가지 다른 방식으로 선언할 수 있습니다. 첫 번째 방식은 다음과 같습니다:"})}),(0,r.jsx)(g,{code:'  [package]\n  name = "ExamplePkg"\n  ...\n  [addresses]\n  named_addr = "_"\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"named_addr을 ExamplePkg 패키지의 명명된 주소로 선언하고, 이 주소는 유효한 어떤 주소 값이든 될 수 있다고 선언합니다. 따라서 가져오는 패키지는 named_addr의 값을 원하는 주소로 선택할 수 있습니다. 직관적으로 이를 ExamplePkg 패키지를 명명된 주소 named_addr로 매개변수화한다고 생각할 수 있으며, 이후 가져오는 패키지에 의해 해당 패키지가 나중에 인스턴스화될 수 있습니다. named_addr은 다음과 같이 선언될 수도 있습니다:"})}),(0,r.jsx)(g,{code:'  [package]\n  name = "ExamplePkg"\n  ...\n  [addresses]\n  named_addr = "0xCAFE"\n'}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이렇게 되면 named_addr이 정확히 0xCAFE인 명명된 주소로 선언되며, 변경할 수 없습니다. 이렇게 하면 다른 가져오는 패키지가 해당 명명된 주소를 사용할 때 정확한 값에 대해 걱정하지 않아도 됩니다. 이 두 가지 다른 선언 방법으로 인해 명명된 주소에 대한 정보가 패키지 그래프를 통해 흐를 수 있는 두 가지 방법이 있습니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'첫 번째 방법인 "할당되지 않은 명명된 주소(unassigned named addresses)"는 명명된 주소 값이 가져오는 위치에서 선언 위치로 흐를 수 있도록 합니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'두 번째 방법인 "할당된 명명된 주소(assigned named addresses)"는 명명된 주소 값이 선언 위치에서 패키지 그래프를 통해 상위 사용 위치로 흐를 수 있도록 합니다'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"패키지 그래프를 통해 명명된 주소 정보를 흐르게하는 이러한 두 가지 방법을 통해 스코핑과 명명(named addresses)에 대한 규칙이 중요해집니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"명명된 주소의 스코핑과 이름 변경"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"패키지 P에서 명명된 주소 N이 다음과 같은 경우에 스코프에 있습니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- N이 명명된 주소를 선언한 경우 또는"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- P의 전이 의존성(transitive dependencies) 중 하나의 패키지가 N을 선언하고 P와 N을 선언하는 패키지 사이에 패키지 그래프 상의 의존성 경로가 있고 N을 재명명하지 않은 경우."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'또한, 패키지 내의 모든 명명된 주소는 내보내집니다. 이로 인해 위의 스코핑 규칙과 함께 각 패키지는 가져올 때 스코프로 가져올 명명된 주소 세트가 있는 것으로 간주할 수 있습니다. 예를 들어, ExamplePkg 패키지를 가져온다면, 그 가져오기는 named_addr이라는 명명된 주소를 스코프로 가져올 것입니다. 이로 인해 P가 두 개의 패키지 P1과 P2를 가져오는 경우, P에서 N을 참조할 때 어떤 "N"을 의미하는지에 대한 모호성이 발생합니다. P1과 P2 모두에서 N을 선언하는 경우, 어느 패키지에서 N이 가져와지는지 애매해집니다. 이러한 명명된 주소가 어느 패키지에서 가져와지는지에 대한 모호성을 방지하기 위해 패키지의 모든 종속성이 소개하는 스코프 세트가 서로 겹치지 않도록 강제하고, 해당 패키지가 가져올 때 명명된 주소의 이름을 변경하는 방법을 제공합니다. P, P1 및 P2의 예에서 가져올 때 명명된 주소의 이름을 변경하는 방법은 다음과 같이 수행할 수 있습니다:'})]})," ",(0,r.jsx)(g,{code:'  [package]\n  name = "P"\n  ...\n  [dependencies]\n  P1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }\n  P2 = { local = "some_path_to_P2"  }\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 경우 N을 P2에서 가져오는 N으로 변경하고, P1N은 P1에서 가져오는 N을 가리킵니다:"})}),(0,r.jsx)(g,{code:"  module N::A {\n    public fun x(): address { @P1N }\n}\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 경우 N을 P2에서 가져오는 N으로 변경하고, P1N은 P1에서 가져오는 N을 가리킵니다:"})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"명명된 주소의 스코핑과 이름 변경"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'중요한 점은 명명된 주소의 이름 변경은 로컬하지 않다는 것입니다: 한 번 패키지 P에서 명명된 주소 N을 N2로 이름을 변경하면 P를 가져오는 모든 패키지는 N 대신에 N2만 볼 수 있으며, P 외부에서 N을 다시 도입하지 않는 한 N을 볼 수 없습니다. 이것이 스코핑 규칙(이 섹션의 시작 부분에 있는 규칙 (2))에서 "P와 N의 선언 패키지 사이의 패키지 그래프에서의 종속성 경로이며 N을 재명명하지 않은 상태"라고 명시하는 이유입니다'})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h3",gutterBottom:!0,children:["인스턴스화"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 패키지는 모든 명명된 주소가 값을 가리켜야만 컴파일할 수 있습니다. 이는 패키지가 초기화되지 않은 명명된 주소를 노출하려는 경우에 문제가 됩니다. 이것이 [dev-addresses] 섹션의 역할입니다. 이 섹션은 명명된 주소에 값을 설정할 수 있지만, 새로운 명명된 주소를 도입할 수는 없습니다. 또한, 개발 모드에서는 루트 패키지의 [dev-addresses]만 포함됩니다. 예를 들어, 다음 매니페스트를 가진 루트 패키지는 named_addr이 초기화되지 않았기 때문에 개발 모드 이외에서는 컴파일되지 않습니다:"})}),(0,r.jsx)(g,{code:'  [package]\n  name = "ExamplePkg"\n  ...\n  [addresses]\n  named_addr = "_"\n  \n  [dev-addresses]\n  named_addr = "0xC0FFEE"\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"사용법, 아티팩트 및 데이터 구조"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["Move 패키지 시스템은 Move CLI의 일부인 move"," <flags> <command> <command_flags>"," 형식의 명령 줄 옵션을 제공합니다. 특정 경로가 제공되지 않으면 모든 패키지 명령은 현재 작업 디렉토리에서 실행됩니다. Move CLI의 모든 명령과 플래그의 전체 목록은 move --help를 실행하여 확인할 수 있습니다."]})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"사용법"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"패키지는 Move CLI 명령 또는 Rust의 라이브러리 명령인 compile_package 함수를 통해 컴파일할 수 있습니다. 이를 통해 컴파일된 바이트코드와 소스 맵, 문서, ABI 등의 다른 컴파일 아티팩트가 메모리에 있는 CompiledPackage가 생성됩니다. 이 CompiledPackage는 OnDiskPackage로 변환하거나 그 반대로 변환할 수 있습니다. 후자는 CompiledPackage의 데이터를 파일 시스템에 다음과 같은 형식으로 배치한 것입니다:"})})," ",(0,r.jsx)(g,{code:"  a_move_package\n  ├── Move.toml\n  ...\n  └── build\n      ├── <dep_pkg_name>\n      │   ├── BuildInfo.yaml\n      │   ├── bytecode_modules\n      │   │   └── *.mv\n      │   ├── source_maps\n      │   │   └── *.mvsm\n      │   ├── bytecode_scripts\n      │   │   └── *.mv\n      │   ├── abis\n      │   │   ├── *.abi\n      │   │   └── <module_name>/*.abi\n      │   └── sources\n      │       └── *.move\n      ...\n      └── <dep_pkg_name>\n          ├── BuildInfo.yaml\n          ...\n          └── sources\n"})," ",(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"See the move-package crate for more information on these data structures and how to use the Move package system as a Rust library."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h3",gutterBottom:!0,children:["Using Bytecode for Dependencies"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move bytecode can be used as dependencies when the Move source code for those dependencies are not available locally. To use this feature, you will need co-locate the files in directories at the same level and then specify their paths in the corresponding Move.toml files."})})," ",(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"Requirements and limitations"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Using local bytecode as dependencies requires bytecode files to be downloaded locally, and the actual address for each named address must be specified in either Move.toml or through --named-addresses. Note, both aptos move prove and aptos move test commands, currently, do not support bytecode as dependencies."})})," ",(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"Recommended structure"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"We use an example to illustrate the dev flow of using this feature. Suppose we want to compile the package A. The package layout is:"})})," ",(0,r.jsx)(g,{code:"  ./A\n  ├── Move.toml\n  ├── sources\n    ├ AModule.move\n"})," ",(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"A.move is defined below, depending on the modules Bar and Foo:"})})," ",(0,r.jsx)(g,{code:"  module A::AModule {\n    use B::Bar;\n    use C::Foo;\n    public fun foo(): u64 {\n        Bar::foo() + Foo::bar()\n    }\n}\n"})," ",(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Suppose the source of Bar and Foo are not available but the corresponding bytecode Bar.mv and Foo.mv are available locally. To use them as dependencies, we would:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Specify Move.toml for Bar and Foo. Note that named addresses are already instantiated with the actual address in the bytecode. In our example, the actual address for C is already bound to 0x3. As a result, [addresses] must be specified C as 0x3, as shown below:"})]})," ",(0,r.jsx)(g,{code:'  [package]\n  name = "Foo"\n  version = "0.0.0"\n  [addresses]\n  C = "0x3"\n'})," ",(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Place the bytecode file and the corresponding Move.toml file in the same directory with the bytecode in a build subdirectory. Note an empty sources directory is required. For instance, the layout of the folder B (for the package Bar) and C (for the package Foo) would resemble:"})})," ",(0,r.jsx)(g,{code:"  ./B\n  ├── Move.toml\n  ├── sources\n  ├── build\n   ├ Bar.mv\n"}),(0,r.jsx)(g,{code:"  ./C\n  ├── Move.toml\n  ├── sources\n  ├── build\n    ├── Foo\n     ├──bytecode_modules\n       ├ Foo.mv\n"})," ",(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Specify [dependencies] in the Move.toml of the target (first) package with the location of the dependent (secondary) packages. For instance, assuming all three package directories are at the same level, Move.toml of A would resemble:"})})," ",(0,r.jsx)(g,{code:'  [package]\n  name = "A"\n  version = "0.0.0"\n  [addresses]\n  A = "0x2"\n  [dependencies]\n  Bar = { local = "../B" }\n  Foo = { local = "../C" }\n'})," ",(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Note that if both the bytecode and the source code of the same package exist in the search paths, the compiler will complain that the declaration is duplicated."})})," "]})}),W=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"Package Upgrades"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos 블록체인에서 Move 코드 (예: Move 모듈)는 업그레이드할 수 있습니다. 이는 코드 소유자와 모듈 개발자가 변경하지 않는 단일하고 안정적인 잘 알려진 계정 주소 아래에서 계약을 업데이트하고 발전시킬 수 있도록 합니다. 모듈 업그레이드가 발생하면 해당 모듈의 모든 사용자는 자동으로 최신 버전의 코드를 받게 됩니다 (예: 다음 상호작용 시간)."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos 블록체인은 기본적으로 다양한 업그레이드 정책을 네이티브로 지원합니다. 이를 통해 Move 개발자는 자신의 Move 코드가 어떻게 업그레이드될 수 있는지에 대한 제약 조건을 명시적으로 정의할 수 있습니다. 기본 정책은 하위 호환성을 가지고 있습니다. 이는 코드 업그레이드가 기존의 자원 저장소나 공개 API(포함하여 공개 함수)에 영향을 주지 않는 것을 보장하는 경우에만 허용된다는 것을 의미합니다. 이러한 호환성 확인은 Move의 강력한 타입 지정 바이트코드 세맨틱을 통해 가능합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그러나 호환되는 업그레이드조차도 응용 프로그램 및 종속된 Move 코드에 위험한 영향을 줄 수 있습니다(예: 기본 모듈의 의미론이 수정된 경우). 따라서, 개발자는 체인상에서 업그레이드할 수 있는 제3자 Move 코드에 의존할 때 주의해야 합니다. 자세한 내용은 종속성에 대한 보안 고려 사항을 참조하십시오."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"How it works"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos 블록체인에서의 Move 코드 업그레이드는 Move 패키지 단위로 이루어집니다. 패키지는 Move.toml 매니페스트에서 업그레이드 정책을 지정합니다."})}),(0,r.jsx)(g,{code:'  [package]\n  name = "MyApp"\n  version = "0.0.1"\n  upgrade_policy = "compatible"\n  ...\n  \n  \n'}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["How to upgrade"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이미 게시된 Move 코드를 업그레이드하려면, 해당 코드를 이전에 게시된 주소와 동일한 주소에 다시 게시하면 됩니다. 이를 위해 Aptos CLI를 사용하여 코드 컴파일 및 게시 지침을 따르면 됩니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"업그레이드 정책"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos에서 현재 지원하는 두 가지 다른 업그레이드 정책이 있습니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"호환 가능 (compatible): 이러한 업그레이드는 반드시 하위 호환성을 유지해야 합니다. 구체적으로 말하면:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"저장소(storage)의 경우, 새 코드에서는 이전 코드와 동일한 구조체 선언이여야 합니다. 이는 기존 저장소의 상태가 새 코드에 의해 올바르게 해석되도록 보장합니다. 그러나 새로운 구조체 선언은 추가될 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"API의 경우, 모든 기존의 공개 함수는 이전과 동일한 시그니처를 가져야 합니다. 새로운 함수, 공개 함수 및 진입 함수를 포함하여 추가될 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"불변 (immutable): 이 코드는 업그레이드할 수 없으며 영원히 동일하게 유지됨이 보장됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 정책들은 호환 가능 (compatible)이 불변 (immutable)보다 약한 정책으로 순서가 지정되어 있습니다. 즉, 호환 가능은 불변보다 약합니다. 체인상의 패키지 정책은 더 강력해질 수 있지만 약해질 수는 없습니다. 또한, 패키지의 모든 종속성의 정책은 해당 패키지의 정책보다 강력하거나 동일해야 합니다. 예를 들어, 불변 패키지는 호환 가능한 패키지를 직접적으로 또는 간접적으로 참조할 수 없습니다. 이는 사용자들에게 예상치 못한 업데이트가 발생하지 않을 것임을 보장해줍니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위 규칙에는 한 가지 예외가 있습니다: 주소 0x1부터 0xa에 설치된 프레임워크 패키지는 종속성 확인에서 제외됩니다. 이는 중요한 업그레이드와 수정을 허용하기 위해 호환 가능한 정책을 갖는 표준 라이브러리를 기반으로 불변 패키지를 정의할 수 있도록 필요합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"호환성 규칙은 다음과 같습니다"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"호환 가능한 업그레이드 정책을 사용할 때, 모듈 패키지는 업그레이드될 수 있습니다. 그러나 이전에 이미 게시된 기존 모듈에 대한 업데이트는 호환되어야 하며 아래의 규칙을 따라야 합니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"기존 구조체의 필드는 업데이트할 수 없습니다. 즉, 새로운 필드를 추가할 수 없으며, 기존 필드를 수정할 수도 없습니다. 구조체의 능력도 변경할 수 없습니다. (새로운 능력을 추가하거나 기존 능력을 제거할 수 없습니다.)"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모든 공개 함수와 진입 함수는 시그니처(인수 타입, 타입 인자, 반환 타입)를 변경할 수 없습니다. 그러나 인수의 이름은 변경할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"공개(friend) 함수는 비공개 함수로 취급되며, 따라서 그 시그니처는 임의로 변경될 수 있습니다. 이는 안전한 조치입니다. 왜냐하면 동일한 패키지에 있는 모듈만이 friend 함수를 호출할 수 있으며, 시그니처가 변경되면 해당 모듈도 업데이트되어야 하기 때문입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈을 업데이트할 때 호환되지 않는 오류가 발생하는 경우, 위에서 언급한 규칙을 확인하고 위반 사항을 수정해야 합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"종속성에 대한 보안 고려 사항은 다음과 같습니다:"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"위에서 언급한대로, 호환되는 업그레이드조차도 업그레이드된 코드에 의존하는 응용 프로그램에 치명적인 영향을 줄 수 있습니다. 이러한 영향은 버그로 인해 발생할 수도 있지만, 악의적인 업그레이드의 결과일 수도 있습니다. 예를 들어, 업그레이드된 종속성이 갑자기 모든 함수를 중단시키면 Move 코드의 작동이 중단될 수 있습니다. 또는 업그레이드된 종속성이 모든 함수를 실행하기 위해 이전보다 훨씬 많은 가스를 소비하도록 변경될 수도 있습니다. 이로 인해 업그레이드 가능한 패키지에 대한 종속성은 주의 깊게 처리되어야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"가장 안전한 종속성은 물론 불변 패키지입니다. 이는 종속성이 절대로 변경되지 않음을 보장하며, 이에 포함된 간접적인 종속성도 변경되지 않습니다. 불변 패키지를 업데이트하려면 소유자는 새로운 주요 버전을 도입해야 하며, 이는 사실상 새로운, 별도 및 독립된 패키지를 배포하는 것과 같습니다. 이는 주요 버전을 이름으로만 표현할 수 있기 때문에 가능합니다 (예: feature_v1 모듈과 feature_v2 모듈). 그러나 모든 패키지 소유자가 코드를 불변으로 게시하기를 원하지는 않을 수도 있습니다. 왜냐하면 이는 버그를 수정하고 코드를 현장에서 업데이트하는 능력을 제한하기 때문입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모든 공개 함수와 진입 함수는 시그니처(인수 타입, 타입 인자, 반환 타입)를 변경할 수 없습니다. 그러나 인수의 이름은 변경할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"호환 가능한 패키지에 종속성이 있는 경우, 해당 패키지를 게시하는 엔티티를 알고 이해하는 것이 매우 권장됩니다. 가장 높은 수준의 보장은 패키지가 탈중앙화 자율 조직(DAO)에 의해 관리되는 경우입니다. 이 경우, 단일 사용자가 업그레이드를 시작할 수 없으며 투표나 유사한 방식으로 진행되어야 합니다. 이는 Aptos 프레임워크의 경우입니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"프로그램적인 업그레이드(Programmatic upgrade)는"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 Aptos는 Move 모듈 aptos_framework::code를 통해 스마트 계약 내에서 어디에서든 코드를 게시할 수 있는 방법을 제공합니다. 그러나 현재 트랜잭션에서 게시된 코드는 해당 트랜잭션이 종료된 후에만 실행될 수 있습니다. 이는 트랜잭션이 완료되기 전까지는 새로운 코드가 적용되지 않음을 의미합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos 프레임워크 자체는 온체인 관리 로직을 포함하여 프로그램적인 업그레이드의 예입니다. 프레임워크는 호환 가능하게 표시되어 있습니다. 업그레이드는 특정 생성된 거버넌스 스크립트를 통해 이루어집니다. 자세한 내용은 Aptos 거버넌스를 참조하십시오."})]})]})}),K=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"단위 테스트"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move의 단위 테스트는 세 가지 새로운 주석을 Move 소스 언어에 추가합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"#[test]"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"#[test_only], and"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"#[expected_failure]."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"각각 함수를 테스트로 표시하는 #[test], 모듈 또는 모듈 멤버 (use, 함수 또는 구조체)를 테스트 전용 코드로 표시하는 #[test_only], 그리고 테스트가 실패할 것으로 예상되는 것을 표시하는 #[expected_failure]입니다. 이러한 주석들은 어떤 가시성을 갖는 함수에도 위치시킬 수 있습니다. 모듈 또는 모듈 멤버가 #[test_only] 또는 #[test]로 주석 처리되면, 해당 모듈이 테스트를 위해 컴파일되지 않는 한 컴파일된 바이트코드에 포함되지 않습니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["테스트 주석(Testing Annotations)"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"#[test]와 #[expected_failure] 주석은 인자가 있는 경우와 인자가 없는 경우 모두 사용할 수 있습니다. 인자가 없는 경우, #[test] 주석은 매개변수가 없는 함수에만 사용할 수 있습니다. 이 주석은 해당 함수를 테스트로 표시하여 유닛 테스트 도구에서 실행할 수 있도록 합니다."})}),(0,r.jsx)(g,{code:"  #[test] // OK\n  fun this_is_a_test() { ... }\n  \n  #[test] // Will fail to compile since the test takes an argument\n  fun this_is_not_correct(arg: signer) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["테스트는 #[expected_failure]로도 주석 처리될 수 있습니다. 이 주석은 해당 테스트가 오류를 발생시킬 것으로 예상된다는 것을 표시합니다. 특정 모듈에서 특정 중단 코드로 테스트가 중단되는지 확인하려면 #[expected_failure(abort_code = ","<code>",", location = ","<loc>",")]로 주석 처리하여 다른 중단 코드, 다른 모듈 또는 중단되지 않은 오류로 테스트가 실패하는 경우를 방지할 수 있습니다. 여기서 ","<loc>","는 Self(현재 모듈) 또는 정규화된 이름(vector::std와 같은)이 될 수 있습니다. #[test] 주석이 있는 함수만 #[expected_failure]로 주석 처리될 수 있다는 점에 유의하세요."]})}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["인수를 사용하는 경우, 테스트 주석은 다음과 같은 형식을 취합니다: #[test(","<param_name_1>","=","<address>",", ..., ","<param_name_n>","=","<address>",")]. 함수가 이와 같은 방식으로 주석 처리된 경우, 함수의 매개변수는 ","<param_name_1>",", ..., ","<param_name_n>","의 매개변수들의 순열이어야 합니다. 즉, 함수에서 발생하는 매개변수의 순서와 테스트 주석에서의 순서는 동일할 필요는 없지만, 이름으로 매칭되도록 일치해야 합니다."]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"테스트 매개변수로는 signer 타입을 갖는 매개변수만 지원됩니다. signer 타입이 아닌 매개변수가 제공된 경우, 테스트 실행 시 오류가 발생합니다."})]}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"모듈과 해당 멤버 중 일부는 테스트 전용으로 선언할 수 있습니다. 이 경우 해당 항목은 테스트 모드로 컴파일될 때만 컴파일된 Move 바이트코드에 포함됩니다. 또한, 테스트 모드가 아닌 컴파일에서는 #[test_only] 모듈의 비테스트 사용은 컴파일 중에 오류가 발생합니다."})}),(0,r.jsx)(g,{code:"  #[test_only] // test only attributes can be attached to modules\n  module abc { ... }\n  \n  #[test_only] // test only attributes can be attached to named addresses\n  address ADDR = @0x1;\n  \n  #[test_only] // .. to uses\n  use 0x1::some_other_module;\n  \n  #[test_only] // .. to structs\n  struct SomeStruct { ... }\n  \n  #[test_only] // .. and functions. Can only be called from test code, but not a test\n  fun test_only_function(...) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"단위 테스트 실행하기"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 패키지의 단위 테스트는 aptos move test 명령을 사용하여 실행할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"테스트를 실행할 때, 각 테스트는 PASS, FAIL 또는 TIMEOUT 중 하나의 결과를 가집니다. 테스트 케이스가 실패하는 경우, 가능한 경우 실패 위치와 실패 원인인 함수 이름이 보고됩니다. 아래에 이에 대한 예시가 나와 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"단일 테스트에 대해 실행할 수 있는 최대 명령어 수를 초과하는 경우 해당 테스트는 타임아웃으로 표시됩니다. 이 한계는 아래의 옵션을 사용하여 변경할 수 있으며, 기본값은 5000개의 명령어로 설정되어 있습니다. 또한, 테스트의 결과는 항상 결정론적이지만, 기본적으로 테스트는 병렬로 실행되므로 테스트 실행에서의 테스트 결과의 순서는 결정론적이지 않습니다. 단일 스레드로 실행하는 경우에만 테스트 결과의 순서가 결정론적이 됩니다 (아래의 OPTIONS 참조)."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"유닛 테스트 바이너리에 전달할 수 있는 여러 옵션이 있습니다. 이 옵션들은 테스트를 세밀하게 조정하고 실패하는 테스트를 디버깅하는 데 도움이 됩니다. 도움말 플래그를 사용하여 이를 확인할 수 있습니다."})]}),(0,r.jsx)(g,{code:"  $ aptos move test -h\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsxs)(d.Z,{variant:"h4",gutterBottom:!0,children:["Example"," "]})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음 예시에서는 단위 테스트 기능을 사용하는 간단한 모듈을 보여줍니다. 먼저 비어있는 디렉토리 내에 빈 패키지를 생성합니다."})}),(0,r.jsx)(g,{code:"  $ aptos move init --name TestExample\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음을 Move.toml 파일에 추가하십시오."})}),(0,r.jsx)(g,{code:'  [dependencies]\n  MoveStdlib = { git = "https://github.com/aptos-labs/aptos-core.git", subdir="aptos-move/framework/move-stdlib", rev = "main", addr_subst = { "std" = "0x1" } }\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음으로, 다음 모듈을 sources 디렉토리 아래에 추가하십시오."})}),(0,r.jsx)(g,{code:"  // filename: sources/my_module.move\n  module 0x1::my_module {\n  \n      struct MyCoin has key { value: u64 }\n  \n      public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n          assert!(coin.value > 0, 0);\n          coin\n      }\n  \n      public fun has_coin(addr: address): bool {\n          exists<MyCoin>(addr)\n      }\n  \n      #[test]\n      fun make_sure_non_zero_coin_passes() {\n          let coin = MyCoin { value: 1 };\n          let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n      }\n  \n      #[test]\n      // Or #[expected_failure] if we don't care about the abort code\n      #[expected_failure(abort_code = 0, location = Self)]\n      fun make_sure_zero_coin_fails() {\n          let coin = MyCoin { value: 0 };\n          let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n      }\n  \n      #[test_only] // test only helper function\n      fun publish_coin(account: &signer) {\n          move_to(account, MyCoin { value: 1 })\n      }\n  \n      #[test(a = @0x1, b = @0x2)]\n      fun test_has_coin(a: signer, b: signer) {\n          publish_coin(&a);\n          publish_coin(&b);\n          assert!(has_coin(@0x1), 0);\n          assert!(has_coin(@0x2), 1);\n          assert!(!has_coin(@0x3), 1);\n      }\n  }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"테스트 실행하기"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그런 다음 aptos move test 명령으로 이러한 테스트를 실행할 수 있습니다."})}),(0,r.jsx)(g,{code:"  $ aptos move test\n  BUILDING MoveStdlib\n  BUILDING TestExample\n  Running Move unit tests\n  [ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n  [ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n  [ PASS    ] 0x1::my_module::test_has_coin\n  Test result: OK. Total tests: 3; passed: 3; failed: 0\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"테스트 플래그 사용하기"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"  -f <str> or --filter <str>"}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["이 명령은 fully qualified name에 ","<str>",'을 포함하는 테스트만 실행합니다. 예를 들어, 이름에 "zero_coin"이 포함된 테스트만 실행하려면:']})]}),(0,r.jsx)(g,{code:"  $ aptos move test -f zero_coin\n  CACHED MoveStdlib\n  BUILDING TestExample\n  Running Move unit tests\n  [ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n  [ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n  Test result: OK. Total tests: 2; passed: 2; failed: 0\n"}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"--coverage"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 명령은 테스트 케이스로 커버되는 코드를 계산하고 커버리지 요약을 생성합니다."})]}),(0,r.jsx)(g,{code:"  $ aptos move test --coverage\n  INCLUDING DEPENDENCY AptosFramework\n  INCLUDING DEPENDENCY AptosStdlib\n  INCLUDING DEPENDENCY MoveStdlib\n  BUILDING TestExample\n  Running Move unit tests\n  [ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n  [ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n  [ PASS    ] 0x1::my_module::test_has_coin\n  Test result: OK. Total tests: 3; passed: 3; failed: 0\n  +-------------------------+\n  | Move Coverage Summary   |\n  +-------------------------+\n  Module 0000000000000000000000000000000000000000000000000000000000000001::my_module\n  >>> % Module coverage: 100.00\n  +-------------------------+\n  | % Move Coverage: 100.00  |\n  +-------------------------+\n  Please use `aptos move coverage` -h for more detailed source or bytecode test coverage of this package\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그런 다음 aptos move coverage를 실행함으로써 더 자세한 커버리지 정보를 얻을 수 있습니다. 이를 위해 도움말 플래그를 사용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  $ aptos move coverage -h\n"})]})}),$=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"전역 스토리지 - 구조 (Global Storage - Structure)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 프로그램의 목적은 트리 모양의 영구적인 전역 스토리지에서 읽기와 쓰기를 수행하는 것입니다. 프로그램은 이 트리 이외의 파일시스템, 네트워크 또는 다른 데이터에 접근할 수 없습니다. 의사 코드로 표현하면 전역 스토리지는 다음과 같습니다."})}),(0,r.jsx)(g,{code:"  #[test] // OK\n  fun this_is_a_test() { ... }\n  \n  #[test] // Will fail to compile since the test takes an argument\n  fun this_is_not_correct(arg: signer) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"구조적으로, 전역 스토리지는 계정 주소를 루트로 하는 트리로 구성된 포레스트입니다. 각 주소는 리소스 데이터 값과 모듈 코드 값 모두를 저장할 수 있습니다. 위의 의사 코드에서와 같이"})})]})}),J=()=>{let e=(0,A.ZP)(b.Z)(e=>{let{theme:t}=e;return{["&.".concat(y.Z.head)]:{backgroundColor:" #171B1C",color:t.palette.common.white},["&.".concat(y.Z.body)]:{fontSize:12}}}),t=(0,A.ZP)(w.Z)(e=>{let{theme:t}=e;return{"&:nth-of-type(odd)":{backgroundColor:t.palette.common.white,color:t.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsxs)(o.Z,{container:!0,children:[(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"전역 스토리지 - 연산자 (Global Storage - Operators)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 프로그램은 다음 다섯 가지 명령어를 사용하여 전역 스토리지에서 리소스를 생성, 삭제 및 업데이트할 수 있습니다."})})]}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsx)(o.Z,{xs:12,md:8,sx:{marginTop:"30px"},children:(0,r.jsx)(T.Z,{component:B.Z,children:(0,r.jsxs)(v.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(_.Z,{children:(0,r.jsxs)(w.Z,{children:[(0,r.jsx)(e,{children:"유형"}),(0,r.jsx)(e,{children:"값 범위"}),(0,r.jsx)(e,{children:"값 범위"})]})}),(0,r.jsx)(f.Z,{component:"div",children:[{통사론:"&e",타입:"&T where e: T and T is a non-reference type	",설명:"e에 대한 불변 참조 생성"},{통사론:"&mut e",타입:"&mut T where e: T and T is a non-reference type	",설명:"e에 대한 변경 가능한 참조를 만듭니다."},{통사론:"&e.f",타입:"&T where e.f: T",설명:"구조체 e의 필드 f에 대한 불변 참조를 만듭니다."},{통사론:"&mut e.f",타입:"&mut T where e.f: T	",설명:"구조체의 필드 f에 대한 변경 가능한 참조를 만듭니다."},{통사론:"freeze(e)",타입:"&T where e: &mut T	",설명:"가변 참조 e를 불변 참조로 변환합니다."}].map(n=>(0,r.jsxs)(t,{children:[(0,r.jsx)(e,{component:"div",scope:"row",children:null==n?void 0:n.통사론}),(0,r.jsx)(e,{children:null==n?void 0:n.타입}),(0,r.jsx)(e,{children:null==n?void 0:n.설명})]}))})]})})}),(0,r.jsx)(o.Z,{xs:0,md:2}),(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이러한 각 명령은 키 기능을 가진 타입 T에 매개변수화됩니다. 그러나 각 타입 T는 현재 모듈에서 선언되어야 합니다. 이는 리소스가 정의된 모듈에서 노출된 API를 통해서만 조작될 수 있도록 보장합니다. 또한, 이 명령어들은 타입 T의 리소스가 저장된 계정 주소를 나타내는 주소 또는 &signer를 취합니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"리소스에 대한 참조 (References to resources)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"borrow_global 또는 borrow_global_mut을 통해 반환된 전역 리소스에 대한 참조는 대부분 로컬 스토리지에 대한 참조와 유사하게 동작합니다. 일반적인 참조 연산자를 사용하여 확장, 읽기 및 쓰기가 가능하며, 다른 함수의 인수로 전달할 수도 있습니다. 그러나 로컬 참조와 전역 참조 사이에는 중요한 차이점이 있습니다: 함수는 전역 스토리지를 가리키는 참조를 반환할 수 없습니다. 예를 들어, 다음 두 함수는 각각 컴파일에 실패합니다:"})}),(0,r.jsx)(g,{code:"  #[test] // OK\n  fun this_is_a_test() { ... }\n  \n  #[test] // Will fail to compile since the test takes an argument\n  fun this_is_not_correct(arg: signer) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move는 전역 스토리지에 대한 끊어진 참조를 보장하기 위해 이 제한을 강제해야 합니다. 이 섹션에는 관심 있는 독자를 위해 더 자세한 내용이 포함되어 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"리소스에 대한 참조 (References to resources)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"전역 스토리지 작업은 인스턴스화된 및 인스턴스화되지 않은 제네릭 타입 매개변수를 가진 일반적인 리소스에 적용할 수 있습니다."})}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"런타임에서 선택된 타입 매개변수를 통해 전역 스토리지에 인덱싱하는 기능은 storage polymorphism으로 알려진 강력한 Move 기능입니다. 이 기능으로 가능한 디자인 패턴에 대해서는 Move 제네릭 문서를 참조하십시오."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"예시: Counter (카운터)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음의 간단한 Counter 모듈은 다섯 가지 전역 스토리지 연산자를 활용합니다. 이 모듈이 노출하는 API를 통해 다음이 가능합니다:"}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 누구나 자신의 계정에 Counter 리소스를 발행할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 누구나 어떤 주소에 Counter가 존재하는지 확인할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 누구나 어떤 주소에 있는 Counter 리소스의 값을 읽거나 증가시킬 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- Counter 리소스를 저장하는 계정은 해당 리소스를 0으로 재설정할 수 있습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- Counter 리소스를 저장하는 계정은 해당 리소스를 제거하고 삭제할 수 있습니다."})]}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"acquires를 사용하여 함수에 주석을 달기"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"카운터 예제에서 get_count, increment, reset 및 delete 함수에 acquires Counter로 주석이 달린 것을 알 수 있을 것입니다. Move 함수 m::f는 T를 acquires로 주석을 달아야 하는 경우에만 acquires T로 주석이 달릴 수 있습니다. 이 경우는 다음과 같습니다:"}),(0,r.jsxs)(d.Z,{variant:"body1",gutterBottom:!0,children:["- m::f의 본문에 move_from","<T>",", borrow_global_mut","<T>",", 또는 borrow_global","<T>"," 명령어가 포함되어 있는 경우, 또는"]}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"m::f의 본문에서 동일한 모듈에서 선언된 acquires로 주석이 달린 함수 m::g를 호출하는 경우."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예를 들어, Counter 내부의 다음 함수는 acquires 주석이 필요합니다."})]}),(0,r.jsx)(g,{code:"  #[test_only] // test only attributes can be attached to modules\n  module abc { ... }\n  \n  #[test_only] // test only attributes can be attached to named addresses\n  address ADDR = @0x1;\n  \n  #[test_only] // .. to uses\n  use 0x1::some_other_module;\n  \n  #[test_only] // .. to structs\n  struct SomeStruct { ... }\n  \n  #[test_only] // .. and functions. Can only be called from test code, but not a test\n  fun test_only_function(...) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그러나 Counter 외부에서 동일한 함수는 주석이 필요하지 않습니다."})}),(0,r.jsx)(g,{code:"  $ aptos move test -h\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"한 함수가 여러 리소스를 사용한다면, 해당 함수는 여러 개의 acquires를 필요로 합니다."})}),(0,r.jsx)(g,{code:"  $ aptos move init --name TestExample\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"acquires 주석은 제네릭 타입 매개변수를 고려하지 않습니다."})}),(0,r.jsx)(g,{code:'  [dependencies]\n  MoveStdlib = { git = "https://github.com/aptos-labs/aptos-core.git", subdir="aptos-move/framework/move-stdlib", rev = "main", addr_subst = { "std" = "0x1" } }\n'}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"마지막으로, 중복된 acquires는 허용되지 않습니다. Counter 내에 이 함수를 추가하면 컴파일 오류가 발생합니다."})}),(0,r.jsx)(g,{code:"  // filename: sources/my_module.move\n  module 0x1::my_module {\n  \n      struct MyCoin has key { value: u64 }\n  \n      public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n          assert!(coin.value > 0, 0);\n          coin\n      }\n  \n      public fun has_coin(addr: address): bool {\n          exists<MyCoin>(addr)\n      }\n  \n      #[test]\n      fun make_sure_non_zero_coin_passes() {\n          let coin = MyCoin { value: 1 };\n          let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n      }\n  \n      #[test]\n      // Or #[expected_failure] if we don't care about the abort code\n      #[expected_failure(abort_code = 0, location = Self)]\n      fun make_sure_zero_coin_fails() {\n          let coin = MyCoin { value: 0 };\n          let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n      }\n  \n      #[test_only] // test only helper function\n      fun publish_coin(account: &signer) {\n          move_to(account, MyCoin { value: 1 })\n      }\n  \n      #[test(a = @0x1, b = @0x2)]\n      fun test_has_coin(a: signer, b: signer) {\n          publish_coin(&a);\n          publish_coin(&b);\n          assert!(has_coin(@0x1), 0);\n          assert!(has_coin(@0x2), 1);\n          assert!(!has_coin(@0x3), 1);\n      }\n  }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'acquires에 대한 자세한 정보는 "Move 함수"를 참조하십시오.'})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"전역 리소스의 참조 안전성"})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move는 전역 참조 반환을 금지하고 acquires 주석을 요구함으로써 불안정한 참조를 방지합니다. 이를 통해 Move는 모든 참조 타입에 대해 정적인 참조 안전성(불안정한 참조, null 또는 nil 참조에 의한 오류 없음)을 제공하는 약속을 지킬 수 있습니다. 이 예시는 Move 타입 시스템이 acquires를 사용하여 불안정한 참조를 방지하는 방법을 보여줍니다."})}),(0,r.jsx)(g,{code:"  $ aptos move test\n  BUILDING MoveStdlib\n  BUILDING TestExample\n  Running Move unit tests\n  [ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n  [ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n  [ PASS    ] 0x1::my_module::test_has_coin\n  Test result: OK. Total tests: 3; passed: 3; failed: 0\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 코드에서 6번째 줄은 전역 스토리지에서 주소 a에 저장된 T에 대한 참조를 획득합니다. 그런 다음 호출된 remove_t는 해당 값을 제거하여 t_ref가 불안정한 참조가 됩니다. 다행히도, 이는 타입 시스템이 이 프로그램을 거부함으로써 발생하지 않을 것입니다. remove_t에 있는 acquires 주석은 타입 시스템에게 7번째 줄이 위험한 것을 알려줍니다. 이 때 별도로 remove_t의 본문을 다시 확인하거나 내부를 조사할 필요가 없습니다! 전역 참조 반환에 대한 제한은 비슷하지만 더 은밀한 문제를 방지합니다:"})}),(0,r.jsx)(g,{code:"  $ aptos move test -f zero_coin\n  CACHED MoveStdlib\n  BUILDING TestExample\n  Running Move unit tests\n  [ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes\n  [ PASS    ] 0x1::my_module::make_sure_zero_coin_fails\n  Test result: OK. Total tests: 2; passed: 2; failed: 0\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"16번째 줄은 전역 리소스 m1::T에 대한 참조를 획득하고, 17번째 줄에서 해당 리소스를 제거하여 t_ref가 불안정한 상태가 됩니다. 이 경우, acquires 주석은 도움이 되지 않습니다. 왜냐하면 borrow_then_remove_bad 함수가 T를 선언하는 m1 모듈 외부에 있기 때문입니다 (acquires 주석은 현재 모듈에서 선언된 리소스에만 사용할 수 있습니다). 대신, 현재 타입 시스템은 6번째 줄에서 전역 참조의 반환을 방지함으로써 이 문제를 해결합니다. 참조 안전성을 희생하지 않고도 전역 참조를 반환할 수 있는 더 고급의 타입 시스템도 가능하지만, Move의 미래 버전에서 이를 고려할 수 있습니다. 현재의 설계는 표현력, 주석 부담, 타입 시스템 복잡성 사이에서 적절한 균형을 이루고 있다고 판단하여 선택되었습니다."})})]})]})},Q=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"라이브러리 (Libraries)"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Aptos provides multiple useful libraries for developers. The Aptos는 개발자를 위한 여러 유용한 라이브러리를 제공합니다. 최신 및 완전한 문서는 여기에서 찾을 수 있습니다."})})]})}),ee=()=>(0,r.jsx)(o.Z,{container:!0,children:(0,r.jsxs)(o.Z,{xs:12,children:[(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h3",gutterBottom:!0,children:"Move 코딩 규칙"})}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"이 섹션은 Move 언어에 대한 기본적인 코딩 규칙을 설명하며, Move 팀이 도움이 되었다고 판단한 내용입니다. 이는 단순히 권장사항일 뿐이며, 다른 포맷 가이드 및 규칙을 선호하는 경우에는 자유롭게 사용할 수 있습니다."})}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"이름 짓기 (Naming)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 모듈 이름: 소문자 스네이크 케이스(lower snake case)를 사용해야 합니다. 예를 들면, fixed_point32, vector 등입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 타입 이름: 원시 타입이 아닌 경우, 카멜 케이스(camel case)를 사용해야 합니다. 예를 들면, Coin, RoleId 등입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 함수 이름: 소문자 스네이크 케이스(lower snake case)를 사용해야 합니다. 예를 들면, destroy_empty 등입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 상수 이름: 오류 코드를 나타내는 경우, 상수 이름은 대문자 카멜 케이스(upper camel case)여야 하며, 'E'로 시작해야 합니다. 예를 들면, EIndexOutOfBounds입니다. 오류가 아닌 값들을 나타내는 경우, 대문자 스네이크 케이스(upper snake case)를 사용해야 합니다. 예를 들면, MIN_STAKE입니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'- 일반적인 타입 이름: 일반적인 타입 이름은 설명적이거나, 적절한 경우에는 반대로 기술적이어야 합니다. 예를 들면, 벡터의 일반적인 타입 매개변수로는 T 또는 Element와 같은 이름을 사용합니다. 대부분의 경우, 모듈 내에서 "주요" 타입은 모듈과 동일한 이름을 가져야 합니다. 예를 들면, option::Option, fixed_point32::FixedPoint32와 같습니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 모듈 파일 이름: 모듈 파일 이름은 모듈 이름과 동일해야 합니다. 예를 들면, option.move와 같습니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:'- 스크립트 파일 이름: 스크립트 파일 이름은 소문자 스네이크 케이스(lower snake case)여야 하며, 스크립트의 "메인" 함수의 이름과 일치해야 합니다.'}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 혼합 파일 이름: 파일에 여러 모듈 및/또는 스크립트가 포함된 경우, 파일 이름은 특정 모듈/스크립트의 이름과 일치하지 않는 경우에는 소문자 스네이크 케이스(lower snake case)여야 합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"Imports"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 모든 모듈의 use 문은 모듈의 맨 위에 위치해야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 함수는 해당 함수가 선언된 모듈에서 완전한 자격 이름으로 임포트되어 사용되어야 하며, 최상위 수준에서 임포트되어서는 안 됩니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 타입은 최상위 수준에서 임포트되어야 합니다. 이름 충돌이 있는 경우, as를 사용하여 필요에 따라 로컬에서 타입 이름을 변경해야 합니다."})]}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"예를 들어, 다음과 같은 모듈이 있다고 가정해봅시다."})}),(0,r.jsx)(g,{code:"  #[test] // OK\n  fun this_is_a_test() { ... }\n  \n  #[test] // Will fail to compile since the test takes an argument\n  fun this_is_not_correct(arg: signer) { ... }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같이 임포트하고 사용됩니다."})}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"그리고, 두 모듈을 임포트할 때 로컬 이름 충돌이 있는 경우에는 다음과 같이 사용합니다."})}),(0,r.jsx)(g,{code:"  #[test]\n  #[expected_failure]\n  public fun this_test_will_abort_and_pass() { abort 1 }\n  \n  #[test]\n  #[expected_failure]\n  public fun test_will_error_and_pass() { 1/0; }\n  \n  #[test]\n  #[expected_failure(abort_code = 0, location = Self)]\n  public fun test_will_error_and_fail() { 1/0; }\n  \n  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.\n  public fun this_other_test_will_abort_and_pass() { abort 1 }\n"}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"주석(Comments)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 각 모듈, 구조체, 그리고 공개 함수 선언은 주석이 달려야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- Move 언어에서는 문서 주석을 나타내는 ///, 일반적인 한 줄 주석을 나타내는 //, 블록 주석을 나타내는 /* /, 그리고 블록 문서 주석을 나타내는 /* */을 사용합니다"})]}),(0,r.jsx)(l.Z,{sx:{width:"100%"},children:(0,r.jsx)(d.Z,{variant:"h4",gutterBottom:!0,children:"서식 맞추기 (Formatting)"})}),(0,r.jsxs)(l.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"Move 팀은 서식 규칙을 강제하는 자동 서식 지원 도구를 작성할 계획입니다. 그러나 그 도구가 준비될 때까지는 다음과 같은 방법으로 서식을 맞추어야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 스크립트와 주소 블록을 제외한 내용에는 4칸 들여쓰기를 사용해야 합니다. 스크립트와 주소 블록의 내용은 들여쓰기되지 않아야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 100자를 초과하는 경우, 줄은 나누어져야 합니다."}),(0,r.jsx)(d.Z,{variant:"body1",gutterBottom:!0,children:"- 구조체와 상수는 모듈 내의 모든 함수보다 앞서 선언되어야 합니다."})]})]})});function et(){let[e,t]=(0,s.useState)(!1),[n,a]=(0,s.useState)(0);function m(e){let{children:t,value:n,index:s,...o}=e;return(0,r.jsx)("div",{style:{textAlign:"center",width:"80%"},role:"tabpanel",hidden:n!==s,id:"vertical-tabpanel-".concat(s),"aria-labelledby":"vertical-tab-".concat(s),...o,children:n===s&&(0,r.jsx)(l.Z,{sx:{p:10,color:"white"},children:(0,r.jsx)(d.Z,{children:t})})})}function u(e){return{id:"vertical-tab-".concat(e),"aria-controls":"vertical-tabpanel-".concat(e)}}return(0,s.useEffect)(()=>{t(!0)},[]),m.propTypes={children:c().node,index:c().number.isRequired,value:c().number.isRequired},e&&(0,r.jsxs)(o.Z,{container:!0,sx:{marginTop:"84px"},children:[(0,r.jsxs)(o.Z,{xs:12,sx:{backgroundColor:" #171B1C",textAlign:"center",fontSize:"300%",color:"white"},children:[(0,r.jsx)("img",{src:"/img/move.webp",style:{width:"50px"}}),(0,r.jsx)("div",{children:"MOVE BOOK"})]}),(0,r.jsx)(o.Z,{xs:12,children:(0,r.jsxs)(l.Z,{sx:{flexGrow:1,bgcolor:" #171B1C",display:"flex",minHeight:"600px",textAlign:"center"},children:[(0,r.jsxs)(i.Z,{orientation:"vertical",variant:"scrollable",value:n,onChange:(e,t)=>{a(t)},"aria-label":"Vertical tabs example",sx:{borderRight:1,borderColor:" #171B1C",width:"16%",color:"white"},children:[(0,r.jsx)(x.Z,{sx:{color:"white"},label:"0️_소개 및 설치",...u(0)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"1️_모듈 및 스크립트",...u(1)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"2️_정수",...u(2)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"3️_부울",...u(3)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"4️_주소",...u(4)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"5️_벡터",...u(5)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"6_서명자",...u(6)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"7️_참조",...u(7)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"8️_튜플 및 단위",...u(8)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"9️_지역 변수 및 범위",...u(9)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"10_평등",...u(10)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"1️1_중단 및 어성셜",...u(11)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"12_조건부",...u(12)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"13_반복문",...u(13)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"14_기능",...u(14)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"15_구조체 리소스",...u(15)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"16_상수",...u(16)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"17️_제네릭",...u(17)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"18️_능력",...u(18)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"19️_용도 및 별칭",...u(19)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"20️_친구",...u(20)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"21_패키지",...u(21)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"22_패키지 업그레이드",...u(22)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"23️_단위 및 테스트",...u(23)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"24️_글로벌 스토리지 구조",...u(24)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"25_글로벌 스토리지 사업자",...u(25)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"26_도서관",...u(26)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"27️_코딩 규칙 이동",...u(27)}),(0,r.jsx)(x.Z,{sx:{color:"white"},label:"\uD83E\uDD28 tutorial",...u(28)})]}),(0,r.jsx)(m,{value:n,index:0,children:(0,r.jsx)(h,{})}),(0,r.jsx)(m,{value:n,index:1,children:(0,r.jsx)(Z,{})}),(0,r.jsx)(m,{value:n,index:2,children:(0,r.jsx)(C,{})}),(0,r.jsx)(m,{value:n,index:3,children:(0,r.jsx)(M,{})}),(0,r.jsx)(m,{value:n,index:4,children:(0,r.jsx)(k,{})}),(0,r.jsx)(m,{value:n,index:5,children:(0,r.jsx)(F,{})}),(0,r.jsx)(m,{value:n,index:6,children:(0,r.jsx)(S,{})}),(0,r.jsx)(m,{value:n,index:7,children:(0,r.jsx)(E,{})}),(0,r.jsx)(m,{value:n,index:8,children:(0,r.jsx)(D,{})}),(0,r.jsx)(m,{value:n,index:9,children:(0,r.jsx)(z,{})}),(0,r.jsx)(m,{value:n,index:10,children:(0,r.jsx)(P,{})}),(0,r.jsx)(m,{value:n,index:11,children:(0,r.jsx)(R,{})}),(0,r.jsx)(m,{value:n,index:12,children:(0,r.jsx)(O,{})}),(0,r.jsx)(m,{value:n,index:13,children:(0,r.jsx)(I,{})}),(0,r.jsx)(m,{value:n,index:14,children:(0,r.jsx)(q,{})}),(0,r.jsx)(m,{value:n,index:15,children:(0,r.jsx)(U,{})}),(0,r.jsx)(m,{value:n,index:16,children:(0,r.jsx)(V,{})}),(0,r.jsx)(m,{value:n,index:17,children:(0,r.jsx)(X,{})}),(0,r.jsx)(m,{value:n,index:18,children:(0,r.jsx)(L,{})}),(0,r.jsx)(m,{value:n,index:19,children:(0,r.jsx)(Y,{})}),(0,r.jsx)(m,{value:n,index:20,children:(0,r.jsx)(G,{})}),(0,r.jsx)(m,{value:n,index:21,children:(0,r.jsx)(H,{})}),(0,r.jsx)(m,{value:n,index:22,children:(0,r.jsx)(W,{})}),(0,r.jsx)(m,{value:n,index:23,children:(0,r.jsx)(K,{})}),(0,r.jsx)(m,{value:n,index:24,children:(0,r.jsx)($,{})}),(0,r.jsx)(m,{value:n,index:25,children:(0,r.jsx)(J,{})}),(0,r.jsx)(m,{value:n,index:26,children:(0,r.jsx)(Q,{})}),(0,r.jsx)(m,{value:n,index:27,children:(0,r.jsx)(ee,{})}),(0,r.jsx)(m,{value:n,index:28,children:"튜토리얼"})]})})]})}}},function(e){e.O(0,[939,774,888,179],function(){return e(e.s=48312)}),_N_E=e.O()}]);