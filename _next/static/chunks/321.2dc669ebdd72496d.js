"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[321],{34068:function(n,e,t){t.r(e);var i=t(85893),r=t(41181),o=t(15861),x=t(87357),d=t(38154);e.default=()=>(0,i.jsx)(r.ZP,{container:!0,children:(0,i.jsxs)(r.ZP,{xs:12,children:[(0,i.jsx)(x.Z,{sx:{width:"100%"},children:(0,i.jsxs)(o.Z,{variant:"h3",gutterBottom:!0,children:["Friends"," "]})}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"friend 문법은 현재 모듈에서 신뢰할 수 있는 모듈을 선언하는 데 사용됩니다. 신뢰할 수 있는 모듈은 현재 모듈에서 public(friend) 가시성을 가진 모든 함수를 호출할 수 있습니다. 함수의 가시성에 대한 자세한 내용은 Functions 섹션의 가시성을 참조하십시오."})}),(0,i.jsx)(x.Z,{sx:{width:"100%"},children:(0,i.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"친구 선언 (Friend declaration)"})}),(0,i.jsxs)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"모듈은 friend 선언문을 통해 다른 모듈을 친구로 선언할 수 있습니다. 이는 다음과 같은 형식으로 사용됩니다."}),(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"- friend address::name - 아래 예시와 같이 완전한 모듈 이름을 사용한 친구 선언, 또는"})]}),(0,i.jsx)(d.Z,{code:"  module 0x42::a {\n    friend 0x42::b;\n\n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsxs)(o.Z,{variant:"body1",gutterBottom:!0,children:["- friend ","<module-name-alias>"," - use 문을 통해 도입된 모듈 이름 별칭을 사용한 친구 선언입니다."]})}),(0,i.jsx)(d.Z,{code:"  module 0x42::a {\n    use 0x42::b;\n    friend b; \n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"한 모듈은 여러 개의 친구 선언을 가질 수 있으며, 모든 친구 모듈의 합집합은 친구 목록을 형성합니다. 아래 예시에서는 0x42::B와 0x42::C가 0x42::A의 친구로 간주됩니다."})}),(0,i.jsx)(d.Z,{code:"  module 0x42::a {\n    friend 0x42::b;\n    friend 0x42::c;\n}\n"}),(0,i.jsxs)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:[(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"use 문과는 달리, friend는 표현식 블록 범위가 아닌 모듈 범위에서만 선언할 수 있습니다. friend 선언은 use, function, struct 등의 최상위 구조가 허용되는 위치에 배치할 수 있습니다. 그러나 가독성을 위해 friend 선언을 모듈 정의의 시작 부근에 배치하는 것이 권장됩니다."}),(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"친구 개념은 Move 스크립트에 적용되지 않습니다: Move 스크립트는 스크립트에서 정의된 함수를 호출하는 메커니즘이 없으므로 스크립트는 친구 모듈을 선언할 수 없습니다. Move 모듈도 스크립트를 친구로 선언할 수 없습니다. 스크립트는 일회성의 코드 조각이며 전역 저장소에 게시되지 않기 때문입니다."})]}),(0,i.jsx)(x.Z,{sx:{width:"100%"},children:(0,i.jsx)(o.Z,{variant:"h4",gutterBottom:!0,children:"친구 선언 규칙"})}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"친구 선언은 다음 규칙에 따릅니다: 모듈은 자신을 친구로 선언할 수 없습니다."})}),(0,i.jsx)(d.Z,{code:" module 0x42::m {\n    friend Self;//오류\n    //     ^^^^ 모듈 자체를 친구로 선언할 수 없습니다.\n}\nmodule 0x43::m {\n    friend 0x42::M;//오류\n        // ^^^^^^^ 모듈 자체를 친구로 선언할 수 없습니다.\n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"친구 모듈은 컴파일러에서 알고 있어야 합니다."})}),(0,i.jsx)(d.Z,{code:"  module 0x42::m { \n    friend 0x42::nonexistent; // ERROR! \n//   ^^^^^^^^^^^^^^^^^ 연결되지 않은 모듈 '0x42::nonexistent'입니다.\n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"친구 모듈은 동일한 계정 주소 내에 있어야 합니다. (참고: 이는 기술적인 요구사항이 아닌 정책 결정으로, 나중에 완화될 수 있습니다.)"})}),(0,i.jsx)(d.Z,{code:"  module 0x42::m {\n}\n\nmodule 0x42::n{\n    friend 0x42::m;//오류\n//       ^^^^^^^ 현재 주소 외부의 모듈을 친구로 선언할 수 없습니다.\n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"친구 관계에서는 순환 모듈 종속성을 생성할 수 없습니다. 친구 관계에서는 순환 사이클을 허용하지 않습니다. 예를 들어, 0x2::a가 0x2::b를 친구로 선언하고, 0x2::b가 0x2::c를 친구로 선언하고, 0x2::c가 다시 0x2::a를 친구로 선언하는 관계는 허용되지 않습니다. 일반적으로, 친구 모듈을 선언하면 친구 모듈은 현재 모듈에 대한 종속성이 추가됩니다 (친구가 현재 모듈의 함수를 호출하는 것이 목적이기 때문입니다). 만약 해당 친구 모듈이 이미 직접적으로나 간접적으로 사용되고 있다면, 종속성의 순환 사이클이 생성됩니다."})}),(0,i.jsx)(d.Z,{code:"  module 0x2::a{\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a(){\n        c::c()\n    }\n}\n\nmodule 0x2::b{\n    friend 0x2::c;//오류\n        // ^^^^^^ 이 친구 관계는 종속성 사이클을 생성합니다: '0x2::b'는 '0x2::a'의 친구이며 '0x2::c'를 사용하고, '0x2::c'는 '0x2::b'의 친구입니다.\n}\n\nmodule 0x2::c {\n    public fun c(){}\n}\n"}),(0,i.jsx)(x.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,i.jsx)(o.Z,{variant:"body1",gutterBottom:!0,children:"한 모듈의 친구 목록에는 중복된 항목이 포함될 수 없습니다."})}),(0,i.jsx)(d.Z,{code:"  module 0x42::a {}\n  module 0x42::m {\n      use 0x42::a as aliased_a;\n      friend aliased_a;//오류\n      // ^^^^^^^^^ 중복된 친구 선언 '0x42::a'입니다. 모듈 내의 친구 선언은 고유해야 합니다.\n  }\n"})]})})},38154:function(n,e,t){t.d(e,{Z:function(){return l}});var i=t(85893),r=t(74855),o=t(34209),x=t(84283),d=t(90066),s=t(67294);function l(n){let{code:e}=n,[t,l]=(0,s.useState)(!1),[a,c]=(0,s.useState)(!1),[u,h]=(0,s.useState)(!1);return(0,i.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{c(!0)},onMouseLeave:()=>{c(!1)},children:[(0,i.jsx)(o.Z,{language:"javascript",style:x.cL,children:e}),(0,i.jsx)(r.CopyToClipboard,{text:e,children:(0,i.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),l(!0),h(!0),setTimeout(()=>{l(!1),h(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:a?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:u?(0,i.jsx)(d.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,i.jsx)(d.Z,{style:{color:t?"#fff":"#000",transition:"color 0.3s"}})})})]})}}}]);