"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[609],{1609:function(t,e,n){n.r(e);var r=n(85893),o=n(41181),i=n(15861),s=n(87357),a=n(38154);e.default=()=>(0,r.jsx)(o.ZP,{container:!0,children:(0,r.jsxs)(o.ZP,{xs:12,children:[(0,r.jsx)(s.Z,{sx:{width:"100%"},children:(0,r.jsx)(i.Z,{variant:"h3",gutterBottom:!0,children:"Abort와 Assert"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"return과 abort는 실행을 종료하는 두 개의 제어 흐름 구조입니다. return은 현재 함수의 실행을 종료하고, abort는 전체 트랜잭션을 종료합니다."})}),(0,r.jsx)(s.Z,{sx:{width:"100%"},children:(0,r.jsx)(i.Z,{variant:"h4",gutterBottom:!0,children:"Abort"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"abort는 하나의 인수를 받는 표현식으로, u64 타입의 중단 코드를 의미합니다. 예를 들어:"})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    fun main(){\n        abort 42\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:'abort 표현식은 현재 함수의 실행을 중단하고, 현재 트랜잭션에 의해 전역 상태에 가해진 모든 변경 사항을 되돌립니다. abort를 "catch"하거나 다른 방식으로 처리하는 메커니즘은 존재하지 않습니다.'})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:'다행히도 Move에서는 트랜잭션은 "모두 또는 아무것도"의 원칙을 따르며, 트랜잭션이 성공한 경우에만 전역 스토리지에 대한 모든 변경 사항이 한 번에 이루어집니다. 이러한 트랜잭션의 변경 사항 커밋 기능으로 인해, 중단된 후에는 변경 사항을 되돌리는 작업에 대해 걱정할 필요가 없습니다. 이 접근 방식은 유연성이 부족하지만 매우 간단하고 예측 가능합니다.'})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"abort는 return과 유사하게, 어떤 조건을 충족시킬 수 없을 때 제어 흐름을 종료하는 데 유용합니다."})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"이 예제에서는 함수가 벡터에서 두 개의 항목을 꺼내오지만, 벡터에 두 개의 항목이 없는 경우에는 중간에 실행을 중단할 것입니다."})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    use std::vector;\n    fun pop_twice<T>(v:&mut vector<T>):(T,T){\n        if (vector::length(v)<2)abort 42;\n\n        (vector::pop_back(v),vector::pop_back(v))\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"이는 제어 흐름 구조 내부에서 더욱 유용합니다. 예를 들어, 이 함수는 벡터 내의 모든 숫자가 지정된 한계 값보다 작은지 확인하고, 그렇지 않은 경우 중단합니다."})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    use std::vector;\n    fun check_vec(v:&vector<u64>,bound:u64){\n        let i = 0;\n        let n = vector::length(v);\n        while (i < n){\n            let cur = *vector::borrow(v,i);\n            if (cur>bound)abort 42;\n            i = i+1;\n        }\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%"},children:(0,r.jsx)(i.Z,{variant:"h4",gutterBottom:!0,children:"Assert"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"assert는 Move 컴파일러에서 제공하는 내장 매크로와 유사한 연산입니다. assert는 두 개의 인자를 받습니다. 첫 번째는 bool 타입의 조건(condition)이고, 두 번째는 u64 타입의 코드(code)입니다."})}),(0,r.jsx)(a.Z,{code:"  module exmaple::test {\n    fun main(){\n      assert!(condition: bool, code: u64)\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"assert는 매크로로 구현되어 있기 때문에 호출 시에는 느낌표(!)를 사용해야 합니다. 이는 assert의 인자가 표현식으로 호출되는 것을 나타내기 위한 것입니다. 다시 말해, assert는 일반적인 함수가 아니며 바이트코드 수준에서 존재하지 않습니다. 컴파일러 내부에서 번역되어 처리됩니다."})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    fun main(){\n        if (continue) () else abort code\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"assert는 abort 단독으로 사용되는 것보다 더 일반적으로 사용됩니다. 위의 abort 예제들은 assert를 사용하여 다시 작성할 수 있습니다."})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    use std::vector;\n    fun pop_twice<T>(v:&mut vector<T>):(T,T){\n        assert!(vector::length(v) >= 2,42);//이제 'assert'를 사용합니다.\n\n        (vector::pop_back(v),vector::pop_back(v))                \n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"and"})}),(0,r.jsx)(a.Z,{code:"  module example::test {\n    use std::vector;\n    fun check_vec(v:&vector<u64>,bound:u64){\n        let i = 0;\n        let n = vector::length(v);\n        while (i < n){\n            let cur = *vector::borrow(v,i);\n            assert!(cur <= bound ,42);//\n            i = i + 1;\n        }\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"주의할 점은 해당 작업이 이렇게 if-else로 대체되기 때문에 코드의 인자가 항상 평가되지는 않는다는 것입니다. 예를 들어:"})}),(0,r.jsx)(a.Z,{code:"   assert!(true,1/0)"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"산술 오류가 발생하지 않으며, 다음과 동등합니다:"})})," ",(0,r.jsx)(a.Z,{code:"if (true) () else (1/0)"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"따라서 산술식은 평가되지 않습니다!"})}),(0,r.jsx)(s.Z,{sx:{width:"100%"},children:(0,r.jsx)(i.Z,{variant:"h4",gutterBottom:!0,children:"Move VM에서의 중단 코드"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"abort를 사용할 때는 u64 코드가 VM에서 어떻게 사용되는지 이해하는 것이 중요합니다."})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"일반적으로 성공적인 실행 후에 Move VM은 전역 스토리지에 대한 변경 사항(리소스 추가/제거, 기존 리소스 업데이트 등)에 대한 변경 세트를 생성합니다."})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"중단(abort)이 발생하는 경우 VM은 오류를 나타내며, 해당 오류에는 두 가지 정보가 포함됩니다:"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"    ⇥ 발생한 중단(abort)을 생성한 모듈(주소와 이름)"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"    ⇥ 중단 코드"})}),(0,r.jsx)(a.Z,{code:"   address 0x42 {\n    module example {\n        public fun aborts(){\n            abort 42\n        }\n    }\n}\n\nscript {\n    fun always_abort() {\n        0x2::example::aborts()\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"만약 위에서 언급한 스크립트인 always_aborts와 같은 트랜잭션이 0x2::example::aborts를 호출하면, VM은 모듈 0x2::example과 코드 42를 나타내는 오류를 생성합니다. 이는 모듈 내에서 여러 중단(abort)을 그룹화하는 데 유용할 수 있습니다. 이 예시에서는 모듈에 두 개의 별도 오류 코드가 있으며, 여러 함수에서 사용됩니다."})}),(0,r.jsx)(a.Z,{code:"   address 0x42 {\n    module example {\n        use std::vector;\n\n        const EMPTY_VECTOR : u64 = 0;\n        const INDEX_OUT_OF_BOUNDES:u64  = 1;\n\n        // move i to j, move j to k, move k to i\n        public fun rotate_three<T>(v:&mut vector<T>,i:u64,j:u64,k:u64){\n            let n = vector::length(v);\n            assert!(n>0,EMPTY_VECTOR);\n            assert!(i<n,INDEX_OUT_OF_BOUNDES);\n            assert!(j<n,INDEX_OUT_OF_BOUNDES);\n            assert!(k<n,INDEX_OUT_OF_BOUNDES);\n\n            vector::swap(v, i, k);\n            vector::swap(v, j, k);\n        }\n\n        public fun remove_twice<T>(v:&mut vector<T>,i:u64,j:u74):(T,T){\n           let n = vector::length(v); \n           assert!(n>0,EMPTY_VECTOR);\n           assert!(i<n,INDEX_OUT_OF_BOUNDES);\n           assert!(j<n,INDEX_OUT_OF_BOUNDES);\n           assert!(i>j,INDEX_OUT_OF_BOUNDES);\n           \n           (vector::remove<T>(v,i),vector::remove<T>(v,j))\n        }\n    } \n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%"},children:(0,r.jsx)(i.Z,{variant:"h4",gutterBottom:!0,children:"중단(abort)의 종류"})}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"abort 식은 어떤 타입이든 가질 수 있습니다! 이는 두 개의 구조 모두 일반적인 제어 흐름을 탈출하기 때문에 해당 타입의 값을 평가할 필요가 없기 때문입니다. 다음은 유용하지는 않지만 타입 체크를 통과할 것입니다."})}),(0,r.jsx)(a.Z,{code:"   module example::test {\n    fun main(){\n        let y:address = abort 0;\n    }\n}\n"}),(0,r.jsx)(s.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(i.Z,{variant:"body1",gutterBottom:!0,children:"이 동작은 가지 분기 지시문에서 일부 분기에서 값이 생성되지만 다른 분기에서는 생성되지 않는 상황에서 유용할 수 있습니다. 예를 들어:"})}),(0,r.jsx)(a.Z,{code:"   module example::test {\n    fun main(){\n        let b = \n             if(x==0)false\n             else if (x==1)true\n             else abort 42;\n               // ^^^^^^^^ abort 42의 타입은 bool입니다.\n    }\n}\n"})]})})},38154:function(t,e,n){n.d(e,{Z:function(){return x}});var r=n(85893),o=n(74855),i=n(34209),s=n(84283),a=n(90066),l=n(67294);function x(t){let{code:e}=t,[n,x]=(0,l.useState)(!1),[d,c]=(0,l.useState)(!1),[u,h]=(0,l.useState)(!1);return(0,r.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{c(!0)},onMouseLeave:()=>{c(!1)},children:[(0,r.jsx)(i.Z,{language:"javascript",style:s.cL,children:e}),(0,r.jsx)(o.CopyToClipboard,{text:e,children:(0,r.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),x(!0),h(!0),setTimeout(()=>{x(!1),h(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:d?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:u?(0,r.jsx)(a.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,r.jsx)(a.Z,{style:{color:n?"#fff":"#000",transition:"color 0.3s"}})})})]})}}}]);