"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[942],{81942:function(e,n,t){t.r(n);var r=t(85893),l=t(41181),s=t(15861),o=t(87357),i=t(7906),x=t(295),d=t(98102),a=t(89755),c=t(72882),u=t(53184),p=t(53816),h=t(90629),m=t(90948),j=t(38154);n.default=()=>{let e=(0,m.ZP)(d.Z)(e=>{let{theme:n}=e;return{["&.".concat(a.Z.head)]:{backgroundColor:" #171B1C",color:n.palette.common.white},["&.".concat(a.Z.body)]:{fontSize:12}}}),n=(0,m.ZP)(p.Z)(e=>{let{theme:n}=e;return{"&:nth-of-type(odd)":{backgroundColor:n.palette.common.white,color:n.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsx)(l.ZP,{container:!0,children:(0,r.jsxs)(l.ZP,{xs:12,children:[(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h3",gutterBottom:!0,children:"참조"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["Move에는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"불변 &"}),"및",(0,r.jsx)("span",{style:{color:"purple"},children:"가변 &mut"}),"의 두 가지 유형의 참조가 있습니다. 변경할 수 없는 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:" 읽기 전용"}),"이며 기본 값(또는 해당 필드)을 수정할 수 없습니다. 변경 가능한 참조는 해당 참조를 통한",(0,r.jsx)("span",{style:{color:"purple"},children:"쓰기를 통한 수정"}),"을 허용합니다. Move의 유형 시스템은 참조 오류를 방지하는 소유권 규율을 적용합니다. 참조 규칙에 대한 자세한 내용은 구조체 및 리소스를 참조하세요."]})}),(0,r.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"참조 연산자"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["Move는 참조를 만들고 확장할 뿐만 아니라 변경 가능한 참조를 변경 불가능한 참조로 변환하기 위한 연산자를 제공합니다. 여기와 다른 곳에서는",(0,r.jsx)("span",{style:{color:"purple"},children:'"표현식 e에는 T 유형이 있음"'}),"에 대해 표기법 ",(0,r.jsx)("span",{style:{color:"purple"},children:" e: T"}),"를 사용합니다."]})}),(0,r.jsx)(c.Z,{component:h.Z,children:(0,r.jsxs)(i.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(u.Z,{children:(0,r.jsxs)(p.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(x.Z,{component:"div",children:[{통사론:"&e",타입:"&T where e: T and T is a non-reference type	",설명:"e에 대한 불변 참조 생성"},{통사론:"&mut e",타입:"&mut T where e: T and T is a non-reference type	",설명:"e에 대한 변경 가능한 참조를 만듭니다."},{통사론:"&e.f",타입:"&T where e.f: T",설명:"구조체 e의 필드 f에 대한 불변 참조를 만듭니다."},{통사론:"&mut e.f",타입:"&mut T where e.f: T	",설명:"구조체의 필드 f에 대한 변경 가능한 참조를 만듭니다."},{통사론:"freeze(e)",타입:"&T where e: &mut T	",설명:"가변 참조 e를 불변 참조로 변환합니다."}].map(t=>(0,r.jsxs)(n,{children:[(0,r.jsx)(e,{children:null==t?void 0:t.통사론}),(0,r.jsx)(e,{children:null==t?void 0:t.타입}),(0,r.jsx)(e,{children:null==t?void 0:t.설명})]}))})]})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:" &e.f"}),"및",(0,r.jsx)("span",{style:{color:"purple"},children:" &mut e.f "}),"연산자는 구조체에 대한 새 참조를 만들거나 기존 참조를 확장하는 데 모두 사용할 수 있습니다."]})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun  main(){\n      let s= S {f:10}\n      let f_ref1:&u64 = &s.f; //공장\n      let s_ref:&S= &s;\n      let f_ref2: &u64= &s_ref.f //또한 작동\n    }\n   }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"여러 필드가 있는 참조 표현식은 두 구조체가 동일한 모듈에 있는 한 작동합니다."})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    struct A {b:B}\n \n    struct B {\n        c:u64\n    }\n \n    fun f(a:&A): &u64{\n       &a.b.c\n    }\n }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["마지막으로 참조에 대한 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:"허용되지 않습니다."})]})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun main(){\n  \n      let x= 7;\n      let y:&u64= &x;\n      let z:&&u64= &y;//컴파일 되지 않습니다.\n    }\n  }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"참고 문헌을 통한 읽기 및 쓰기"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["변경 가능한 참조와 변경 불가능한 참조를 모두 읽어 참조된 값의",(0,r.jsx)("span",{style:{color:"purple"},children:"복사본"}),"을 생성할 수 있습니다. 변경 가능한 참조만 작성할 수 있습니다. 쓰기",(0,r.jsx)("span",{style:{color:"purple"},children:" *x = v"}),"는 이전에 x에 저장된 값을 버리고 v로 업데이트합니다. 두 작업 모두 C와 유사한",(0,r.jsx)("span",{style:{color:"purple"},children:"* 구문"}),"을 사용합니다. 그러나 읽기는 표현식인 반면 쓰기는 등호의 왼쪽에서 발생해야 하는 변형입니다."]})}),(0,r.jsx)(c.Z,{component:h.Z,children:(0,r.jsxs)(i.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(u.Z,{children:(0,r.jsxs)(p.Z,{children:[(0,r.jsx)(e,{children:"통사론"}),(0,r.jsx)(e,{children:"타입"}),(0,r.jsx)(e,{children:"설명"})]})}),(0,r.jsx)(x.Z,{component:"div",children:[{통사론:"*e",타입:"T where e is &T or &mut T	",설명:"e가 가리키는 값을 읽습니다."},{통사론:"*e1 = e2	",타입:"() where e1: &mut T and e2: T	",설명:"e1의 값을 e2로 업데이트합니다."}].map(t=>(0,r.jsxs)(n,{children:[(0,r.jsx)(e,{children:null==t?void 0:t.통사론}),(0,r.jsx)(e,{children:null==t?void 0:t.타입}),(0,r.jsx)(e,{children:null==t?void 0:t.설명})]}))})]})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["참조를 읽으려면 기본 유형에",(0,r.jsx)("span",{style:{color:"purple"},children:"복사"}),"기능이 있어야 합니다. 참조를 읽으면 값의 새 복사본이 생성되기 때문입니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"이 규칙은 리소스 값 복사를 방지합니다."})]})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun copy_resource_via_ref_bad(c:Coin){\n      let c_ref= &c;\n      let counterfeit:Coin= *c_ref;//허용되지 않습니다!\n      pay(c);\n      pay(counterfeit);\n    }\n  }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["이중: 참조를 작성하려면 기본 유형에 삭제 기능이 있어야 합니다. 참조에 작성하면 이전 값이 삭제 (",(0,r.jsx)("span",{style:{color:"purple"},children:'또는 "삭제"'}),")되기 때문입니다. 이 규칙은 리소스 값의 파괴를 방지합니다."]})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun destroy_resource_via_ref_bad(ten_coins:Coin,c:Coin){\n     let ref= &mut ten_coins;\n     *ref =c;//허용되지 않음-10개의 코인을 파괴합니다!\n    }\n }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"동결 추론"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"변경 불가능한 참조가 예상되는 상황에서 변경 가능한 참조를 사용할 수 있습니다."})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun main(){\n      let x=  7;\n      let y= &u64= &mut x;\n    }\n  }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"이는 내부적으로 컴파일러가 필요한 곳에 고정 명령을 삽입하기 때문에 작동합니다. 다음은 고정 추론의 몇 가지 예입니다."})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun takes_immut_returns_immut(x:&u64):&u64{x}\n \n    //반환값에 대한 추론 고정\n    fun takes_mut_returns_immut(x:&mut u64):&u64{x}\n \n    fun expression_examples(){\n \n     let x= 0;\n     let y= 0;\n     takes_immut_returns_immut(&x);//추론없음\n     takes_immut_returns_immut(&mut x);//추정 동결(&mut x)\n     takes_mut_returns_immut(&mut x);//추론없음\n \n     assert!(&x == &mut y,42);//추정 동결(&mut y)\n    }\n    \n \n    fun assignment_examples(){\n       let x= 0;\n       let y= 0;\n       let imm_ref:&u64 = &x;\n \n       imm_ref= &x;//추론없음\n       imm_ref= &mut y;//추정 동결(&mut y)\n     \n    }\n \n    \n    \n    }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"하위 유형"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["이 동결 추론을 통해 Move 유형 검사기는",(0,r.jsx)("span",{style:{color:"purple"},children:"&mut T"}),"를",(0,r.jsx)("span",{style:{color:"purple"},children:"&T"}),"의 하위 유형으로 볼 수 있습니다. 위에 표시된 것처럼 이것은 &T 값이 사용되는 모든 표현식에 대해 &mut T 값도 사용할 수 있음을 의미합니다. 이 용어는 &T가 제공된 곳에 &mut T가 필요했음을 간결하게 나타내기 위해 오류 메시지에 사용됩니다. 예를 들어"]})}),(0,r.jsx)(j.Z,{code:"  address 0x42 {\n    module example{\n        fun read_and_assign(store:&mut u64,new_value:&u64){\n            *store= *new_value\n        }\n\n        fun subtype_examples(){\n            let x:&u64 = &0;\n            let y:&mut u64= &mut 1;\n\n            x= &mut 1;//유효한\n            y= &2 //유효하지 않은\n\n            read_and_assign(y,x);//유효한\n            read_and_assign(x,y);//유효하지 않은\n        }  \n    }\n}\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"다음과 같은 오류 메시지가 나타납니다"})}),(0,r.jsx)(j.Z,{code:"  error:\n\n  ┌── example.move:12:9 ───\n  │\n12 │         y = &2; // 유효하지 않은!\n  │         ^ Invalid assignment to local 'y'\n  \xb7\n12 │         y = &2; // 유효하지 않음!\n  │             -- The type: '&{integer}'\n  \xb7\n9 │         let y: &mut u64 = &mut 1;\n  │                -------- Is not a subtype of: '&mut u64'\n  │\n\nerror:\n\n  ┌── example.move:15:9 ───\n  │\n15 │         read_and_assign(x, y); // 유효하지 않음!\n  │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'\n  \xb7\n8 │         let x: &u64 = &0;\n  │                ---- The type: '&u64'\n  \xb7\n3 │     fun read_and_assign(store: &mut u64, new_value: &u64) {\n  │                                -------- Is not a subtype of: '&mut u64'\n  │\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["현재 하위 유형이 있는 유일한 다른 유형은",(0,r.jsx)("span",{style:{color:"purple"},children:"튜플"}),"입니다."]})}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"동일한 참조의 기존 복사본이나 확장이 있더라도 변경 가능한 참조와 변경 불가능한 참조는 항상 복사 및 확장될 수 있습니다."})}),(0,r.jsx)(j.Z,{code:"  module example::test {\n    fun reference_copies(s:&mut S){\n      let s_copy1=s;//유효\n      let s_extension= &mut s.f;//유효\n      let s_copy2 = s;//유효\n    }\n  }\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"이것은 위의 코드를 거부하는 Rust의 소유권 시스템에 익숙한 프로그래머에게는 놀라운 일이 될 수 있습니다. Move의 타입 시스템은 복사본 처리에 있어서 더 관대하지만 쓰기 전에 변경 가능한 참조의 고유한 소유권을 보장하는 데 있어서도 똑같이 엄격합니다."})}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"참조를 저장할 수 없음"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"참조"})," 와",(0,r.jsx)("span",{style:{color:"purple"},children:"튜플"}),"은 구조체의 필드 값으로 저장할 수 없는 ",(0,r.jsx)("span",{style:{color:"purple"},children:"유일한 유형"}),"이며, 이는",(0,r.jsx)("span",{style:{color:"purple"},children:"전역 저장소에 존재할 수 없음을 의미"}),"하기도 합니다. 프로그램 실행 중에 생성된 모든 참조는",(0,r.jsx)("span",{style:{color:"purple"},children:"Move 프로그램이 종료될 때 삭제"}),"됩니다. 그들은 완전히",(0,r.jsx)("span",{style:{color:"purple"},children:" 일시적"})," 입니다. 이 불변성은 저장 기능이 없는 유형의 값에도 적용되지만 참조와 튜플은 애초에 구조체에서 허용되지 않음으로써 한 단계 더 나아갑니다. 이것은 Move와 Rust의 또 다른 차이점으로, 구조체 내부에 참조를 저장할 수 있습니다. 현재 Move는 참조를 직렬화할 수 없기 때문에 이를 지원할 수 없지만 모든 Move 값은 직렬화 가능해야 합니다. 이 요구 사항은 프로그램 실행 간에 값을 유지하기 위해 값을 직렬화해야 하는 Move의 영구 전역 저장소에서 비롯됩니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체는 전역 저장소에 쓸 수 있으므로 직렬화 가능해야 합니다."}),"참조를 구조체에 저장하고 해당 구조체가 전역 저장소에 존재하는 것을 금지하는 더 멋지고 표현력이 뛰어난 유형 시스템을 상상할 수 있습니다. 저장 기능이 없는 구조체 내부의 참조를 허용할 수도 있지만 문제를 완전히 해결하지는 못합니다. Move에는 정적 참조 안전성을 추적하는 상당히 복잡한 시스템이 있으며 유형 시스템의 이러한 측면도 확장해야 합니다. 구조체 내부에 참조 저장을 지원합니다. 요컨대, Move의 유형 시스템(특히 참조 안전성에 관한 측면)은 저장된 참조를 지원하도록 확장되어야 합니다. 그러나 그것은 언어가 발전함에 따라 우리가 주시하고 있는 것입니다."]})})]})})}},38154:function(e,n,t){t.d(n,{Z:function(){return d}});var r=t(85893),l=t(74855),s=t(34209),o=t(84283),i=t(90066),x=t(67294);function d(e){let{code:n}=e,[t,d]=(0,x.useState)(!1),[a,c]=(0,x.useState)(!1),[u,p]=(0,x.useState)(!1);return(0,r.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{c(!0)},onMouseLeave:()=>{c(!1)},children:[(0,r.jsx)(s.Z,{language:"javascript",style:o.cL,children:n}),(0,r.jsx)(l.CopyToClipboard,{text:n,children:(0,r.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),d(!0),p(!0),setTimeout(()=>{d(!1),p(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:a?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:u?(0,r.jsx)(i.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,r.jsx)(i.Z,{style:{color:t?"#fff":"#000",transition:"color 0.3s"}})})})]})}}}]);