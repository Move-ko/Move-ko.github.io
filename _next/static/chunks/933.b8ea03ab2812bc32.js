"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[933],{26933:function(n,e,t){t.r(e);var r=t(85893),l=t(41181),s=t(15861),o=t(87357),i=t(7906),u=t(295),c=t(98102),d=t(89755),x=t(72882),a=t(53184),h=t(53816),p=t(90629),j=t(90948),m=t(38154);e.default=()=>{let n=(0,j.ZP)(c.Z)(n=>{let{theme:e}=n;return{["&.".concat(d.Z.head)]:{backgroundColor:" #171B1C",color:e.palette.common.white},["&.".concat(d.Z.body)]:{fontSize:12}}}),e=(0,j.ZP)(h.Z)(n=>{let{theme:e}=n;return{"&:nth-of-type(odd)":{backgroundColor:e.palette.common.white,color:e.palette.common.white},"&:last-child td, &:last-child th":{border:0}}});return(0,r.jsx)(l.ZP,{container:!0,children:(0,r.jsxs)(l.ZP,{xs:12,children:[(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h3",gutterBottom:!0,children:"튜플 및 단위"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["Move는 튜플을 일급 값으로 사용하는 다른 언어에서 온 것으로 예상할 수 있으므로 튜플을 완전히 지원하지 않습니다. 그러나 여러 반환 값을 지원하기 위해 Move에는",(0,r.jsx)("span",{style:{color:"purple"},children:" 튜플과 같은 표현식"}),"이 있습니다. 이러한 식은 런타임에 구체적인 값을 생성하지 않으며(",(0,r.jsx)("span",{style:{color:"purple"},children:"바이트코드에 튜플이 없음"}),") 결과적으로 매우 제한적입니다. 식에만 나타날 수 있습니다(",(0,r.jsx)("span",{style:{color:"purple"},children:"일반적으로 함수의 반환 위치"}),"). 지역 변수에 바인딩할 수 없습니다. 구조체에 저장할 수 없습니다. 제네릭을 인스턴스화하는 데 튜플 유형을 사용할 수 없습니다. 마찬가지로 ",(0,r.jsx)("span",{style:{color:"purple"},children:"unit()"}),"은 표현식 기반이 되기 위해 Move 소스 언어에서 만든 유형입니다. 단위 값()은 런타임 값을 생성하지 않습니다.",(0,r.jsx)("span",{style:{color:"purple"},children:"unit()"})," 을 빈 튜플로 간주할 수 있으며 튜플에 적용되는 모든 제한 사항이 유닛에도 적용됩니다. 이러한 제한 사항을 감안할 때 언어에 튜플이 있는 것이 이상하게 느껴질 수 있습니다. 그러나 다른 언어에서 튜플의 가장 일반적인 사용 사례 중 하나는 함수가 여러 값을 반환할 수 있도록 하는 함수입니다. 일부 언어는 사용자가 여러 반환 값을 포함하는 구조체를 작성하도록 강제하여 이 문제를 해결합니다. 그러나 Move에서는",(0,r.jsx)("span",{style:{color:"purple"},children:"구조체 내부에 참조를 넣을 수 없습니다."}),"여러 반환 값을 지원하려면 Move가 필요했습니다. 이러한 여러 반환 값은 모두 바이트 코드 수준에서 스택에 푸시됩니다. 소스 수준에서 이러한 여러 반환 값은 튜플을 사용하여 표시됩니다."]})}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"리터럴"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"튜플은 괄호 안에 쉼표로 구분된 표현식 목록으로 생성됩니다."})}),(0,r.jsx)(x.Z,{component:p.Z,children:(0,r.jsxs)(i.Z,{sx:{width:"100%"},"aria-label":"customized table",children:[(0,r.jsx)(a.Z,{children:(0,r.jsxs)(h.Z,{children:[(0,r.jsx)(n,{children:"통사론"}),(0,r.jsx)(n,{children:"타입"}),(0,r.jsx)(n,{children:"설명"})]})}),(0,r.jsx)(u.Z,{component:"div",children:[{통사론:"()",타입:"(): ()",설명:"단위, 빈 튜플 또는 인수가 0인 튜플"},{통사론:"(e1, ..., en)",타입:"(e1, ..., en): (T1, ..., Tn) where e_i: Ti s.t. 0 < i <= n and n > 0",설명:"n-튜플, 개수 n의 튜플, n개의 요소가 있는 튜플"}].map(t=>(0,r.jsxs)(e,{children:[(0,r.jsx)(n,{children:null==t?void 0:t.통사론}),(0,r.jsx)(n,{children:null==t?void 0:t.타입}),(0,r.jsx)(n,{children:null==t?void 0:t.설명})]}))})]})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:[(0,r.jsx)("span",{style:{color:"purple"},children:"(e)"})," 에는",(0,r.jsx)("span",{style:{color:"purple"},children:"(e): (t)"})," 유형이 없습니다. 즉,",(0,r.jsx)("span",{style:{color:"purple"},children:"하나의 요소가 있는 튜플이 없습니다."}),"괄호 안에 하나의 요소만 있는 경우 괄호는 명확성을 위해서만 사용되며 다른 특별한 의미는 없습니다. 때로는 요소가 두 개인 튜플을",(0,r.jsx)("span",{style:{color:"purple"},children:' "쌍"'}),"이라고 하고 요소가 세 개인 튜플을 ",(0,r.jsx)("span",{style:{color:"purple"},children:' "트리플"'}),"이라고 합니다."]})}),(0,r.jsx)(m.Z,{code:'  address 0x42 {\n    module example {\n        // 이 세 가지 기능은 모두 동일합니다.\n    \n    //반환 유형이 제공되지 않으면 ()로 간주됩니다.\n        fun returns_unit_1() { }\n    \n    \n    // 빈 표현식 블록에 암시적() 값이 있습니다.\n        fun returns_unit_2(): () { }\n    \n    \n    // returns_unit_1 및 returns_unit_2의 명시적 버전\n        fun returns_unit_3(): () { () }\n    \n    \n        fun returns_3_values(): (u64, bool, address) {\n            (0, false, @0x42)\n        }\n        fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n            (x, 0, 1, b"foobar")\n        }\n    }\n    }\n'}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"Operations"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["현재 튜플에서 수행할 수 있는 유일한 작업은",(0,r.jsx)("span",{style:{color:"purple"},children:"구조 분해"})," 입니다."]})}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"Destructuring"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"모든 크기의 튜플에 대해 let 바인딩이나 할당에서 해체될 수 있습니다."})}),(0,r.jsx)(m.Z,{code:'  address 0x42 {\n    module example {\n        \n    // 이 3개의 함수는 모두 동일합니다.\n    \n    \n     fun returns_uint(){}\n    \n     fun returns_2_values():(bool,bool){\n        (true,false)\n     } \n    \n     fun return_4_values(x:&u64):(&u64,u8,u128,vector<u8>){\n        (x,0,1,b"foobar")\n     }\n    \n     fun examples(cond:bool){\n        let ()= ();\n        let (x,y):(u8,u64)= (0,1);\n        let (a,b,c,d)= (@0x0,0,false,b"");\n    \n        ()= ();\n        (x,y)= if(cond)(1,2)else (3,4);\n        (a,b,c,d)= (@0x1,1,true,b"1");\n     }\n    \n     fun example_with_function_calls(){\n        let ()=  returns_unit();\n        let (x,y):(bool,bool)= returns_2_values();\n        let (a,b,c,d)= returns_4_values(&0);\n    \n        ()= returns_unit();\n        (x,y)= returns_2_values();\n        (a,b,c,d )= return_4_values(&1);\n     }\n  }\n}\n'}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsx)(s.Z,{variant:"body1",gutterBottom:!0,children:"자세한 내용은 변수 이동을 참조하십시오."})}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"Subtyping"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["참조와 함께 튜플은 Move에서",(0,r.jsx)("span",{style:{color:"purple"},children:"하위 유형"})," 이 있는 유일한 유형입니다. 튜플은 (",(0,r.jsx)("span",{style:{color:"purple"},children:" 공변량 방식으로"})," ) 참조가 있는 하위 유형이라는 의미에서만 하위 유형이 있습니다."]})}),(0,r.jsx)(m.Z,{code:"  let x:&u64= &0;\n  let y:&mut u64= &mut 1;\n \n  // (&u64, &mut u64)는 (&u64, &u64)의 하위 유형입니다.\n  //&mut u64는 &u64의 하위 유형이므로\n  let (a, b): (&u64, &u64) = (x, y);\n   \n\n  // (&mut u64, &mut u64)는 (&u64, &u64)의 하위 유형입니다.\n  // &mut u64는 &u64의 하위 유형이므로 \n  let (c, d): (&u64, &u64) = (y, y);\n  \n\n   // 오류! (&u64, &mut u64)는 (&mut u64, &mut u64)의 하위 유형이 아닙니다.\n  // &u64는 &mut u64의 하위 유형이 아니므로\n\n  let (e, f): (&mut u64, &mut u64) = (x, y);\n"}),(0,r.jsx)(o.Z,{sx:{width:"100%"},children:(0,r.jsx)(s.Z,{variant:"h4",gutterBottom:!0,children:"소유권"})}),(0,r.jsx)(o.Z,{sx:{width:"100%",textAlign:"left",marginTop:"30px"},children:(0,r.jsxs)(s.Z,{variant:"body1",gutterBottom:!0,children:["위에서 언급했듯이 튜플 값은 런타임에 실제로",(0,r.jsx)("span",{style:{color:"purple"},children:" 존재하지 않습니다. "}),"그리고 현재 이 때문에 로컬 변수에 저장할 수 없습니다(",(0,r.jsx)("span",{style:{color:"purple"},children:"그러나 이 기능이 곧 제공될 가능성이 높습니다"}),"). 따라서 튜플을 복사하려면 먼저 지역 변수에 넣어야 하므로 튜플은 현재에만 이동할 수 있습니다."]})})]})})}},38154:function(n,e,t){t.d(e,{Z:function(){return c}});var r=t(85893),l=t(74855),s=t(34209),o=t(84283),i=t(90066),u=t(67294);function c(n){let{code:e}=n,[t,c]=(0,u.useState)(!1),[d,x]=(0,u.useState)(!1),[a,h]=(0,u.useState)(!1);return(0,r.jsxs)("div",{style:{position:"relative"},onMouseEnter:()=>{x(!0)},onMouseLeave:()=>{x(!1)},children:[(0,r.jsx)(s.Z,{language:"javascript",style:o.cL,children:e}),(0,r.jsx)(l.CopyToClipboard,{text:e,children:(0,r.jsx)("button",{onClick:()=>{console.log("코드가 복사되었습니다."),c(!0),h(!0),setTimeout(()=>{c(!1),h(!1)},1e3)},style:{position:"absolute",top:"0",right:"0",margin:"8px",padding:"8px",background:"none",border:"none",cursor:"pointer",opacity:d?1:0,transition:"opacity 0.3s",display:"flex",alignItems:"center"},children:a?(0,r.jsx)(i.Z,{style:{color:"#fff",transition:"color 0.3s"}}):(0,r.jsx)(i.Z,{style:{color:t?"#fff":"#000",transition:"color 0.3s"}})})})]})}}}]);